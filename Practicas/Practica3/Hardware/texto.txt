// Code generated by Icestudio 0.12
// Sun, 20 Apr 2025 10:50:28 GMT

`default_nettype none

//---- Top entity
module main #(
 parameter v269dbc = 'h0400_0000,
 parameter v9c4340 = 100000
) (
 input v87186f,
 input v4dc0ee,
 input [31:0] v867561,
 input v8859f4,
 input [31:0] v23504b,
 output v9127c2,
 output vfe2384,
 output [31:0] v504d16,
 output [0:7] vinit,
 inout v80923c
);
 localparam p0 = v269dbc;
 localparam p3 = v9c4340;
 wire w1;
 wire w2;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire [0:31] w11;
 wire [0:31] w12;
 wire [0:31] w13;
 wire w14;
 wire [0:31] w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire [0:6] w21;
 wire [0:7] w22;
 wire [0:7] w23;
 wire [0:7] w24;
 wire [0:3] w25;
 assign w4 = v87186f;
 assign w5 = v87186f;
 assign w6 = v4dc0ee;
 assign w7 = v4dc0ee;
 assign v9127c2 = w8;
 assign w9 = v80923c;
 assign vfe2384 = w10;
 assign w11 = v867561;
 assign w12 = v867561;
 assign v504d16 = w13;
 assign w14 = v8859f4;
 assign w15 = v23504b;
 assign w5 = w4;
 assign w7 = w6;
 assign w12 = w11;
 vf9bdaf #(
  .v6b316b(p0)
 ) v72f060 (
  .v18e78c(w1),
  .ve1f562(w11)
 );
 vb2090f vef47e6 (
  .v0e28cb(w1),
  .v3ca442(w14),
  .vcbab45(w18)
 );
 v0e64bc #(
  .v207e0d(p3)
 ) v9f9653 (
  .v8337bc(w2),
  .v531e20(w4)
 );
 main_v571ff6 v571ff6 (
  .clk(w2),
  .rst(w6),
  .I2C_SCL(w8),
  .I2C_SDA(w9),
  .data_ready(w16),
  .enable(w17),
  .rw(w19),
  .I2C_BUSY(w20),
  .slv_addr(w21),
  .reg_obj(w22),
  .data_in(w23),
  .data_out(w24),
  .data_size(w25)
 );
 main_vecfcb9 vecfcb9 (
  .clk(w5),
  .rst(w7),
  .bus_data_enable(w10),
  .Bus_addr(w12),
  .bus_data_out(w13),
  .Bus_data(w15),
  .new_data_ready(w16),
  .enable_start(w17),
  .serdat_cs(w18),
  .rw(w19),
  .I2C_Busy(w20),
  .slv_addr(w21),
  .reg_obj(w22),
  .data_write(w23),
  .data_out(w24),
  .data_size(w25)
 );
 assign vinit = 8'b00000000;
endmodule

//---------------------------------------------------
//-- I2C
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Periférico encargado de la comunicación a través del bus I2C.
//---------------------------------------------------
//---- Top entity
module vf9bdaf #(
 parameter v6b316b = 0
) (
 input [31:0] ve1f562,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = ve1f562;
 vf9bdaf_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 32 bits. Se compara si el operando es igual al parámetro
//---------------------------------------------------

module vf9bdaf_vd75681 #(
 parameter K = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a[31:8] == K[31:8]);
endmodule
//---- Top entity
module vb2090f (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vb2090f_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND
//---------------------------------------------------

module vb2090f_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta AND
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a & b;
 
 //-- endmodule
endmodule
//---- Top entity
module v0e64bc #(
 parameter v207e0d = 1
) (
 input v531e20,
 output v8337bc
);
 localparam p2 = v207e0d;
 wire w0;
 wire w1;
 assign v8337bc = w0;
 assign w1 = v531e20;
 v0e64bc_v94c6d7 #(
  .HZ(p2)
 ) v94c6d7 (
  .clk_o(w0),
  .clk(w1)
 );
endmodule

//---------------------------------------------------
//-- Corazon_Hz
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Corazon genérico para bombear bits a la frecuencia fijada en Hz (por defecto 1Hz)
//---------------------------------------------------

module v0e64bc_v94c6d7 #(
 parameter HZ = 0
) (
 input clk,
 output clk_o
);
 
 //parameter HZ=1;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000/HZ;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- REgistro con el valor del reloj
 reg clk_out = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_out <= ~clk_out;
 
 
 assign clk_o = clk_out;  
 
endmodule

module main_v571ff6 (
 input clk,
 input rst,
 input enable,
 input rw,
 input [6:0] slv_addr,
 input [7:0] reg_obj,
 input [7:0] data_in,
 input [3:0] data_size,
 output data_ready,
 output I2C_BUSY,
 output [7:0] data_out,
 output I2C_SCL,
 inout I2C_SDA
);
     // Definir los estados de la máquina de estados
     localparam READY            = 0;
     localparam START            = 1;
     localparam COMMAND          = 2;
     localparam SLV_OBJ_ACK      = 3;
     localparam WRITE_DATA       = 4;
     localparam WRITE_ACK        = 5;
     localparam READ_DATA        = 6;
     localparam READ_ACK         = 7;
     localparam STOP             = 8;
     
     
     // Registros internos
     reg [3:0] state = READY;        // Estado actual
     reg [7:0] counter = 0;          // Contador local. Cuenta hasta 8 bits de un envío
                                     // No tiene en cuenta el mensaje completo
     reg [7:0] bit_ptr = 0;          // Contador global. Cuenta hasta el tamaño del mensaje
                                     // Tiene en cuenta el mensaje completo
     reg [6:0] slave_addr = 0;       // Dirección del esclavo
     reg read_write = 0;                     // Lectura o escritura
     reg [15:0] wt_buffer = 0;       // Buffer de escritura. Mensaje a enviar
     reg [7:0] rd_buffer = 0;        // Buffer de lectura. Mensaje recibido
     reg new_data_read = 0;          // Flag de nuevo dato leído
     reg sda_out = 1;                // Salida de SDA
     reg write_enable = 0;           // Habilitación de SDA
     reg i2c_scl_enable = 0;         // Habilitación de SCL
     reg busy = 0;               // Flag de bus ocupado
     
     assign I2C_SCL  = (i2c_scl_enable == 0) ? 1 : clk;       // Pin de SCL
     assign I2C_SDA  = (write_enable == 1) ? sda_out : 1'bz;  // Pin de SDA
     assign I2C_BUSY = busy;   // Salida de ocupado
     
     assign data_ready = new_data_read;   // Señal de listo
     assign data_out = rd_buffer;    // Salida de datos
     
     
     // Control de habilitación de SCL
     always @(negedge clk or posedge rst) begin
         if (rst)
             i2c_scl_enable <= 0;
         else
             i2c_scl_enable <= (state != READY && state != START && state != STOP);
     end
     
     // Máquina de estados I2C
     always @(posedge clk or posedge rst) begin
         if (rst) begin
             state <= READY;
             counter <= 0;
             bit_ptr <= 0;
             slave_addr <= 7'b0000000;
             read_write <= 1'b0;
             wt_buffer <= 8'b00000000;
             rd_buffer <= 8'b00000000;
             new_data_read <= 0;
             sda_out <= 1;
             write_enable <= 0;
             i2c_scl_enable <= 0;        //??? - No estamos seguros de como tratar el SCL
             busy <= 0;
         end else begin
             case (state)
                 READY: begin
                     write_enable <= 0;
                     if (enable) begin
                         busy <= 1;
                         read_write <= rw;
                         slave_addr <= {slv_addr, rw};
                         wt_buffer <= {reg_obj, data_in};
                         bit_ptr <= data_size;  // Ajustamos el tamaño de bits a enviar según data_size
                         state <= START;
                         new_data_read <= 0;
                     end
                 end
                 START: begin
                     write_enable <= 1;
                     sda_out <= 0;
                     state <= COMMAND;
                     counter <= 7;
                 end
                 COMMAND: begin
                     sda_out <= slave_addr[counter];
                     if (counter == 0) begin
                         sda_out <= 1;
                         state <= SLV_OBJ_ACK;
                     end else
                         counter <= counter - 1;
                 end
                 SLV_OBJ_ACK: begin
                     write_enable <= 0;
                     if (I2C_SDA == 0) begin
                         counter <= 7;
                         if (slave_addr[0] == 0) begin  // Write
                             write_enable <= 1;
                             state <= WRITE_DATA;
                         end else begin               // Read
                             write_enable <= 0;
                             state <= READ_DATA;
                         end
                     end else
                         state <= STOP;
                 end
                 WRITE_DATA: begin
                     sda_out <= wt_buffer[bit_ptr];
                     bit_ptr <= bit_ptr - 1;             //Cuidado con bit_ptr. Debe restar 8 bits al enviar un mensaje
                                                         // 7,6,5 ... 1,0
                     if (counter == 0) begin
                         sda_out <= 1;
                         state <= WRITE_ACK;
                     end else 
                         counter <= counter - 1;       //Está enviando primero el más significativo
                 end
                 WRITE_ACK: begin
                     write_enable <= 0;
                     if (I2C_SDA == 0) begin
                         if (bit_ptr >= 8) begin
                             counter <= 7;
                             write_enable <= 1;
                             //bit_ptr <= bit_ptr - 1;       //Este bit se decrementa en WRITE_DATA
                             //sda_out <= tx_buffer[bit_ptr - 1];
                             state <= WRITE_DATA;
                         end else
                             state <= STOP;
                     end else
                         state <= STOP;
                 end
                 READ_DATA: begin
                     rd_buffer[counter] <= I2C_SDA;
                     if (counter == 0)
                         state <= READ_ACK;
                     else
                         counter <= counter - 1;
                 end
                 READ_ACK: begin
                     write_enable <= 1;
                     sda_out <= 0;
                     state <= STOP;
                     new_data_read <= 1;
     
                 end
                 STOP: begin
                     write_enable <= 1;
                     sda_out <= 1;
                     busy <= 0;
                     state <= READY;
                 end
             endcase
         end
     end
endmodule

module main_vecfcb9 (
 input clk,
 input [31:0] Bus_addr,
 input [31:0] Bus_data,
 input serdat_cs,
 input rst,
 input I2C_Busy,
 input new_data_ready,
 input [7:0] data_out,
 output enable_start,
 output rw,
 output [6:0] slv_addr,
 output [7:0] reg_obj,
 output [7:0] data_write,
 output [3:0] data_size,
 output bus_data_enable,
 output [31:0] bus_data_out
);
 //Entrada desde bus de datos
 reg [7:0] dataArray [0:7];           
 reg reg_enable_start = 0;
 reg [31:0] buffer_data_out;
 reg [31:0] zero = 32'b0;
 
 assign slv_addr[6:0] = dataArray[0][6:0];       //7 bits
 assign reg_obj[7:0] = dataArray[1];
 assign data_write[7:0] = dataArray[2];
 assign rw = dataArray[3][0];                    //1 bit
 assign data_size[3:0] = dataArray[4][3:0];      //4 bits
 assign bus_data_out = buffer_data_out;
 
 //assign dataArray[5] = new_data_ready;
 //assign dataArray[6] = data_out;
 
 assign enable_start = reg_enable_start;
 
 integer i;
 
 
 always @(posedge serdat_cs or posedge rst) begin
     
     if (rst) begin
         // No existen los for exactamente
         // Esto creará estructuras de reinicio tantas veces como se diga
         // No va a iterar x veces
         for (i = 0; i < 8; i = i + 1) begin
             dataArray[i] <= 8'b0;  
         end
         
         reg_enable_start <= 1'b0;
         
     end else if (serdat_cs) begin
         // Caso en el que se introduce información
         if(!(Bus_data[2] && (Bus_data[0] || Bus_data[1])))begin
             dataArray[Bus_addr[2:0]] <= Bus_data[7:0];
 
             if(Bus_addr[7:0] == 8'b0) begin
                 reg_enable_start <= 1'b1;
             end
         // Caso en el que se lee información
         end else begin
             // Caso en el que se pide el busy
             if(Bus_data[2:0] == 3'b111)begin
                 buffer_data_out[31:8] = {zero[31:8],dataArray[7]};
             // Caso en el que se pide el new data o su flag
             end else if(dataArray[5][0]) begin
                 buffer_data_out <= {zero[31:8], dataArray[Bus_addr[2:0]]};
                 if(Bus_addr[2:0] == 3'b110) begin
                     dataArray[5] <= 8'b0;
                     dataArray[6] <= 8'b0;
                 end
             // Caso en el que aún no haya información nueva
             end else begin
                 buffer_data_out <= 32'b11111111111111111111111111111111;
             end
         end
     end
 end
 
 always @(posedge clk) begin
     if (new_data_ready) begin
         reg_enable_start <= 1'b0;
     end
     if (I2C_Busy) begin
         dataArray[7] <= {7'b0, I2C_Busy};
     end
 
 end
 
endmodule
