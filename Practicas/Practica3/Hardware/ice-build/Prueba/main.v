// Code generated by Icestudio 0.12

`default_nettype none

//---- Top entity
module main #(
 parameter v269dbc = 'h0400_0000,
 parameter v9c4340 = 100000
) (
 input v87186f,
 input v4dc0ee,
 input [31:0] v867561,
 input v8859f4,
 input [31:0] v23504b,
 output v9127c2,
 output vfe2384,
 output [31:0] v504d16,
 output [0:7] vinit,
 inout v80923c
);
 localparam p0 = v269dbc;
 localparam p3 = v9c4340;
 wire w1;
 wire w2;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:31] w10;
 wire [0:31] w11;
 wire w12;
 wire w13;
 wire [0:31] w14;
 wire w15;
 wire [0:31] w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire [0:6] w21;
 wire [0:7] w22;
 wire [0:7] w23;
 wire [0:7] w24;
 wire [0:3] w25;
 assign w4 = v87186f;
 assign w5 = v87186f;
 assign v9127c2 = w6;
 assign w7 = v4dc0ee;
 assign w8 = v4dc0ee;
 assign vfe2384 = w9;
 assign w10 = v867561;
 assign w11 = v867561;
 assign w13 = v80923c;
 assign v504d16 = w14;
 assign w15 = v8859f4;
 assign w16 = v23504b;
 assign w5 = w4;
 assign w8 = w7;
 assign w11 = w10;
 vf9bdaf #(
  .v6b316b(p0)
 ) v72f060 (
  .v18e78c(w1),
  .ve1f562(w10)
 );
 vb2090f vef47e6 (
  .v0e28cb(w1),
  .vcbab45(w12),
  .v3ca442(w15)
 );
 v0e64bc #(
  .v207e0d(p3)
 ) v9f9653 (
  .v8337bc(w2),
  .v531e20(w4)
 );
 main_v571ff6 v571ff6 (
  .clk(w2),
  .I2C_SCL(w6),
  .rst(w7),
  .I2C_SDA(w13),
  .data_ready(w17),
  .enable(w18),
  .I2C_BUSY(w19),
  .rw(w20),
  .slv_addr(w21),
  .reg_obj(w22),
  .data_out(w23),
  .data_in(w24),
  .data_size(w25)
 );
 main_vecfcb9 vecfcb9 (
  .clk(w5),
  .rst(w8),
  .bus_data_enable(w9),
  .Bus_addr(w11),
  .serdat_cs(w12),
  .bus_data_out(w14),
  .Bus_data(w16),
  .new_data_ready(w17),
  .enable_start(w18),
  .I2C_Busy(w19),
  .rw(w20),
  .slv_addr(w21),
  .reg_obj(w22),
  .data_out(w23),
  .data_write(w24),
  .data_size(w25)
 );
 assign vinit = 8'b00000000;
endmodule

//---------------------------------------------------
//-- I2C
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Periférico encargado de la comunicación a través del bus I2C.
//---------------------------------------------------
//---- Top entity
module vf9bdaf #(
 parameter v6b316b = 0
) (
 input [31:0] ve1f562,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = ve1f562;
 vf9bdaf_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 32 bits. Se compara si el operando es igual al parámetro
//---------------------------------------------------

module vf9bdaf_vd75681 #(
 parameter K = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a[31:8] == K[31:8]);
endmodule
//---- Top entity
module vb2090f (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vb2090f_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND
//---------------------------------------------------

module vb2090f_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta AND
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a & b;
 
 //-- endmodule
endmodule
//---- Top entity
module v0e64bc #(
 parameter v207e0d = 1
) (
 input v531e20,
 output v8337bc
);
 localparam p2 = v207e0d;
 wire w0;
 wire w1;
 assign v8337bc = w0;
 assign w1 = v531e20;
 v0e64bc_v94c6d7 #(
  .HZ(p2)
 ) v94c6d7 (
  .clk_o(w0),
  .clk(w1)
 );
endmodule

//---------------------------------------------------
//-- Corazon_Hz
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Corazon genérico para bombear bits a la frecuencia fijada en Hz (por defecto 1Hz)
//---------------------------------------------------

module v0e64bc_v94c6d7 #(
 parameter HZ = 0
) (
 input clk,
 output clk_o
);
 
 //parameter HZ=1;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000/HZ;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- REgistro con el valor del reloj
 reg clk_out = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_out <= ~clk_out;
 
 
 assign clk_o = clk_out;  
 
endmodule

module main_v571ff6 (
 input clk,
 input rst,
 input enable,
 input rw,
 input [6:0] slv_addr,
 input [7:0] reg_obj,
 input [7:0] data_in,
 input [3:0] data_size,
 output data_ready,
 output I2C_BUSY,
 output [7:0] data_out,
 output I2C_SCL,
 inout I2C_SDA
);
 // Definir los estados de la máquina de estados
 localparam READY            = 0;
 localparam START            = 1;
 localparam COMMAND          = 2;
 localparam SLV_OBJ_ACK      = 3;
 localparam WRITE_DATA       = 4;
 localparam WRITE_ACK        = 5;
 localparam READ_DATA        = 6;
 localparam READ_ACK         = 7;
 localparam STOP             = 8;
     
     
 // Registros internos
 reg [3:0] state = READY;        // Estado actual
 reg [7:0] counter = 0;          // Contador local. Cuenta hasta 8 bits de un envío
                                     // No tiene en cuenta el mensaje completo
 reg [7:0] bit_ptr = 0;          // Contador global. Cuenta hasta el tamaño del mensaje
                                     // Tiene en cuenta el mensaje completo
 reg [6:0] slave_addr = 0;       // Dirección del esclavo
 reg read_write = 0;                     // Lectura o escritura
 reg [15:0] wt_buffer = 0;       // Buffer de escritura. Mensaje a enviar
 reg [7:0] rd_buffer = 0;        // Buffer de lectura. Mensaje recibido
 reg new_data_read = 0;          // Flag de nuevo dato leído
 reg sda_out = 1;                // Salida de SDA
 reg write_enable = 0;           // Habilitación de SDA
 reg i2c_scl_enable = 0;         // Habilitación de SCL
 reg busy = 0;               // Flag de bus ocupado
     
 assign I2C_SCL  = (i2c_scl_enable == 0) ? 1 : clk;       // Pin de SCL
 assign I2C_BUSY = busy;   // Salida de ocupado
     
 assign data_ready = new_data_read;   // Señal de listo
 assign data_out = rd_buffer;    // Salida de datos
 
   // --------------------------------------------------
   // Open‑drain SDA usando SB_IO (pull‑up interno)
   // --------------------------------------------------
   wire sda_pad_i;    // lectura de la línea SDA
   reg  sda_oe;       // 1=conduce sda_out, 0=hi‑Z+pull‑up
 
   // Instanciación de la salida SDA hardware‑aware
   SB_IO #(
     .PIN_TYPE(6'b1010_01), // [oe=1,D0], D_IN, OE, PULLUP=1
     .PULLUP(1'b1)
   ) i2c_sda_buf (
     .PACKAGE_PIN   (I2C_SDA),
     .D_IN_0        (sda_pad_i),    // para leer ACK/bits
     .D_OUT_0       (sda_out),      // tu dato: 0 o 1
     .OUTPUT_ENABLE (sda_oe)        // 1=drive, 0=release (hi‑Z+pull‑up)
   );
 
   // Y en tu FSM reemplaza todas las lecturas de I2C_SDA por sda_pad_i:
   //   if (sda_pad_i == 0) …     // ACK
   //   rd_buffer[counter] <= sda_pad_i;
 
 // Máquina de estados I2C
 always @(posedge clk or posedge rst) begin
     if (rst) begin
         state <= READY;
         counter <= 0;
         bit_ptr <= 0;
         slave_addr <= 7'b0000000;
         read_write <= 1'b0;
         wt_buffer <= 8'b00000000;
         rd_buffer <= 8'b00000000;
         new_data_read <= 0;
         sda_out <= 1;
         i2c_scl_enable <= 0;
         write_enable <= 0;
         i2c_scl_enable <= 0;        //??? - No estamos seguros de como tratar el SCL
         busy <= 0;
     end else begin
         sda_oe      <= write_enable;
         busy        <= (state != READY && state != START && state != STOP);
         case (state)
             READY: begin
                 write_enable <= 0;
                 if (enable) begin
                     busy <= 1;
                     read_write <= rw;
                     slave_addr <= {slv_addr, rw};
                     wt_buffer <= {reg_obj, data_in};
                     bit_ptr <= data_size;  // Ajustamos el tamaño de bits a enviar según data_size
                     state <= START;
                     new_data_read <= 0;
                 end
             end
             START: begin
                 write_enable <= 1;
                 sda_out <= 0;
                 state <= COMMAND;
                 counter <= 7;
             end
             COMMAND: begin
                 sda_out <= slave_addr[counter];
                 if (counter == 0) begin
                     sda_out <= 1;
                     state <= SLV_OBJ_ACK;
                 end else
                     counter <= counter - 1;
             end
             SLV_OBJ_ACK: begin
                 write_enable <= 0;
                 if (I2C_SDA == 0) begin
                     counter <= 7;
                     if (slave_addr[0] == 0) begin  // Write
                         write_enable <= 1;
                         state <= WRITE_DATA;
                     end else begin               // Read
                         write_enable <= 0;
                         state <= READ_DATA;
                     end
                 end else
                     state <= STOP;
             end
             WRITE_DATA: begin
                 sda_out <= wt_buffer[bit_ptr];
                 bit_ptr <= bit_ptr - 1;             //Cuidado con bit_ptr. Debe restar 8 bits al enviar un mensaje
                                                     // 7,6,5 ... 1,0
                 if (counter == 0) begin
                     sda_out <= 1;
                     state <= WRITE_ACK;
                 end else 
                     counter <= counter - 1;       //Está enviando primero el más significativo
             end
             WRITE_ACK: begin
                 write_enable <= 0;
                 if (I2C_SDA == 0) begin
                     if (bit_ptr >= 8) begin
                         counter <= 7;
                         write_enable <= 1;
                         //bit_ptr <= bit_ptr - 1;       //Este bit se decrementa en WRITE_DATA
                         //sda_out <= tx_buffer[bit_ptr - 1];
                         state <= WRITE_DATA;
                     end else
                         state <= STOP;
                 end else
                     state <= STOP;
             end
             READ_DATA: begin
                 rd_buffer[counter] <= I2C_SDA;
                 if (counter == 0)
                     state <= READ_ACK;
                 else
                     counter <= counter - 1;
             end
             READ_ACK: begin
                 write_enable <= 1;
                 sda_out <= 0;
                 state <= STOP;
                 new_data_read <= 1;
 
             end
             STOP: begin
                 write_enable <= 1;
                 sda_out <= 1;
                 busy <= 0;
                 state <= READY;
             end
         endcase
     end
 end
endmodule

module main_vecfcb9 (
 input clk,
 input rst,
 input [31:0] Bus_addr,
 input [31:0] Bus_data,
 input serdat_cs,
 input I2C_Busy,
 input new_data_ready,
 input [7:0] data_out,
 output enable_start,
 output rw,
 output [6:0] slv_addr,
 output [7:0] reg_obj,
 output [7:0] data_write,
 output [3:0] data_size,
 output bus_data_enable,
 output [31:0] bus_data_out
);
 // ---------------------------------------------
 // Interfaz de bus con registros individuales
 // ---------------------------------------------
 
 // inside your module, up in the declarations:
 reg  [7:0] sel_byte;
 
 // Declaración de registros (en lugar de array)
 reg [7:0] data0;
 reg [7:0] data1;
 reg [7:0] data2;
 reg [7:0] data3;
 reg [7:0] data4;
 reg [7:0] data5;
 reg [7:0] data6;
 reg [7:0] data7;
 
 reg reg_enable_start = 1'b0;
 reg [31:0] buffer_data_out;
 reg [31:0] zero = 32'b0;
 
 // Señales de salida hijas
 assign slv_addr[6:0]   = data0[6:0];      // dirección del esclavo
 assign reg_obj[7:0]    = data1;           // registro objetivo
 assign data_write[7:0] = data2;           // dato a escribir
 assign rw               = data3[0];       // lectura/escritura
 assign data_size[3:0]  = data4[3:0];      // tamaño en bits
 assign bus_data_out     = buffer_data_out;
 assign enable_start     = reg_enable_start;
 
 // Reset y escritura: muestreo en flanco de serdat_cs
 always @(posedge serdat_cs or posedge rst) begin
      begin
         // Si es escritura en bus (byte válido)
         if (!(Bus_data[2] && (Bus_data[0] || Bus_data[1]))) begin
             case (Bus_addr[2:0])
                 3'd0: data0 <= Bus_data[7:0];
                 3'd1: data1 <= Bus_data[7:0];
                 3'd2: data2 <= Bus_data[7:0];
                 3'd3: data3 <= Bus_data[7:0];
                 3'd4: data4 <= Bus_data[7:0];
                 3'd5: data5 <= Bus_data[7:0];
                 3'd6: data6 <= Bus_data[7:0];
                 3'd7: data7 <= Bus_data[7:0];
             endcase
 
             // Arrancar transacción si se escribe en dirección 0
             if (Bus_addr[7:0] == 8'b0)
                 reg_enable_start <= 1'b1;
         end else begin
             // Lectura de estado o datos
             case (Bus_addr[2:0])
                     3'd0: sel_byte = data0;
                 3'd1: sel_byte = data1;
                 3'd2: sel_byte = data2;
                 3'd3: sel_byte = data3;
                 3'd4: sel_byte = data4;
                 3'd5: sel_byte = data5;
                 3'd6: sel_byte = data6;
                 3'd7: sel_byte = data7;
             endcase
 
             // Petición de BUSY (dirección 7)
             if (Bus_data[2:0] == 3'b111) begin
                 buffer_data_out <= {zero[31:8], data7};
             end
             // Nuevo dato disponible
             else if (data5[0]) begin
                 buffer_data_out <= {zero[31:8], sel_byte};
                 if (Bus_addr[2:0] == 3'b110) begin
                     data5 <= 8'b0;
                     data6 <= 8'b0;
                 end
             end else begin
                 buffer_data_out <= 32'hFFFFFFFF;
             end
         end
         end
 end
 
 // Limpieza de "enable_start" y actualización de flag de recibido
 always @(posedge clk) begin
   if (!rst) begin
     // --- asynchronous reset of all registers ---
     reg_enable_start <= 1'b0;
     data0            <= 8'b0;
     data1            <= 8'b0;
     data2            <= 8'b0;
     data3            <= 8'b0;
     data4            <= 8'b0;
     data5            <= 8'b0;
     data6            <= 8'b0;
     data7            <= 8'b0;
   end else begin
     // --- normal operation ---
     if (new_data_ready)
       reg_enable_start <= 1'b0;
 
     if (I2C_Busy)
       data7 <= {7'b0, I2C_Busy};
   end
 end
 
endmodule
