// Code generated by Icestudio 0.12

`default_nettype none

//---- Top entity
module main #(
 parameter v31c48c = 'h0210_0000
) (
 input v537510,
 input v6f1ced,
 input [31:0] v775e34,
 input v87d16b,
 input [31:0] v976ab6,
 output vc51198,
 output vc84d54,
 output [31:0] v235119,
 output [0:7] vinit,
 inout va7280c,
 inout vd14cf6
);
 localparam p1 = v31c48c;
 wire w0;
 wire w2;
 wire [0:7] w3;
 wire w4;
 wire [0:6] w5;
 wire [0:7] w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire [0:31] w11;
 wire w12;
 wire [0:31] w13;
 wire [0:31] w14;
 wire w15;
 assign w7 = v537510;
 assign w8 = v6f1ced;
 assign vc84d54 = w9;
 assign v235119 = w11;
 assign w12 = vd14cf6;
 assign w13 = v976ab6;
 assign w14 = v775e34;
 assign w15 = v87d16b;
 vf9bdaf #(
  .v6b316b(p1)
 ) v9b369f (
  .v18e78c(w2),
  .ve1f562(w14)
 );
 vb2090f v2b8390 (
  .v0e28cb(w2),
  .vcbab45(w10),
  .v3ca442(w15)
 );
 main_v020df3 v020df3 (
  .adc_data_write(w3),
  .adc_rw(w4),
  .adc_addr(w5),
  .Bus_data(w13)
 );
 main_vffb17e vffb17e (
  .data_rd(w6),
  .adcReady(w9),
  .adcData(w11)
 );
 main_v7f5352 v7f5352 (
  .ADC_SCL(w0),
  .clk(w0),
  .data_rw(w3),
  .rw(w4),
  .addr(w5),
  .data_rd(w6),
  .resetn(w8),
  .ena(w10),
  .ADC_SDA(w12)
 );
 assign vinit = 8'b00000000;
endmodule

//---------------------------------------------------
//-- ADC_I2C
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Módulo de comuniación con el adc de Alhambra II usando I2C
//---------------------------------------------------
//---- Top entity
module vf9bdaf #(
 parameter v6b316b = 0
) (
 input [31:0] ve1f562,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = ve1f562;
 vf9bdaf_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 32 bits. Se compara si el operando es igual al parámetro
//---------------------------------------------------

module vf9bdaf_vd75681 #(
 parameter K = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a == K);
endmodule
//---- Top entity
module vb2090f (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vb2090f_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND
//---------------------------------------------------

module vb2090f_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta AND
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a & b;
 
 //-- endmodule
endmodule

module main_v020df3 (
 input [31:0] Bus_data,
 output [6:0] adc_addr,
 output adc_rw,
 output [15:8] adc_reg,
 output [23:16] adc_data_write
);
 // Asignación
 assign adc_addr = Bus_data[6:0];
 assign adc_rw   = Bus_data[7];
 assign adc_reg  = Bus_data[15:8];
 assign adc_data_write = Bus_data[23:16];
 
endmodule

module main_vffb17e (
 input [7:0] data_tx,
 output [31:0] adcData,
 output adcReady
);

endmodule

module main_v7f5352 (
 input clk,
 input resetn,
 input ena,
 input [6:0] addr,
 input rw,
 input [7:0] reg_obj,
 input [7:0] data_wr,
 output busy,
 output ack_error,
 output [7:0] data_rd,
 output ADC_SCL,
 inout ADC_SDA
);
 // ADC I2C Master para Alhambra II compatible con IceStudio
 
 
 // Parámetros
 parameter INPUT_CLK = 12_000_000;
 parameter BUS_CLK   = 100_000;
 
 // Clock divider
 localparam DIVIDER = (INPUT_CLK / BUS_CLK) / 4;
 localparam NDIV = 8; // log2(375) ~= 8.5, usar 8 por seguridad
 
 //Flanco de bajada.
 reg clk_bit_prev;
 
 always @(posedge clk) begin
     clk_bit_prev <= clk_bit;
 end
 
 wire falling_edge_clk_bit = (clk_bit_prev == 1 && clk_bit == 0);
 
 // Señales internas
 reg [NDIV-1:0] clk_div = 0;
 reg clk_bit = 0;
 always @(posedge clk) begin
     clk_div <= (clk_div == DIVIDER - 1) ? 0 : clk_div + 1;
     if (clk_div == 0) clk_bit <= ~clk_bit;
 end
 
 // Estados
 localparam READY    = 4'd0;
 localparam START    = 4'd1;
 localparam COMMAND  = 4'd2;
 localparam SLV_ACK1 = 4'd3;
 localparam WR       = 4'd4;
 localparam RD       = 4'd5;
 localparam SLV_ACK2 = 4'd6;
 localparam MSTR_ACK = 4'd7;
 localparam STOP     = 4'd8;
 
 reg [3:0] state = READY;
 reg scl_en = 0;
 reg sda_int = 1;
 reg [7:0] addr_rw, data_tx, data_rx;
 reg [2:0] bit_cnt = 3'd7;
 reg [6:0] prev_addr = 7'b0;  // Addr previo
 
 assign data_rd = data_rx;
 assign busy = (state != READY);
 
 // SDA como salida Open Drain
 assign ADC_SDA = (sda_int == 0) ? 1'b0 : 1'bz;
 assign ADC_SCL = (scl_en == 1) ? clk_bit : 1'bz;
 
 always @(posedge clk_bit or negedge resetn) begin
     if (!resetn) begin
         state <= READY;
         sda_int <= 1;
         scl_en <= 0;
         bit_cnt <= 7;
     end else begin
         case (state)
             READY: begin
                 if (ena) begin
                     addr_rw <= {addr, rw};
                     data_tx <= data_rw;
                     scl_en <= 1;
                     sda_int <= 0;
                     state <= START;
                 end
             end
             START: begin
                 sda_int <= addr_rw[bit_cnt];
                 state <= COMMAND;
             end
             COMMAND: begin
                 if (bit_cnt == 0) begin
                     sda_int <= 1;
                     bit_cnt <= 7;
                     state <= SLV_ACK1;
                 end else begin
                     bit_cnt <= bit_cnt - 1;
                     sda_int <= addr_rw[bit_cnt - 1];
                 end
             end
             SLV_ACK1: begin
                 if (rw == 0) begin
                     sda_int <= data_tx[bit_cnt];
                     state <= WR;
                 end else begin
                     sda_int <= 1;
                     state <= RD;
                 end
             end
             WR: begin
                 if (bit_cnt == 0) begin
                     sda_int <= 1;
                     bit_cnt <= 7;
                     state <= SLV_ACK2;
                 end else begin
                     bit_cnt <= bit_cnt - 1;
                     sda_int <= data_tx[bit_cnt - 1];
                 end
             end
             RD: begin
                 if (bit_cnt == 0) begin
                     bit_cnt <= 7;
                     sda_int <= 1;
                     state <= MSTR_ACK;
                 end else begin
                     bit_cnt <= bit_cnt - 1;
                     data_rx[bit_cnt] <= ADC_SDA;
                 end
             end
             SLV_ACK2: begin
             
                 if (ena) begin
                     addr_rw <= {addr, rw};
                     data_tx <= data_rw;
                     if (rw == 0 && addr == prev_addr) begin
                         bit_cnt <= 7;
                         sda_int <= data_rw[7];
                         state <= WR;
                     end else begin // rw == 1 || addr != prev_addr
                         sda_int <= 0;
                         state <= START;
                     end 
                     prev_addr <= addr;
                 end else begin
                     scl_en <= 0;
                     sda_int <= 1;
                     state <= STOP;
                 end
             end
             MSTR_ACK: begin
                 if (ena) begin
                     addr_rw <= {addr, rw};
                     data_tx <= data_rw;
                     if (rw == 1 && addr == prev_addr) begin
                         bit_cnt <= 7;
                         sda_int <= 1;
                         state <= RD;
                     end else begin // rw == 0 || addr != prev_addr
                         sda_int <= 0;
                         state <= START;
                     end
                     prev_addr <= addr;
                 end else begin
                     scl_en <= 0;
                     sda_int <= 1;
                     state <= STOP;
                 end
             end
             STOP: begin
                 sda_int <= 1;
                 state <= READY;
             end
             default: state <= READY;
         endcase
     end
 end
 
 // Gestión del ack_error al estilo del ejemplo VHDL
 always @(posedge clk or negedge resetn) begin
     if (!resetn) begin
         ack_error <= 0;
     end else if (falling_edge_clk_bit) begin
         case (state)
             START: begin
                 ack_error <= 0;
             end
             SLV_ACK1: begin
                 ack_error <= ADC_SDA | ack_error;
             end
             SLV_ACK2: begin
                 ack_error <= ADC_SDA | ack_error;
             end
             default: begin
                 ack_error <= ack_error;
             end
         endcase
     end
 end
endmodule
