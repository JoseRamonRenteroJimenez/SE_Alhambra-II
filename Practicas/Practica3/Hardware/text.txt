Skip to content
Chat history
You said:
Estos son algunos componenetes de mi proyecto de sistemas empotrados. Podr√°s ver el procesador que estoy usando, la l√≥gica de acceso a este y una uart. Estos componentes funcionan bien y hace lo que se espera. Expl√≠came como actual l√≥gica de acceso y como devuelve el control al procesador despu√©s de d√°rselo a la uart despu√©s de activarla con su se√±al de chip select


Estos son algunos de los componentes de mi proyecto de sistemas empotrados. Expl√≠came como funciona la l√≥gica de acceso. Como es que despu√©s de dar el control el procesador a la uart por medio de su chip select, vuelve el control al procesador
ChatGPT said:
Resumen r√°pido

Tu procesador y la UART comparten el mismo bus de datos/control.
La ‚Äúl√≥gica de acceso‚Äù (bus arbiter + decodificador de direcci√≥n) es la que:

    Detecta cu√°ndo el procesador est√° intentando acceder a la UART (por la direcci√≥n o la se√±al CS_UART que t√∫ generas).

    Cede temporalmente el control de las l√≠neas de datos, direcci√≥n y se√±ales RD/WR a la UART.

    Espera a que la UART responda con ‚Äúoperaci√≥n terminada‚Äù (ACK, READY, TXEMPTY, etc.).

    Des‚Äêaserta CS_UART, pone la UART en alta impedancia (tri-state) y devuelve el bus al procesador (estado IDLE).

Pasos con algo m√°s de detalle
Fase FSM	Se√±ales clave	Qui√©n conduce el bus	Explicaci√≥n breve
IDLE	CS_UART=0, BUSY=0	Procesador	No hay perif√©rico seleccionado.
DECODE	CPU coloca direcci√≥n; la l√≥gica detecta rango de la UART.	Procesador	Si la direcci√≥n ‚àà rango-UART ‚áí CS_UART ‚Üê 1.
UART_ACCESS	CS_UART=1, BUSY=1	UART	El decodificador desconecta la CPU (tri-state) y la UART usa las l√≠neas.
WAIT/COMPLETE	UART genera ACK/READY=1 cuando ha le√≠do/escrito el dato.	UART/-	Arbiter observa la se√±al, des-aserta BUSY.
RETURN	CS_UART‚Üê0, BUSY‚Üê0	Procesador	La FSM vuelve a IDLE; la CPU re-toma el bus.
¬øQu√© hace cada bloque?
Bloque	Se√±ales que mira	Se√±ales que genera	Comentario
Decodificador de direcci√≥n	ADDR[31:0]	CS_UART, CS_RAM, etc.	Normalmente un comparador (rango) + AND con MREQ o VALID.
Arbiter / Bus‚Äêmux	CS_*, RD/WR, ACK, CLK	BUSY, MUX_SEL	Selecciona qui√©n conduce el bus y cu√°ndo.
UART	CS_UART, RD/WR, DATA, CLK	DATA, ACK/READY, IRQ_TX, etc.	Cuando CS_UART=1 se habilita su l√≥gica interna; cuando CS_UART=0 pone salidas en Z.
Mecanismo de ‚Äúdevolver el control‚Äù

    Transferencia finalizada

        La UART termina su lectura/escritura y levanta ACK (o READY).

        Si usas un bus estilo Wishbone, esto equivale a ACK_O=1; en AXI-Lite ser√≠a *_VALID & *_READY.

    FSM detecta el ACK

        En el siguiente flanco de reloj, el arbiter pone CS_UART‚Üê0 y BUSY‚Üê0.

        El multiplexor de datos y direcci√≥n vuelve a seleccionar al procesador.

    CPU reanuda

        El n√∫cleo ve que el ciclo ya no est√° ‚Äúen espera‚Äù (WAIT=0) y continua con la instrucci√≥n siguiente.

        Cualquier interrupci√≥n de la UART (IRQ_TX/IRQ_RX) puede dispararse ahora si procede.

    üí° Importante: Nunca tienes a la UART ‚Äúgobernando‚Äù indefinidamente. El arbiter s√≥lo le da el bus durante ese ciclo de lectura/escritura. Tras el ACK, el control regresa autom√°ticamente al procesador.

Se√±ales t√≠picas en un solo ciclo de escritura (ejemplo)

CLK   ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ...
ADDR  AAAAA|AAAA|AAAA‚îÜ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ    (CPU coloca direcci√≥n de la UART)
DATA  DDDDD|DDDD|DDDD‚îÜ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ    (CPU coloca dato a transmitir)
RD/W  ----W|----W|----W‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     (Write)
CS_U  _____|=====|_____            (Generado por decodificador)
ACK_U ________|===|______          (UART responde cuando listo)
BUSY  ________|===|______          (Arbiter: bus cedido)

Puntos de comprobaci√≥n / Depuraci√≥n r√°pida

    Latencias

        Si la UART necesita varios ciclos, el arbiter debe mantener BUSY hasta el ACK.

        Inserta contadores o un analizador l√≥gico para ver cu√°ndo llega ACK.

    Tri-state o mux

        Comprueba que, mientras CS_UART=0, las salidas de la UART est√°n en alta Z.

        Si usas un bus puramente multiplexado (sin tri-state), aseg√∫rate de que el mux selecciona ‚Äúcero‚Äù o ‚Äúdummy‚Äù.

    Riesgo de contenci√≥n

        Dos perif√©ricos nunca deben conducir las mismas l√≠neas simult√°neamente.

        Vigila en simulaci√≥n que CS exclusivos y multiplexores est√©n bien sincronizados.

    Signal naming

        Usa un prefijo claro ACK_, CS_, BUSY_, REQ_ para cada perif√©rico. Evita nombres ambiguos que te lleven a puentear se√±ales por error.

Conclusi√≥n

    La l√≥gica de acceso es b√°sicamente un peque√±o FSM + decodificador de direcciones que arbitra el bus.

    El procesador pierde el control s√≥lo durante el lapso en que la UART tiene CS activo y hasta que responde con ACK/READY.

    El retorno se produce en el mismo flanco de reloj en que se detecta el ACK‚Äîsimplemente se des-aserta CS, se pone el perif√©rico en Z y el arbiter vuelve a seleccionar al procesador.

Con esto, tu CPU y la UART trabajan sin pisarse, y cada transferencia queda perfectamente acotada en el tiempo.
You said:
Estoy tratando de dise√±ar un perif√©rico nuevo que lleve la comunicaci√≥n del bus de i2c


// Code generated by Icestudio 0.12
// Fri, 18 Jul 2025 01:57:50 GMT

default_nettype none

//---- Top entity
module main #(
 parameter vec4673 = 'h0400_0000,
 parameter v8eaf13 = 'h0400_0001,
 parameter v9c4340 = 100000
) (
 input v87186f,
 input v4dc0ee,
 input [31:0] v867561,
 input v8859f4,
 input [31:0] v23504b,
 output v9127c2,
 output vfe2384,
 output [31:0] v504d16,
 output vf73703,
 output va77527,
 output v34d6ed,
 output v5a58e0,
 output [2:0] v056d28,
 output [7:0] vaac567,
 output v147f2d,
 output [6:0] vc02bbb,
 output [0:7] vinit,
 inout v80923c
);
 localparam p0 = v9c4340;
 localparam p1 = v8eaf13;
 localparam p7 = vec4673;
 wire w2;
 wire [0:6] w3;
 wire w4;
 wire [0:2] w5;
 wire [0:7] w6;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire [0:31] w13;
 wire [0:31] w14;
 wire [0:31] w15;
 wire [0:31] w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 wire [0:31] w29;
 wire [0:31] w30;
 wire [0:3] w31;
 wire w32;
 wire w33;
 wire w34;
 wire [0:6] w35;
 wire [0:6] w36;
 wire [0:31] w37;
 wire [0:7] w38;
 wire [0:2] w39;
 assign vc02bbb = w3;
 assign v056d28 = w5;
 assign vaac567 = w6;
 assign v147f2d = w8;
 assign v9127c2 = w9;
 assign vfe2384 = w12;
 assign w13 = v867561;
 assign w14 = v867561;
 assign w15 = v867561;
 assign v504d16 = w16;
 assign w17 = v87186f;
 assign w18 = v87186f;
 assign w19 = v87186f;
 assign vf73703 = w20;
 assign w21 = v8859f4;
 assign w22 = v4dc0ee;
 assign w23 = v4dc0ee;
 assign w24 = v4dc0ee;
 assign va77527 = w25;
 assign w26 = v80923c;
 assign v5a58e0 = w26;
 assign w27 = v80923c;
 assign v34d6ed = w28;
 assign w29 = v23504b;
 assign w30 = v23504b;
 assign w11 = w10;
 assign w14 = w13;
 assign w15 = w13;
 assign w15 = w14;
 assign w18 = w17;
 assign w19 = w17;
 assign w19 = w18;
 assign w23 = w22;
 assign w24 = w22;
 assign w24 = w23;
 assign w27 = w26;
 assign w30 = w29;
 assign w36 = w35;
 assign w39 = w5;
 v0e64bc #(
  .v207e0d(p0)
 ) v9f9653 (
  .v8337bc(w4),
  .v531e20(w17)
 );
 vf9bdaf #(
  .v6b316b(p1)
 ) v3156fe (
  .v18e78c(w2),
  .ve1f562(w15)
 );
 main_vb9f55b vb9f55b (
  .b(w2),
  .slave__out(w3),
  .a(w11),
  .clk(w19),
  .x(w20),
  .rst_n(w24),
  .y(w25),
  .z(w28),
  .c(w30),
  .slave_out(w36)
 );
 main_v626e75 v626e75 (
  .clk(w4),
  .I2C_SCL(w9),
  .rstn(w22),
  .I2C_SDA(w27),
  .state_out(w31),
  .enable(w32),
  .rw(w33),
  .busy_out(w34),
  .slv_addr(w35),
  .data_in(w37),
  .data_out(w38),
  .n_paquetes(w39)
 );
 main_vadbda8 #(
  .Addr(p7)
 ) vadbda8 (
  .i2c_cs(w10),
  .addr_in(w13),
  .bit_valid(w21)
 );
 main_vecfcb9 vecfcb9 (
  .n_paquetes(w5),
  .check(w6),
  .data_ready(w8),
  .serdat_cs(w10),
  .bus_data_enable(w12),
  .Bus_addr(w14),
  .bus_data_out(w16),
  .clk(w18),
  .rstn(w23),
  .Bus_data(w29),
  .I2C_State(w31),
  .enable_start(w32),
  .rw(w33),
  .I2C_Busy(w34),
  .slv_addr(w35),
  .data_write(w37),
  .data_out(w38)
 );
 assign vinit = 8'b00000000;
endmodule

//---------------------------------------------------
//-- I2C_soc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Perif√©rico encargado de la comunicaci√≥n a trav√©s del bus I2C.
//---------------------------------------------------
//---- Top entity
module v0e64bc #(
 parameter v207e0d = 1
) (
 input v531e20,
 output v8337bc
);
 localparam p2 = v207e0d;
 wire w0;
 wire w1;
 assign v8337bc = w0;
 assign w1 = v531e20;
 v0e64bc_v94c6d7 #(
  .HZ(p2)
 ) v94c6d7 (
  .clk_o(w0),
  .clk(w1)
 );
endmodule

//---------------------------------------------------
//-- Corazon_Hz
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Corazon gen√©rico para bombear bits a la frecuencia fijada en Hz (por defecto 1Hz)
//---------------------------------------------------

module v0e64bc_v94c6d7 #(
 parameter HZ = 0
) (
 input clk,
 output clk_o
);
 
 //parameter HZ=1;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000/HZ;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- REgistro con el valor del reloj
 reg clk_out = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_out <= ~clk_out;
 
 
 assign clk_o = clk_out;  
 
endmodule
//---- Top entity
module vf9bdaf #(
 parameter v6b316b = 0
) (
 input [31:0] ve1f562,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = ve1f562;
 vf9bdaf_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 32 bits. Se compara si el operando es igual al par√°metro
//---------------------------------------------------

module vf9bdaf_vd75681 #(
 parameter K = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a[31:6] == K[31:6]);
endmodule

module main_vb9f55b (
 input clk,
 input rst_n,
 input a,
 input b,
 input [31:0] c,
 input [6:0] slave_out,
 input rw_out,
 output x,
 output y,
 output z,
 output [6:0] slave__out
);
 reg         reg_x = 0;    // ahora es reg
 reg         reg_y = 0;    // ahora es reg
 reg         reg_z = 0;     // ahora es reg
 
 reg [6:0] slave_addr = 7'd0;   
 
 assign x = reg_x;
 assign y = reg_y;
 assign z = reg_z;
 assign slave__out = slave_addr;
 always @(posedge clk or negedge rst_n) begin
 
     
     if (!rst_n) begin
         // Reset: vuelven a 0
         reg_x <= 1'b0;
         reg_y <= 1'b0;
         reg_z <= 1'b0;
         slave_addr <= 8'd0;   
         
     end else begin
         // Al primer 1 en 'a', si a√∫n no lo hab√≠amos detectado
         if (a && !reg_x)
             reg_x <= 1'b1;
 
         // Al primer 1 en 'b'
         if (b && !reg_y)
             reg_y <= 1'b1;
 
         // Al primer 1 en cualquier bit de 'c' (reducci√≥n OR)
         if (c && !reg_z)
             reg_z <= 1'b1;
         
         if(slave_out && !slave_addr)
             slave_addr <= slave_out;
     end
 end
 
endmodule

module main_v626e75 (
 input clk,
 input rstn,
 input enable,
 input rw,
 input [6:0] slv_addr,
 input [31:0] data_in,
 input [2:0] n_paquetes,
 input I2C_SDA,
 output [3:0] state_out,
 output busy_out,
 output [7:0] data_out,
 output I2C_SCL
);
 // Definir los estados de la m√°quina de estados
 localparam READY       = 4'd0;
 localparam START       = 4'd1;
 localparam COMMAND     = 4'd2;
 localparam SLV_OBJ_ACK = 4'd3;
 localparam WRITE_DATA  = 4'd4;
 localparam WRITE_ACK   = 4'd5;
 localparam READ_DATA   = 4'd6;
 localparam READ_ACK    = 4'd7;
 localparam STOP        = 4'd8;
 
 // Bit m√°s significativos
 localparam max_slv_Addr = 7;
 localparam max_data_wr = 31;
 
 // Registros internos
 reg [3:0] state = READY;            // Estado actual
 reg [2:0] counter = 3'd0;           // Contador local. Cuenta hasta 8 bits de un env√≠o
 reg [2:0] num_paquetes = 3'd0;      // Contador de paquetes a enviar.
 reg [7:0] slave_addr = 8'd0;        // Direcci√≥n del esclavo
 reg read_write = 1'd0;              // Lectura o escritura
 reg [31:0] wt_buffer = 32'b0;       // Buffer de escritura. Mensaje a enviar
 reg [7:0] rd_buffer = 8'd0;         // Buffer de lectura. Mensaje recibido
 reg sda_out = 1'd0;                 // Salida de SDA
 reg write_enable = 1'd0;            // Habilitaci√≥n de SDA
 reg enable_reg = 1'd0;
 reg clk_enable;
 reg busy = 1'd0;                    // Flag de bus ocupado
 reg reg_data_ready = 1'b0;
 
 // Asignaciones
 assign busy_out = busy;
 assign data_out = rd_buffer;
 assign I2C_SCL = clk_enable ? clk : 1'b1;       // Pin de SCL
 assign I2C_SDA = write_enable ? 1'b0 : 1'bz;    // Pin de SDA
 
 //always @(posedge enable) begin
 //    enable_reg <= 1'b1;
 //end
 
 // M√°quina de estados I2C
 always @(posedge clk or negedge rstn) begin
     if (!rstn) begin
         state <= READY;        
         counter <= 3'd0;
         num_paquetes <= 2'd0;  
         sda_out <= 1'b1;
         slave_addr <= 8'd0;       
         read_write <= 1'd0;
         wt_buffer <= 24'b0;       
         rd_buffer <= 8'd0;                
         write_enable <= 1'd0;           
         busy <= 1'd0;
         reg_data_ready <= 1'b0;
         enable_reg <= 1'b0;
     end else begin
         case (state)
             READY: begin
                 reg_data_ready <= 1'b0;
                 write_enable <= 1'b0;
                 busy <= enable;
                 if (enable && !enable_reg) begin
                     enable_reg <= 1'b1;
                 end
                 if (enable_reg) begin
                     num_paquetes <= n_paquetes;
                     read_write <= rw;
                     slave_addr <= {slv_addr, rw};
                     wt_buffer <= data_in;
                     enable_reg <= 1'b0;
                     state <= START;
                 end
             end
             START: begin
                 busy <= 1'b1;
                 write_enable <= 1'b1;
                 counter <= 3'd7;
                 sda_out <= slave_addr[max_slv_Addr];               
                 state <= COMMAND;  
             end
             COMMAND: begin
                 if (counter == 3'd0) begin
                     //write_enable <= 1'b0;
                     sda_out <= 1'b0;  // Finaliza el env√≠o de la direcci√≥n
                     state <= SLV_OBJ_ACK;
                 end else begin
                     counter <= counter - 1;
                     slave_addr <= slave_addr << 1; // Desplaza la direcci√≥n del esclavo
                     sda_out <= slave_addr[max_slv_Addr];
                 end
             end
             SLV_OBJ_ACK: begin
                 // Chequear ACK del esclavo. No est√° en el verilog
                 if (I2C_SDA == 1'b1) begin  // Write
                     counter <= 3'd7;
                     write_enable <= 1'b1;
                     sda_out <= wt_buffer[max_data_wr];
                     state <= WRITE_DATA;
                 end else begin               // Read
                     counter <= 3'd7;
                     write_enable <= 1'b0;
                     state <= READ_DATA;
                 end
             end
             WRITE_DATA: begin
                 busy <= 1'b1;
                 if (counter == 3'd0) begin
                     write_enable <= 1'b0;
                     num_paquetes <= num_paquetes - 1'b1;
                     sda_out <= 1'b0;
                     state <= WRITE_ACK;
                 end else begin
                     counter <= counter - 1;
                     wt_buffer <= wt_buffer << 1;
                     sda_out <= wt_buffer[max_data_wr];
                 end
             end
             READ_DATA: begin
                 rd_buffer[counter] <= I2C_SDA;
                 if (counter == 3'd0) begin
                     state <= READ_ACK;
                 end else begin 
                     counter <= counter - 1;
                 end
             end
             WRITE_ACK: begin
                 if (enable == 1'b1) begin
                     if (num_paquetes > 2'b0) begin
                         counter <= 3'd7;
                         write_enable <= 1'b1;
                         sda_out <= wt_buffer[max_data_wr];
                         state <= WRITE_DATA;
                     end else begin
                         state <= STOP;
                     end
                 end else begin 
                     state <= STOP;
                 end
             end
             READ_ACK: begin
                 busy <= 1'b0;
                 write_enable <= 1'b1;
                 sda_out <= 1'b0;
                 reg_data_ready <= 1'b1;
                 state <= STOP;
             end
             STOP: begin
                 write_enable <= 1'b1;
                 sda_out <= 1'b1;
                 busy <= 1'b0;
                 state <= READY;
             end
         endcase
     end
 end
 
 // Control s√≠ncrono de SCL enable
 always @(posedge clk) begin
     if (!rstn)
         clk_enable <= 1'b0;
     else
         clk_enable <= (state != READY) && (state != START) && (state != STOP);
 end
endmodule

module main_vadbda8 #(
 parameter Addr = 0
) (
 input [31:0] addr_in,
 input bit_valid,
 output i2c_cs
);
 assign i2c_cs = (addr_in[31:6] == Addr[31:6]) & bit_valid;
endmodule

module main_vecfcb9 (
 input clk,
 input rstn,
 input [31:0] Bus_addr,
 input [31:0] Bus_data,
 input serdat_cs,
 input [3:0] I2C_State,
 input I2C_Busy,
 input [7:0] data_out,
 output enable_start,
 output rw,
 output [6:0] slv_addr,
 output [31:0] data_write,
 output [2:0] n_paquetes,
 output bus_data_enable,
 output [31:0] bus_data_out,
 output [7:0] check,
 output data_ready
);
 parameter W_SLV_ADDR        = 3'b000;  // 0x04000000
 parameter W_RW              = 3'b001;  // 0x04000004
 parameter W_N_PQTS          = 3'b010;  // 0x04000008
 parameter R_STATE           = 3'b011;  // 0x0400000C
 parameter R_BUSY            = 3'b100;  // 0x04000010
 parameter R_DATA_OUT        = 3'b101;  // 0x04000014
 parameter S_ENABLE          = 3'b110;  // 0x04000018
 parameter W_DATA_WRITE      = 3'b111;  // 0x0400001C
 
 // √çndice en el array de registros
 parameter slv_addr_register         = 0;
 parameter rw_register               = 1;
 parameter num_pqts_register         = 2;
 parameter state_register            = 3;
 parameter busy_register             = 4;
 parameter data_out_register         = 5;
 parameter enable_register           = 6;
 parameter bus_data_enable_register  = 7;
 
 
 //Entrada desde bus de datos
 reg [7:0] dataArray [7:0];
 reg [31:0] buffer_data_out;
 reg [31:0] data_wr = 32'b0;
 
 assign slv_addr[6:0] = dataArray[slv_addr_register][6:0];      
 assign rw = dataArray[rw_register][0];                   
 assign n_paquetes[2:0] = dataArray[num_pqts_register][2:0];    
 
 assign enable_start = dataArray[enable_register][0];                                    
 assign bus_data_enable = dataArray[bus_data_enable_register][0];      
 
 assign data_write = data_wr;             
 assign bus_data_out = buffer_data_out;     
 assign check = dataArray[W_RW];
 
 wire serdat_write = Bus_addr[5];
 
 always @(posedge clk or negedge rstn) begin
     if (!rstn) begin
         // Reset completo de los registros
         dataArray[0] <= 8'b0;
         dataArray[1] <= 8'b0;
         dataArray[2] <= 8'b0;
         dataArray[3] <= 8'b0;
         dataArray[4] <= 8'b0;
         dataArray[5] <= 8'b0;
         dataArray[6] <= 8'b0;
         dataArray[7] <= 8'b0;
         buffer_data_out <= 32'b0;
         data_wr <= 32'b0;
 
     end else begin
         // Registros actualizados por hardware (FSM)
         dataArray[state_register]    <= {4'b0, I2C_State};
         dataArray[busy_register]     <= {7'b0, I2C_Busy};
         dataArray[data_out_register] <= data_out;
 
         // Interfaz externa desde CPU
         if (serdat_cs) begin
             if (serdat_write) begin
                 // ----------- ESCRITURA -----------
                 if (Bus_addr[4:2] == W_DATA_WRITE) begin
                     data_wr <= Bus_data;
                 end else begin
                     dataArray[Bus_addr[4:2]] <= Bus_data[7:0];
                 end
             end else begin
                 // ----------- LECTURA -----------
                 buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
                 dataArray[bus_data_enable_register] <= 8'b00000001;
             end
         end
 
         // Limpieza de registros de un solo ciclo
         dataArray[enable_register] <= 8'b0;
         dataArray[bus_data_enable_register] <= 8'b0;
     end
 end
 
endmodule


Como puede comprobar, hay dos componentes principales en mi deise√±o. Una interfaz y el m√≥dulo del i2c. Mi intenci√≥n es alimentar la interfaz con los datos necesarios para realizar la comunicaci√≥n del i2c, para despu√©s hacer la comunicaci√≥n asincrona. DEsde el c√≥digo escribiremos y leeremos los datos en la interfaz. Esta mandar√° la informaci√≥n necesaria a la m√°quina de estados del i2x y comenzar√° la comnicaci√≥n . Sin embargo, hay un problema en mi dise√±o. Tras escribir en un registro de la intefaz. La placa queda "secuestrada". No responde. Creo que se debe a que el chip selec del i2c no cambia de valor tras leer o escribir un registro y el control no vuelve al procesador. Podr√≠a ser esto as√≠? C√≥mo puedo solventar el problema de ser este? Tiene sentido viendo como funciona el procesador?
ChatGPT said:

The user is working on an embedded systems project using Verilog. In their top module, they‚Äôre trying to interface with an I2C module but are facing an issue where the board gets ‚Äústuck‚Äù after a register write. They suspect the I2C chip select (CS) isn‚Äôt toggling correctly. Based on the provided details, it seems like the I2C CS signal (i2c_cs) is determined by addr_in[31:6] and bit_valid. I‚Äôll need to check how i2c_cs is being used and whether this matches the expected behavior of the processor.


ChatGPT can make mistakes. Check important info. See Cookie Preferences.


Cuando el procesador hace una operaci√≥n de lectura o escritura sobre tu perif√©rico I¬≤C, lo que ocurre ‚Äúbajo el cap√≥‚Äù es esto:

1. **El procesador pone en el bus**

   * `ADDR` con la direcci√≥n de la interfaz
   * `bit_valid` (o `CS/WE`) activo
   * (en caso de escritura) `DATA` con el dato a escribir

2. **Tu decodificador de direcci√≥n** (`main_vadbda8`) detecta que esa direcci√≥n encaja con `Addr` y, mientras `bit_valid==1`, mantiene `i2c_cs=1`.

3. **La l√≥gica de interfaz** (`main_vecfcb9`) ve `serdat_cs=i2c_cs` y, en funci√≥n de si es lectura o escritura, actualiza sus registros internos.

4. **Espera una se√±al de ‚Äúfin de ciclo‚Äù** (un *ack*): en tu dise√±o esa funci√≥n la cumple la salida `bus_data_enable`. Cuando el procesador ve `bus_data_enable=1`, entiende ‚Äúok, ya recib√≠ tu respuesta‚Äù, baja `bit_valid` y abandona el bus. Al bajar `bit_valid`, tu chip-select deja de estar activo y el bus vuelve al procesador.

---

## ¬øPor qu√© se ‚Äúsecuestra‚Äù la placa?

En tu c√≥digo el pulso `bus_data_enable` solo se genera en la rama de **lectura**:

```verilog
if (serdat_cs) begin
  if (!serdat_write) begin
    // ‚Ä¶ lectura
    dataArray[bus_data_enable_register] <= 8'b00000001;
  end
  // en escritura NO se toca bus_data_enable
end

// y al final:
dataArray[enable_register]      <= 8'b0;
dataArray[bus_data_enable_register] <= 8'b0;
```

‚Äì> **Resultado:** en una escritura nunca sale `bus_data_enable=1`. El procesador **no recibe el ack**, mantiene `bit_valid=1` (y por tanto `i2c_cs=1`) y se queda bloqueado a la espera de que tu perif√©rico termine el ciclo.

---

## ¬øC√≥mo arreglarlo?

1. **Genera el ‚Äúack‚Äù en lectura y en escritura**
   Mueve la asignaci√≥n de `bus_data_enable` para que se active siempre que `serdat_cs` est√© activo, no solo en la lectura. Por ejemplo:

   ```verilog
   if (serdat_cs) begin
     // fin de ciclo para lectura o escritura
     dataArray[bus_data_enable_register] <= 8'b00000001;

     if (serdat_write) begin
       // escritura: actualiza el registro
       if (Bus_addr[4:2] == W_DATA_WRITE)
         data_wr <= Bus_data;
       else
         dataArray[Bus_addr[4:2]] <= Bus_Data[7:0];
     end else begin
       // lectura: prepara buffer de salida
       buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
     end
   end
   ```

   Con esto, en cualquier operaci√≥n tu interfaz levantar√° `bus_data_enable` un ciclo, el procesador lo ver√°, bajar√° `bit_valid` y **devolver√° el bus** autom√°ticamente (por tanto `i2c_cs` caer√° y el procesador seguir√° ejecut√°ndose).

2. **Comprueba tu se√±al de ‚Äúwrite vs read‚Äù**
   Actualmente usas `serdat_write = Bus_addr[5]`, que es un bit de la direcci√≥n, no un stro-be de escritura. Aseg√∫rate de usar el verdadero `WE`/`RD` que te da el procesador (en tu top-level es probablemente `v8859f4` o similar) para distinguir lectura/escritura en vez de reusar un bit de la direcci√≥n.

3. **Hand¬≠shake claro y un pulso**

   * `i2c_cs` debe ser puro ‚Äúaddress match & valid‚Äù.
   * La **confirmaci√≥n** de fin de ciclo la dan se√±ales dedicadas (`ACK_O`, `bus_data_enable`, etc.).
   * Ese pulso de ack debe llegar **SIEMPRE** para lectura y escritura, aunque sea de un solo ciclo, y luego borrarse.

---

### ¬øTiene sentido con tu procesador?

S√≠. Casi todos los cores embebidos mantienen `CS`/`VALID` hasta que reciben un `ACK`. Si tu perif√©rico nunca lo emite en escritura, el core se ‚Äúsecuestra‚Äù a la espera de que termine la transacci√≥n. Generar ese `ACK` (el pulso `bus_data_enable`) al final de **cada** operaci√≥n es **imprescindible** para devolver el control y liberar el bus.

---

**Resumen de la soluci√≥n**

* Mover la generaci√≥n de `bus_data_enable` fuera de la rama de s√≥lo lectura: hazla un handshake unificado para lectura y escritura.
* Usar la se√±al real de ‚Äúwrite enable‚Äù del procesador, en lugar de un bit de la direcci√≥n, para distinguir tipos de acceso.

Con estos cambios, tras escribir un registro tu chip-select caer√° al recibir el ack, y el procesador retomar√° el control sin quedarse bloqueado.





//////////////////////
///////////////
//////////////////

Skip to content
Chat history
You said:
Skip to content
Chat history
You said:
Estos son algunos componenetes de mi proyecto de sistemas empotrados. Podr√°s ver el procesador que estoy usando, la l√≥gica de acceso a este y una uart. Estos componentes funcionan bien y hace lo que se espera. Expl√≠came como actual l√≥gica de acceso y como devuelve el control al procesador despu√©s de d√°rselo a la uart despu√©s de activarla con su se√±al de chip select


Estos son algunos de los componentes de mi proyecto de sistemas empotrados. Expl√≠came como funciona la l√≥gica de acceso. Como es que despu√©s de dar el control el procesador a la uart por medio de su chip select, vuelve el control al procesador
ChatGPT said:
Resumen r√°pido

Tu procesador y la UART comparten el mismo bus de datos/control.
La ‚Äúl√≥gica de acceso‚Äù (bus arbiter + decodificador de direcci√≥n) es la que:

    Detecta cu√°ndo el procesador est√° intentando acceder a la UART (por la direcci√≥n o la se√±al CS_UART que t√∫ generas).

    Cede temporalmente el control de las l√≠neas de datos, direcci√≥n y se√±ales RD/WR a la UART.

    Espera a que la UART responda con ‚Äúoperaci√≥n terminada‚Äù (ACK, READY, TXEMPTY, etc.).

    Des‚Äêaserta CS_UART, pone la UART en alta impedancia (tri-state) y devuelve el bus al procesador (estado IDLE).

Pasos con algo m√°s de detalle
Fase FSM	Se√±ales clave	Qui√©n conduce el bus	Explicaci√≥n breve
IDLE	CS_UART=0, BUSY=0	Procesador	No hay perif√©rico seleccionado.
DECODE	CPU coloca direcci√≥n; la l√≥gica detecta rango de la UART.	Procesador	Si la direcci√≥n ‚àà rango-UART ‚áí CS_UART ‚Üê 1.
UART_ACCESS	CS_UART=1, BUSY=1	UART	El decodificador desconecta la CPU (tri-state) y la UART usa las l√≠neas.
WAIT/COMPLETE	UART genera ACK/READY=1 cuando ha le√≠do/escrito el dato.	UART/-	Arbiter observa la se√±al, des-aserta BUSY.
RETURN	CS_UART‚Üê0, BUSY‚Üê0	Procesador	La FSM vuelve a IDLE; la CPU re-toma el bus.
¬øQu√© hace cada bloque?
Bloque	Se√±ales que mira	Se√±ales que genera	Comentario
Decodificador de direcci√≥n	ADDR[31:0]	CS_UART, CS_RAM, etc.	Normalmente un comparador (rango) + AND con MREQ o VALID.
Arbiter / Bus‚Äêmux	CS_*, RD/WR, ACK, CLK	BUSY, MUX_SEL	Selecciona qui√©n conduce el bus y cu√°ndo.
UART	CS_UART, RD/WR, DATA, CLK	DATA, ACK/READY, IRQ_TX, etc.	Cuando CS_UART=1 se habilita su l√≥gica interna; cuando CS_UART=0 pone salidas en Z.
Mecanismo de ‚Äúdevolver el control‚Äù

    Transferencia finalizada

        La UART termina su lectura/escritura y levanta ACK (o READY).

        Si usas un bus estilo Wishbone, esto equivale a ACK_O=1; en AXI-Lite ser√≠a *_VALID & *_READY.

    FSM detecta el ACK

        En el siguiente flanco de reloj, el arbiter pone CS_UART‚Üê0 y BUSY‚Üê0.

        El multiplexor de datos y direcci√≥n vuelve a seleccionar al procesador.

    CPU reanuda

        El n√∫cleo ve que el ciclo ya no est√° ‚Äúen espera‚Äù (WAIT=0) y continua con la instrucci√≥n siguiente.

        Cualquier interrupci√≥n de la UART (IRQ_TX/IRQ_RX) puede dispararse ahora si procede.

    üí° Importante: Nunca tienes a la UART ‚Äúgobernando‚Äù indefinidamente. El arbiter s√≥lo le da el bus durante ese ciclo de lectura/escritura. Tras el ACK, el control regresa autom√°ticamente al procesador.

Se√±ales t√≠picas en un solo ciclo de escritura (ejemplo)

CLK   ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ...
ADDR  AAAAA|AAAA|AAAA‚îÜ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ    (CPU coloca direcci√≥n de la UART)
DATA  DDDDD|DDDD|DDDD‚îÜ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ    (CPU coloca dato a transmitir)
RD/W  ----W|----W|----W‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     (Write)
CS_U  _____|=====|_____            (Generado por decodificador)
ACK_U ________|===|______          (UART responde cuando listo)
BUSY  ________|===|______          (Arbiter: bus cedido)

Puntos de comprobaci√≥n / Depuraci√≥n r√°pida

    Latencias

        Si la UART necesita varios ciclos, el arbiter debe mantener BUSY hasta el ACK.

        Inserta contadores o un analizador l√≥gico para ver cu√°ndo llega ACK.

    Tri-state o mux

        Comprueba que, mientras CS_UART=0, las salidas de la UART est√°n en alta Z.

        Si usas un bus puramente multiplexado (sin tri-state), aseg√∫rate de que el mux selecciona ‚Äúcero‚Äù o ‚Äúdummy‚Äù.

    Riesgo de contenci√≥n

        Dos perif√©ricos nunca deben conducir las mismas l√≠neas simult√°neamente.

        Vigila en simulaci√≥n que CS exclusivos y multiplexores est√©n bien sincronizados.

    Signal naming

        Usa un prefijo claro ACK_, CS_, BUSY_, REQ_ para cada perif√©rico. Evita nombres ambiguos que te lleven a puentear se√±ales por error.

Conclusi√≥n

    La l√≥gica de acceso es b√°sicamente un peque√±o FSM + decodificador de direcciones que arbitra el bus.

    El procesador pierde el control s√≥lo durante el lapso en que la UART tiene CS activo y hasta que responde con ACK/READY.

    El retorno se produce en el mismo flanco de reloj en que se detecta el ACK‚Äîsimplemente se des-aserta CS, se pone el perif√©rico en Z y el arbiter vuelve a seleccionar al procesador.

Con esto, tu CPU y la UART trabajan sin pisarse, y cada transferencia queda perfectamente acotada en el tiempo.
You said:
Estoy tratando de dise√±ar un perif√©rico nuevo que lleve la comunicaci√≥n del bus de i2c


// Code generated by Icestudio 0.12
// Fri, 18 Jul 2025 01:57:50 GMT

default_nettype none

//---- Top entity
module main #(
 parameter vec4673 = 'h0400_0000,
 parameter v8eaf13 = 'h0400_0001,
 parameter v9c4340 = 100000
) (
 input v87186f,
 input v4dc0ee,
 input [31:0] v867561,
 input v8859f4,
 input [31:0] v23504b,
 output v9127c2,
 output vfe2384,
 output [31:0] v504d16,
 output vf73703,
 output va77527,
 output v34d6ed,
 output v5a58e0,
 output [2:0] v056d28,
 output [7:0] vaac567,
 output v147f2d,
 output [6:0] vc02bbb,
 output [0:7] vinit,
 inout v80923c
);
 localparam p0 = v9c4340;
 localparam p1 = v8eaf13;
 localparam p7 = vec4673;
 wire w2;
 wire [0:6] w3;
 wire w4;
 wire [0:2] w5;
 wire [0:7] w6;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire [0:31] w13;
 wire [0:31] w14;
 wire [0:31] w15;
 wire [0:31] w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 wire [0:31] w29;
 wire [0:31] w30;
 wire [0:3] w31;
 wire w32;
 wire w33;
 wire w34;
 wire [0:6] w35;
 wire [0:6] w36;
 wire [0:31] w37;
 wire [0:7] w38;
 wire [0:2] w39;
 assign vc02bbb = w3;
 assign v056d28 = w5;
 assign vaac567 = w6;
 assign v147f2d = w8;
 assign v9127c2 = w9;
 assign vfe2384 = w12;
 assign w13 = v867561;
 assign w14 = v867561;
 assign w15 = v867561;
 assign v504d16 = w16;
 assign w17 = v87186f;
 assign w18 = v87186f;
 assign w19 = v87186f;
 assign vf73703 = w20;
 assign w21 = v8859f4;
 assign w22 = v4dc0ee;
 assign w23 = v4dc0ee;
 assign w24 = v4dc0ee;
 assign va77527 = w25;
 assign w26 = v80923c;
 assign v5a58e0 = w26;
 assign w27 = v80923c;
 assign v34d6ed = w28;
 assign w29 = v23504b;
 assign w30 = v23504b;
 assign w11 = w10;
 assign w14 = w13;
 assign w15 = w13;
 assign w15 = w14;
 assign w18 = w17;
 assign w19 = w17;
 assign w19 = w18;
 assign w23 = w22;
 assign w24 = w22;
 assign w24 = w23;
 assign w27 = w26;
 assign w30 = w29;
 assign w36 = w35;
 assign w39 = w5;
 v0e64bc #(
  .v207e0d(p0)
 ) v9f9653 (
  .v8337bc(w4),
  .v531e20(w17)
 );
 vf9bdaf #(
  .v6b316b(p1)
 ) v3156fe (
  .v18e78c(w2),
  .ve1f562(w15)
 );
 main_vb9f55b vb9f55b (
  .b(w2),
  .slave__out(w3),
  .a(w11),
  .clk(w19),
  .x(w20),
  .rst_n(w24),
  .y(w25),
  .z(w28),
  .c(w30),
  .slave_out(w36)
 );
 main_v626e75 v626e75 (
  .clk(w4),
  .I2C_SCL(w9),
  .rstn(w22),
  .I2C_SDA(w27),
  .state_out(w31),
  .enable(w32),
  .rw(w33),
  .busy_out(w34),
  .slv_addr(w35),
  .data_in(w37),
  .data_out(w38),
  .n_paquetes(w39)
 );
 main_vadbda8 #(
  .Addr(p7)
 ) vadbda8 (
  .i2c_cs(w10),
  .addr_in(w13),
  .bit_valid(w21)
 );
 main_vecfcb9 vecfcb9 (
  .n_paquetes(w5),
  .check(w6),
  .data_ready(w8),
  .serdat_cs(w10),
  .bus_data_enable(w12),
  .Bus_addr(w14),
  .bus_data_out(w16),
  .clk(w18),
  .rstn(w23),
  .Bus_data(w29),
  .I2C_State(w31),
  .enable_start(w32),
  .rw(w33),
  .I2C_Busy(w34),
  .slv_addr(w35),
  .data_write(w37),
  .data_out(w38)
 );
 assign vinit = 8'b00000000;
endmodule

//---------------------------------------------------
//-- I2C_soc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Perif√©rico encargado de la comunicaci√≥n a trav√©s del bus I2C.
//---------------------------------------------------
//---- Top entity
module v0e64bc #(
 parameter v207e0d = 1
) (
 input v531e20,
 output v8337bc
);
 localparam p2 = v207e0d;
 wire w0;
 wire w1;
 assign v8337bc = w0;
 assign w1 = v531e20;
 v0e64bc_v94c6d7 #(
  .HZ(p2)
 ) v94c6d7 (
  .clk_o(w0),
  .clk(w1)
 );
endmodule

//---------------------------------------------------
//-- Corazon_Hz
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Corazon gen√©rico para bombear bits a la frecuencia fijada en Hz (por defecto 1Hz)
//---------------------------------------------------

module v0e64bc_v94c6d7 #(
 parameter HZ = 0
) (
 input clk,
 output clk_o
);
 
 //parameter HZ=1;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000/HZ;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- REgistro con el valor del reloj
 reg clk_out = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_out <= ~clk_out;
 
 
 assign clk_o = clk_out;  
 
endmodule
//---- Top entity
module vf9bdaf #(
 parameter v6b316b = 0
) (
 input [31:0] ve1f562,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = ve1f562;
 vf9bdaf_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 32 bits. Se compara si el operando es igual al par√°metro
//---------------------------------------------------

module vf9bdaf_vd75681 #(
 parameter K = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a[31:6] == K[31:6]);
endmodule

module main_vb9f55b (
 input clk,
 input rst_n,
 input a,
 input b,
 input [31:0] c,
 input [6:0] slave_out,
 input rw_out,
 output x,
 output y,
 output z,
 output [6:0] slave__out
);
 reg         reg_x = 0;    // ahora es reg
 reg         reg_y = 0;    // ahora es reg
 reg         reg_z = 0;     // ahora es reg
 
 reg [6:0] slave_addr = 7'd0;   
 
 assign x = reg_x;
 assign y = reg_y;
 assign z = reg_z;
 assign slave__out = slave_addr;
 always @(posedge clk or negedge rst_n) begin
 
     
     if (!rst_n) begin
         // Reset: vuelven a 0
         reg_x <= 1'b0;
         reg_y <= 1'b0;
         reg_z <= 1'b0;
         slave_addr <= 8'd0;   
         
     end else begin
         // Al primer 1 en 'a', si a√∫n no lo hab√≠amos detectado
         if (a && !reg_x)
             reg_x <= 1'b1;
 
         // Al primer 1 en 'b'
         if (b && !reg_y)
             reg_y <= 1'b1;
 
         // Al primer 1 en cualquier bit de 'c' (reducci√≥n OR)
         if (c && !reg_z)
             reg_z <= 1'b1;
         
         if(slave_out && !slave_addr)
             slave_addr <= slave_out;
     end
 end
 
endmodule

module main_v626e75 (
 input clk,
 input rstn,
 input enable,
 input rw,
 input [6:0] slv_addr,
 input [31:0] data_in,
 input [2:0] n_paquetes,
 input I2C_SDA,
 output [3:0] state_out,
 output busy_out,
 output [7:0] data_out,
 output I2C_SCL
);
 // Definir los estados de la m√°quina de estados
 localparam READY       = 4'd0;
 localparam START       = 4'd1;
 localparam COMMAND     = 4'd2;
 localparam SLV_OBJ_ACK = 4'd3;
 localparam WRITE_DATA  = 4'd4;
 localparam WRITE_ACK   = 4'd5;
 localparam READ_DATA   = 4'd6;
 localparam READ_ACK    = 4'd7;
 localparam STOP        = 4'd8;
 
 // Bit m√°s significativos
 localparam max_slv_Addr = 7;
 localparam max_data_wr = 31;
 
 // Registros internos
 reg [3:0] state = READY;            // Estado actual
 reg [2:0] counter = 3'd0;           // Contador local. Cuenta hasta 8 bits de un env√≠o
 reg [2:0] num_paquetes = 3'd0;      // Contador de paquetes a enviar.
 reg [7:0] slave_addr = 8'd0;        // Direcci√≥n del esclavo
 reg read_write = 1'd0;              // Lectura o escritura
 reg [31:0] wt_buffer = 32'b0;       // Buffer de escritura. Mensaje a enviar
 reg [7:0] rd_buffer = 8'd0;         // Buffer de lectura. Mensaje recibido
 reg sda_out = 1'd0;                 // Salida de SDA
 reg write_enable = 1'd0;            // Habilitaci√≥n de SDA
 reg enable_reg = 1'd0;
 reg clk_enable;
 reg busy = 1'd0;                    // Flag de bus ocupado
 reg reg_data_ready = 1'b0;
 
 // Asignaciones
 assign busy_out = busy;
 assign data_out = rd_buffer;
 assign I2C_SCL = clk_enable ? clk : 1'b1;       // Pin de SCL
 assign I2C_SDA = write_enable ? 1'b0 : 1'bz;    // Pin de SDA
 
 //always @(posedge enable) begin
 //    enable_reg <= 1'b1;
 //end
 
 // M√°quina de estados I2C
 always @(posedge clk or negedge rstn) begin
     if (!rstn) begin
         state <= READY;        
         counter <= 3'd0;
         num_paquetes <= 2'd0;  
         sda_out <= 1'b1;
         slave_addr <= 8'd0;       
         read_write <= 1'd0;
         wt_buffer <= 24'b0;       
         rd_buffer <= 8'd0;                
         write_enable <= 1'd0;           
         busy <= 1'd0;
         reg_data_ready <= 1'b0;
         enable_reg <= 1'b0;
     end else begin
         case (state)
             READY: begin
                 reg_data_ready <= 1'b0;
                 write_enable <= 1'b0;
                 busy <= enable;
                 if (enable && !enable_reg) begin
                     enable_reg <= 1'b1;
                 end
                 if (enable_reg) begin
                     num_paquetes <= n_paquetes;
                     read_write <= rw;
                     slave_addr <= {slv_addr, rw};
                     wt_buffer <= data_in;
                     enable_reg <= 1'b0;
                     state <= START;
                 end
             end
             START: begin
                 busy <= 1'b1;
                 write_enable <= 1'b1;
                 counter <= 3'd7;
                 sda_out <= slave_addr[max_slv_Addr];               
                 state <= COMMAND;  
             end
             COMMAND: begin
                 if (counter == 3'd0) begin
                     //write_enable <= 1'b0;
                     sda_out <= 1'b0;  // Finaliza el env√≠o de la direcci√≥n
                     state <= SLV_OBJ_ACK;
                 end else begin
                     counter <= counter - 1;
                     slave_addr <= slave_addr << 1; // Desplaza la direcci√≥n del esclavo
                     sda_out <= slave_addr[max_slv_Addr];
                 end
             end
             SLV_OBJ_ACK: begin
                 // Chequear ACK del esclavo. No est√° en el verilog
                 if (I2C_SDA == 1'b1) begin  // Write
                     counter <= 3'd7;
                     write_enable <= 1'b1;
                     sda_out <= wt_buffer[max_data_wr];
                     state <= WRITE_DATA;
                 end else begin               // Read
                     counter <= 3'd7;
                     write_enable <= 1'b0;
                     state <= READ_DATA;
                 end
             end
             WRITE_DATA: begin
                 busy <= 1'b1;
                 if (counter == 3'd0) begin
                     write_enable <= 1'b0;
                     num_paquetes <= num_paquetes - 1'b1;
                     sda_out <= 1'b0;
                     state <= WRITE_ACK;
                 end else begin
                     counter <= counter - 1;
                     wt_buffer <= wt_buffer << 1;
                     sda_out <= wt_buffer[max_data_wr];
                 end
             end
             READ_DATA: begin
                 rd_buffer[counter] <= I2C_SDA;
                 if (counter == 3'd0) begin
                     state <= READ_ACK;
                 end else begin 
                     counter <= counter - 1;
                 end
             end
             WRITE_ACK: begin
                 if (enable == 1'b1) begin
                     if (num_paquetes > 2'b0) begin
                         counter <= 3'd7;
                         write_enable <= 1'b1;
                         sda_out <= wt_buffer[max_data_wr];
                         state <= WRITE_DATA;
                     end else begin
                         state <= STOP;
                     end
                 end else begin 
                     state <= STOP;
                 end
             end
             READ_ACK: begin
                 busy <= 1'b0;
                 write_enable <= 1'b1;
                 sda_out <= 1'b0;
                 reg_data_ready <= 1'b1;
                 state <= STOP;
             end
             STOP: begin
                 write_enable <= 1'b1;
                 sda_out <= 1'b1;
                 busy <= 1'b0;
                 state <= READY;
             end
         endcase
     end
 end
 
 // Control s√≠ncrono de SCL enable
 always @(posedge clk) begin
     if (!rstn)
         clk_enable <= 1'b0;
     else
         clk_enable <= (state != READY) && (state != START) && (state != STOP);
 end
endmodule

module main_vadbda8 #(
 parameter Addr = 0
) (
 input [31:0] addr_in,
 input bit_valid,
 output i2c_cs
);
 assign i2c_cs = (addr_in[31:6] == Addr[31:6]) & bit_valid;
endmodule

module main_vecfcb9 (
 input clk,
 input rstn,
 input [31:0] Bus_addr,
 input [31:0] Bus_data,
 input serdat_cs,
 input [3:0] I2C_State,
 input I2C_Busy,
 input [7:0] data_out,
 output enable_start,
 output rw,
 output [6:0] slv_addr,
 output [31:0] data_write,
 output [2:0] n_paquetes,
 output bus_data_enable,
 output [31:0] bus_data_out,
 output [7:0] check,
 output data_ready
);
 parameter W_SLV_ADDR        = 3'b000;  // 0x04000000
 parameter W_RW              = 3'b001;  // 0x04000004
 parameter W_N_PQTS          = 3'b010;  // 0x04000008
 parameter R_STATE           = 3'b011;  // 0x0400000C
 parameter R_BUSY            = 3'b100;  // 0x04000010
 parameter R_DATA_OUT        = 3'b101;  // 0x04000014
 parameter S_ENABLE          = 3'b110;  // 0x04000018
 parameter W_DATA_WRITE      = 3'b111;  // 0x0400001C
 
 // √çndice en el array de registros
 parameter slv_addr_register         = 0;
 parameter rw_register               = 1;
 parameter num_pqts_register         = 2;
 parameter state_register            = 3;
 parameter busy_register             = 4;
 parameter data_out_register         = 5;
 parameter enable_register           = 6;
 parameter bus_data_enable_register  = 7;
 
 
 //Entrada desde bus de datos
 reg [7:0] dataArray [7:0];
 reg [31:0] buffer_data_out;
 reg [31:0] data_wr = 32'b0;
 
 assign slv_addr[6:0] = dataArray[slv_addr_register][6:0];      
 assign rw = dataArray[rw_register][0];                   
 assign n_paquetes[2:0] = dataArray[num_pqts_register][2:0];    
 
 assign enable_start = dataArray[enable_register][0];                                    
 assign bus_data_enable = dataArray[bus_data_enable_register][0];      
 
 assign data_write = data_wr;             
 assign bus_data_out = buffer_data_out;     
 assign check = dataArray[W_RW];
 
 wire serdat_write = Bus_addr[5];
 
 always @(posedge clk or negedge rstn) begin
     if (!rstn) begin
         // Reset completo de los registros
         dataArray[0] <= 8'b0;
         dataArray[1] <= 8'b0;
         dataArray[2] <= 8'b0;
         dataArray[3] <= 8'b0;
         dataArray[4] <= 8'b0;
         dataArray[5] <= 8'b0;
         dataArray[6] <= 8'b0;
         dataArray[7] <= 8'b0;
         buffer_data_out <= 32'b0;
         data_wr <= 32'b0;
 
     end else begin
         // Registros actualizados por hardware (FSM)
         dataArray[state_register]    <= {4'b0, I2C_State};
         dataArray[busy_register]     <= {7'b0, I2C_Busy};
         dataArray[data_out_register] <= data_out;
 
         // Interfaz externa desde CPU
         if (serdat_cs) begin
             if (serdat_write) begin
                 // ----------- ESCRITURA -----------
                 if (Bus_addr[4:2] == W_DATA_WRITE) begin
                     data_wr <= Bus_data;
                 end else begin
                     dataArray[Bus_addr[4:2]] <= Bus_data[7:0];
                 end
             end else begin
                 // ----------- LECTURA -----------
                 buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
                 dataArray[bus_data_enable_register] <= 8'b00000001;
             end
         end
 
         // Limpieza de registros de un solo ciclo
         dataArray[enable_register] <= 8'b0;
         dataArray[bus_data_enable_register] <= 8'b0;
     end
 end
 
endmodule


Como puede comprobar, hay dos componentes principales en mi deise√±o. Una interfaz y el m√≥dulo del i2c. Mi intenci√≥n es alimentar la interfaz con los datos necesarios para realizar la comunicaci√≥n del i2c, para despu√©s hacer la comunicaci√≥n asincrona. DEsde el c√≥digo escribiremos y leeremos los datos en la interfaz. Esta mandar√° la informaci√≥n necesaria a la m√°quina de estados del i2x y comenzar√° la comnicaci√≥n . Sin embargo, hay un problema en mi dise√±o. Tras escribir en un registro de la intefaz. La placa queda "secuestrada". No responde. Creo que se debe a que el chip selec del i2c no cambia de valor tras leer o escribir un registro y el control no vuelve al procesador. Podr√≠a ser esto as√≠? C√≥mo puedo solventar el problema de ser este? Tiene sentido viendo como funciona el procesador?
ChatGPT said:

The user is working on an embedded systems project using Verilog. In their top module, they‚Äôre trying to interface with an I2C module but are facing an issue where the board gets ‚Äústuck‚Äù after a register write. They suspect the I2C chip select (CS) isn‚Äôt toggling correctly. Based on the provided details, it seems like the I2C CS signal (i2c_cs) is determined by addr_in[31:6] and bit_valid. I‚Äôll need to check how i2c_cs is being used and whether this matches the expected behavior of the processor.


ChatGPT can make mistakes. Check important info. See Cookie Preferences.


Cuando el procesador hace una operaci√≥n de lectura o escritura sobre tu perif√©rico I¬≤C, lo que ocurre ‚Äúbajo el cap√≥‚Äù es esto:

1. **El procesador pone en el bus**

   * ADDR con la direcci√≥n de la interfaz
   * bit_valid (o CS/WE) activo
   * (en caso de escritura) DATA con el dato a escribir

2. **Tu decodificador de direcci√≥n** (main_vadbda8) detecta que esa direcci√≥n encaja con Addr y, mientras bit_valid==1, mantiene i2c_cs=1.

3. **La l√≥gica de interfaz** (main_vecfcb9) ve serdat_cs=i2c_cs y, en funci√≥n de si es lectura o escritura, actualiza sus registros internos.

4. **Espera una se√±al de ‚Äúfin de ciclo‚Äù** (un *ack*): en tu dise√±o esa funci√≥n la cumple la salida bus_data_enable. Cuando el procesador ve bus_data_enable=1, entiende ‚Äúok, ya recib√≠ tu respuesta‚Äù, baja bit_valid y abandona el bus. Al bajar bit_valid, tu chip-select deja de estar activo y el bus vuelve al procesador.

---

## ¬øPor qu√© se ‚Äúsecuestra‚Äù la placa?

En tu c√≥digo el pulso bus_data_enable solo se genera en la rama de **lectura**:

verilog
if (serdat_cs) begin
  if (!serdat_write) begin
    // ‚Ä¶ lectura
    dataArray[bus_data_enable_register] <= 8'b00000001;
  end
  // en escritura NO se toca bus_data_enable
end

// y al final:
dataArray[enable_register]      <= 8'b0;
dataArray[bus_data_enable_register] <= 8'b0;



‚Äì> **Resultado:** en una escritura nunca sale bus_data_enable=1. El procesador **no recibe el ack**, mantiene bit_valid=1 (y por tanto i2c_cs=1) y se queda bloqueado a la espera de que tu perif√©rico termine el ciclo.

---

## ¬øC√≥mo arreglarlo?

1. **Genera el ‚Äúack‚Äù en lectura y en escritura**
   Mueve la asignaci√≥n de bus_data_enable para que se active siempre que serdat_cs est√© activo, no solo en la lectura. Por ejemplo:

   

verilog
   if (serdat_cs) begin
     // fin de ciclo para lectura o escritura
     dataArray[bus_data_enable_register] <= 8'b00000001;

     if (serdat_write) begin
       // escritura: actualiza el registro
       if (Bus_addr[4:2] == W_DATA_WRITE)
         data_wr <= Bus_data;
       else
         dataArray[Bus_addr[4:2]] <= Bus_Data[7:0];
     end else begin
       // lectura: prepara buffer de salida
       buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
     end
   end



   Con esto, en cualquier operaci√≥n tu interfaz levantar√° bus_data_enable un ciclo, el procesador lo ver√°, bajar√° bit_valid y **devolver√° el bus** autom√°ticamente (por tanto i2c_cs caer√° y el procesador seguir√° ejecut√°ndose).

2. **Comprueba tu se√±al de ‚Äúwrite vs read‚Äù**
   Actualmente usas serdat_write = Bus_addr[5], que es un bit de la direcci√≥n, no un stro-be de escritura. Aseg√∫rate de usar el verdadero WE/RD que te da el procesador (en tu top-level es probablemente v8859f4 o similar) para distinguir lectura/escritura en vez de reusar un bit de la direcci√≥n.

3. **Hand¬≠shake claro y un pulso**

   * i2c_cs debe ser puro ‚Äúaddress match & valid‚Äù.
   * La **confirmaci√≥n** de fin de ciclo la dan se√±ales dedicadas (ACK_O, bus_data_enable, etc.).
   * Ese pulso de ack debe llegar **SIEMPRE** para lectura y escritura, aunque sea de un solo ciclo, y luego borrarse.

---

### ¬øTiene sentido con tu procesador?

S√≠. Casi todos los cores embebidos mantienen CS/VALID hasta que reciben un ACK. Si tu perif√©rico nunca lo emite en escritura, el core se ‚Äúsecuestra‚Äù a la espera de que termine la transacci√≥n. Generar ese ACK (el pulso bus_data_enable) al final de **cada** operaci√≥n es **imprescindible** para devolver el control y liberar el bus.

---

**Resumen de la soluci√≥n**

* Mover la generaci√≥n de bus_data_enable fuera de la rama de s√≥lo lectura: hazla un handshake unificado para lectura y escritura.
* Usar la se√±al real de ‚Äúwrite enable‚Äù del procesador, en lugar de un bit de la direcci√≥n, para distinguir tipos de acceso.

Con estos cambios, tras escribir un registro tu chip-select caer√° al recibir el ack, y el procesador retomar√° el control sin quedarse bloqueado.





Mi √∫ltima versi√≥n del dise√±o es esta. A√∫n sigue secuestrando la placa. Qu√© cambios puedo hacer?

// Code generated by Icestudio 0.12
// Fri, 18 Jul 2025 15:42:15 GMT

default_nettype none

//---- Top entity
module main #(
 parameter vec4673 = 'h0400_0000,
 parameter v8eaf13 = 'h0400_0001,
 parameter v9c4340 = 100000
) (
 input v87186f,
 input v4dc0ee,
 input [31:0] v867561,
 input v8859f4,
 input [31:0] v23504b,
 output v9127c2,
 output vfe2384,
 output [31:0] v504d16,
 output vf73703,
 output va77527,
 output v34d6ed,
 output v5a58e0,
 output [7:0] vaac567,
 output [6:0] vc02bbb,
 output [0:7] vinit,
 inout v80923c
);
 localparam p0 = v9c4340;
 localparam p1 = v8eaf13;
 localparam p6 = vec4673;
 wire w2;
 wire [0:6] w3;
 wire w4;
 wire [0:7] w5;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire [0:31] w11;
 wire [0:31] w12;
 wire [0:31] w13;
 wire [0:31] w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire [0:31] w28;
 wire [0:31] w29;
 wire [0:3] w30;
 wire w31;
 wire w32;
 wire w33;
 wire [0:6] w34;
 wire [0:6] w35;
 wire [0:31] w36;
 wire [0:7] w37;
 wire [0:2] w38;
 assign vc02bbb = w3;
 assign vaac567 = w5;
 assign v9127c2 = w7;
 assign vfe2384 = w10;
 assign w11 = v867561;
 assign w12 = v867561;
 assign w13 = v867561;
 assign v504d16 = w14;
 assign w15 = v87186f;
 assign w16 = v87186f;
 assign w17 = v87186f;
 assign vf73703 = w18;
 assign w19 = v8859f4;
 assign w20 = v8859f4;
 assign w21 = v4dc0ee;
 assign w22 = v4dc0ee;
 assign w23 = v4dc0ee;
 assign va77527 = w24;
 assign w25 = v80923c;
 assign v5a58e0 = w25;
 assign w26 = v80923c;
 assign v34d6ed = w27;
 assign w28 = v23504b;
 assign w29 = v23504b;
 assign w9 = w8;
 assign w12 = w11;
 assign w13 = w11;
 assign w13 = w12;
 assign w16 = w15;
 assign w17 = w15;
 assign w17 = w16;
 assign w20 = w19;
 assign w22 = w21;
 assign w23 = w21;
 assign w23 = w22;
 assign w26 = w25;
 assign w29 = w28;
 assign w35 = w34;
 v0e64bc #(
  .v207e0d(p0)
 ) v9f9653 (
  .v8337bc(w4),
  .v531e20(w15)
 );
 vf9bdaf #(
  .v6b316b(p1)
 ) v3156fe (
  .v18e78c(w2),
  .ve1f562(w13)
 );
 main_vb9f55b vb9f55b (
  .b(w2),
  .slave__out(w3),
  .a(w9),
  .clk(w17),
  .x(w18),
  .rst_n(w23),
  .y(w24),
  .z(w27),
  .c(w29),
  .slave_out(w35)
 );
 main_v626e75 v626e75 (
  .clk(w4),
  .I2C_SCL(w7),
  .rstn(w21),
  .I2C_SDA(w26),
  .state_out(w30),
  .enable(w31),
  .rw(w32),
  .busy_out(w33),
  .slv_addr(w34),
  .data_in(w36),
  .data_out(w37),
  .n_paquetes(w38)
 );
 main_vadbda8 #(
  .Addr(p6)
 ) vadbda8 (
  .i2c_cs(w8),
  .addr_in(w11),
  .bit_valid(w19)
 );
 main_vecfcb9 vecfcb9 (
  .check(w5),
  .serdat_cs(w8),
  .bus_data_enable(w10),
  .Bus_addr(w12),
  .bus_data_out(w14),
  .clk(w16),
  .valid(w20),
  .rstn(w22),
  .Bus_data(w28),
  .I2C_State(w30),
  .enable_start(w31),
  .rw(w32),
  .I2C_Busy(w33),
  .slv_addr(w34),
  .data_write(w36),
  .data_out(w37),
  .n_paquetes(w38)
 );
 assign vinit = 8'b00000000;
endmodule

//---------------------------------------------------
//-- I2C_soc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Perif√©rico encargado de la comunicaci√≥n a trav√©s del bus I2C.
//---------------------------------------------------
//---- Top entity
module v0e64bc #(
 parameter v207e0d = 1
) (
 input v531e20,
 output v8337bc
);
 localparam p2 = v207e0d;
 wire w0;
 wire w1;
 assign v8337bc = w0;
 assign w1 = v531e20;
 v0e64bc_v94c6d7 #(
  .HZ(p2)
 ) v94c6d7 (
  .clk_o(w0),
  .clk(w1)
 );
endmodule

//---------------------------------------------------
//-- Corazon_Hz
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Corazon gen√©rico para bombear bits a la frecuencia fijada en Hz (por defecto 1Hz)
//---------------------------------------------------

module v0e64bc_v94c6d7 #(
 parameter HZ = 0
) (
 input clk,
 output clk_o
);
 
 //parameter HZ=1;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000/HZ;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- REgistro con el valor del reloj
 reg clk_out = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_out <= ~clk_out;
 
 
 assign clk_o = clk_out;  
 
endmodule
//---- Top entity
module vf9bdaf #(
 parameter v6b316b = 0
) (
 input [31:0] ve1f562,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = ve1f562;
 vf9bdaf_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 32 bits. Se compara si el operando es igual al par√°metro
//---------------------------------------------------

module vf9bdaf_vd75681 #(
 parameter K = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a[31:6] == K[31:6]);
endmodule

module main_vb9f55b (
 input clk,
 input rst_n,
 input a,
 input b,
 input [31:0] c,
 input [6:0] slave_out,
 input rw_out,
 output x,
 output y,
 output z,
 output [6:0] slave__out
);
 reg         reg_x = 0;    // ahora es reg
 reg         reg_y = 0;    // ahora es reg
 reg         reg_z = 0;     // ahora es reg
 
 reg [6:0] slave_addr = 7'd0;   
 
 assign x = reg_x;
 assign y = reg_y;
 assign z = reg_z;
 assign slave__out = slave_addr;
 always @(posedge clk or negedge rst_n) begin
 
     
     if (!rst_n) begin
         // Reset: vuelven a 0
         reg_x <= 1'b0;
         reg_y <= 1'b0;
         reg_z <= 1'b0;
         slave_addr <= 8'd0;   
         
     end else begin
         // Al primer 1 en 'a', si a√∫n no lo hab√≠amos detectado
         if (a && !reg_x)
             reg_x <= 1'b1;
 
         // Al primer 1 en 'b'
         if (b && !reg_y)
             reg_y <= 1'b1;
 
         // Al primer 1 en cualquier bit de 'c' (reducci√≥n OR)
         if (c && !reg_z)
             reg_z <= 1'b1;
         
         if(slave_out && !slave_addr)
             slave_addr <= slave_out;
     end
 end
 
endmodule

module main_v626e75 (
 input clk,
 input rstn,
 input enable,
 input rw,
 input [6:0] slv_addr,
 input [31:0] data_in,
 input [2:0] n_paquetes,
 input I2C_SDA,
 output [3:0] state_out,
 output busy_out,
 output [7:0] data_out,
 output I2C_SCL
);
 // Definir los estados de la m√°quina de estados
 localparam READY       = 4'd0;
 localparam START       = 4'd1;
 localparam COMMAND     = 4'd2;
 localparam SLV_OBJ_ACK = 4'd3;
 localparam WRITE_DATA  = 4'd4;
 localparam WRITE_ACK   = 4'd5;
 localparam READ_DATA   = 4'd6;
 localparam READ_ACK    = 4'd7;
 localparam STOP        = 4'd8;
 
 // Bit m√°s significativos
 localparam max_slv_Addr = 7;
 localparam max_data_wr = 31;
 
 // Registros internos
 reg [3:0] state = READY;            // Estado actual
 reg [2:0] counter = 3'd0;           // Contador local. Cuenta hasta 8 bits de un env√≠o
 reg [2:0] num_paquetes = 3'd0;      // Contador de paquetes a enviar.
 reg [7:0] slave_addr = 8'd0;        // Direcci√≥n del esclavo
 reg read_write = 1'd0;              // Lectura o escritura
 reg [31:0] wt_buffer = 32'b0;       // Buffer de escritura. Mensaje a enviar
 reg [7:0] rd_buffer = 8'd0;         // Buffer de lectura. Mensaje recibido
 reg sda_out = 1'd0;                 // Salida de SDA
 reg write_enable = 1'd0;            // Habilitaci√≥n de SDA
 reg enable_reg = 1'd0;
 reg clk_enable;
 reg busy = 1'd0;                    // Flag de bus ocupado
 reg reg_data_ready = 1'b0;
 
 // Asignaciones
 assign busy_out = busy;
 assign data_out = rd_buffer;
 assign I2C_SCL = clk_enable ? clk : 1'b1;       // Pin de SCL
 assign I2C_SDA = write_enable ? 1'b0 : 1'bz;    // Pin de SDA
 
 //always @(posedge enable) begin
 //    enable_reg <= 1'b1;
 //end
 
 // M√°quina de estados I2C
 always @(posedge clk or negedge rstn) begin
     if (!rstn) begin
         state <= READY;        
         counter <= 3'd0;
         num_paquetes <= 2'd0;  
         sda_out <= 1'b1;
         slave_addr <= 8'd0;       
         read_write <= 1'd0;
         wt_buffer <= 24'b0;       
         rd_buffer <= 8'd0;                
         write_enable <= 1'd0;           
         busy <= 1'd0;
         reg_data_ready <= 1'b0;
         enable_reg <= 1'b0;
     end else begin
         case (state)
             READY: begin
                 reg_data_ready <= 1'b0;
                 write_enable <= 1'b0;
                 busy <= enable;
                 if (enable && !enable_reg) begin
                     enable_reg <= 1'b1;
                 end
                 if (enable_reg) begin
                     num_paquetes <= n_paquetes;
                     read_write <= rw;
                     slave_addr <= {slv_addr, rw};
                     wt_buffer <= data_in;
                     enable_reg <= 1'b0;
                     state <= START;
                 end
             end
             START: begin
                 busy <= 1'b1;
                 write_enable <= 1'b1;
                 counter <= 3'd7;
                 sda_out <= slave_addr[max_slv_Addr];               
                 state <= COMMAND;  
             end
             COMMAND: begin
                 if (counter == 3'd0) begin
                     //write_enable <= 1'b0;
                     sda_out <= 1'b0;  // Finaliza el env√≠o de la direcci√≥n
                     state <= SLV_OBJ_ACK;
                 end else begin
                     counter <= counter - 1;
                     slave_addr <= slave_addr << 1; // Desplaza la direcci√≥n del esclavo
                     sda_out <= slave_addr[max_slv_Addr];
                 end
             end
             SLV_OBJ_ACK: begin
                 // Chequear ACK del esclavo. No est√° en el verilog
                 if (I2C_SDA == 1'b1) begin  // Write
                     counter <= 3'd7;
                     write_enable <= 1'b1;
                     sda_out <= wt_buffer[max_data_wr];
                     state <= WRITE_DATA;
                 end else begin               // Read
                     counter <= 3'd7;
                     write_enable <= 1'b0;
                     state <= READ_DATA;
                 end
             end
             WRITE_DATA: begin
                 busy <= 1'b1;
                 if (counter == 3'd0) begin
                     write_enable <= 1'b0;
                     num_paquetes <= num_paquetes - 1'b1;
                     sda_out <= 1'b0;
                     state <= WRITE_ACK;
                 end else begin
                     counter <= counter - 1;
                     wt_buffer <= wt_buffer << 1;
                     sda_out <= wt_buffer[max_data_wr];
                 end
             end
             READ_DATA: begin
                 rd_buffer[counter] <= I2C_SDA;
                 if (counter == 3'd0) begin
                     state <= READ_ACK;
                 end else begin 
                     counter <= counter - 1;
                 end
             end
             WRITE_ACK: begin
                 if (enable == 1'b1) begin
                     if (num_paquetes > 2'b0) begin
                         counter <= 3'd7;
                         write_enable <= 1'b1;
                         sda_out <= wt_buffer[max_data_wr];
                         state <= WRITE_DATA;
                     end else begin
                         state <= STOP;
                     end
                 end else begin 
                     state <= STOP;
                 end
             end
             READ_ACK: begin
                 busy <= 1'b0;
                 write_enable <= 1'b1;
                 sda_out <= 1'b0;
                 reg_data_ready <= 1'b1;
                 state <= STOP;
             end
             STOP: begin
                 write_enable <= 1'b1;
                 sda_out <= 1'b1;
                 busy <= 1'b0;
                 state <= READY;
             end
         endcase
     end
 end
 
 // Control s√≠ncrono de SCL enable
 always @(posedge clk) begin
     if (!rstn)
         clk_enable <= 1'b0;
     else
         clk_enable <= (state != READY) && (state != START) && (state != STOP);
 end
endmodule

module main_vadbda8 #(
 parameter Addr = 0
) (
 input [31:0] addr_in,
 input bit_valid,
 output i2c_cs
);
 assign i2c_cs = (addr_in[31:6] == Addr[31:6]) & bit_valid;
endmodule

module main_vecfcb9 (
 input clk,
 input rstn,
 input valid,
 input [31:0] Bus_addr,
 input [31:0] Bus_data,
 input serdat_cs,
 input [3:0] I2C_State,
 input I2C_Busy,
 input [7:0] data_out,
 output enable_start,
 output rw,
 output [6:0] slv_addr,
 output [31:0] data_write,
 output [2:0] n_paquetes,
 output bus_data_enable,
 output [31:0] bus_data_out,
 output [7:0] check,
 output data_ready
);
 parameter W_SLV_ADDR        = 3'b000;  // 0x04000000
 parameter W_RW              = 3'b001;  // 0x04000004
 parameter W_N_PQTS          = 3'b010;  // 0x04000008
 parameter R_STATE           = 3'b011;  // 0x0400000C
 parameter R_BUSY            = 3'b100;  // 0x04000010
 parameter R_DATA_OUT        = 3'b101;  // 0x04000014
 parameter S_ENABLE          = 3'b110;  // 0x04000018
 parameter W_DATA_WRITE      = 3'b111;  // 0x0400001C
 
 // √çndice en el array de registros
 parameter slv_addr_register         = 0;
 parameter rw_register               = 1;
 parameter num_pqts_register         = 2;
 parameter state_register            = 3;
 parameter busy_register             = 4;
 parameter data_out_register         = 5;
 parameter enable_register           = 6;
 parameter bus_data_enable_register  = 7;
 
 
 //Entrada desde bus de datos
 reg [7:0] dataArray [7:0];
 reg [31:0] buffer_data_out;
 reg [31:0] data_wr = 32'b0;
 
 assign slv_addr[6:0] = dataArray[slv_addr_register][6:0];      
 assign rw = dataArray[rw_register][0];                   
 assign n_paquetes[2:0] = dataArray[num_pqts_register][2:0];    
 
 assign enable_start = dataArray[enable_register][0];                                    
 assign bus_data_enable = dataArray[bus_data_enable_register][0];      
 
 assign data_write = data_wr;             
 assign bus_data_out = buffer_data_out;     
 assign check = dataArray[W_N_PQTS];
 
 wire serdat_write = valid;
 
 always @(posedge clk or negedge rstn) begin
     if (!rstn) begin
         // Reset completo de los registros
         dataArray[0] <= 8'b0;
         dataArray[1] <= 8'b0;
         dataArray[2] <= 8'b0;
         dataArray[3] <= 8'b0;
         dataArray[4] <= 8'b0;
         dataArray[5] <= 8'b0;
         dataArray[6] <= 8'b0;
         dataArray[7] <= 8'b0;
         buffer_data_out <= 32'b0;
         data_wr <= 32'b0;
 
     end else begin
         // Registros actualizados por hardware (FSM)
         dataArray[state_register]    <= {4'b0, I2C_State};
         dataArray[busy_register]     <= {7'b0, I2C_Busy};
         dataArray[data_out_register] <= data_out;
         
 
         // Interfaz externa desde CPU
         if (serdat_cs) begin
         dataArray[bus_data_enable_register] <= !dataArray[bus_data_enable_register];
             if (serdat_write) begin
                 // ----------- ESCRITURA -----------
                 if (Bus_addr[4:2] == W_DATA_WRITE) begin
                     data_wr <= Bus_data;
                 end else begin
                     dataArray[Bus_addr[4:2]] <= Bus_data[7:0];
                 end
             end else begin
                 // ----------- LECTURA -----------
                 buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
                 dataArray[bus_data_enable_register] <= 8'b00000001;
             end
         end
 
         // Limpieza de registros de un solo ciclo
         dataArray[enable_register] <= 8'b0;
     end
 end
 
endmodule
ChatGPT said:
Qu√© est√° ocurriendo ahora mismo

    bus_data_enable ya no es un pulso

        Antes lo pon√≠as a 1 s√≥lo un ciclo y lo volv√≠as a 0 inmediatamente; el procesador ve√≠a el flanco, bajaba bit_valid y el chip-select (i2c_cs) ca√≠a.

        En la versi√≥n nueva primero lo conmutas

dataArray[bus_data_enable_register] <= !dataArray[bus_data_enable_register];

y, si la operaci√≥n es de lectura, lo vuelves a cargar en 1:

    dataArray[bus_data_enable_register] <= 8'b00000001;

    El resultado es que bus_data_enable permanece a 1 (o se queda oscilando si encadenas varias escrituras) y nunca vuelve a 0 mientras bit_valid siga alto ‚Üí el procesador sigue esperando que ‚Äútermine‚Äù la transacci√≥n y se queda bloqueado.

No distingues lectura vs escritura
En tu bus externo no hay ninguna se√±al WE de verdad, as√≠ que necesitas reconstruirla.
Con Icestudio/minisoc se codifica normalmente en el bit 5 de la direcci√≥n (0x‚Ä¶._20_ = write, 0x‚Ä¶._00_ = read).
Al sustituirlo por valid (que es el mismo bit_valid que ya usas para serdat_cs) acabas diciendo ‚Äúesto es siempre una escritura‚Äù, con lo que el procesador nunca espera datos de vuelta y el handshake se rompe en las lecturas.

I2C_SDA no sale por el pin
En main_v626e75 asignas

    assign I2C_SDA = write_enable ? 1'b0 : 1'bz;

    pero la l√≠nea que realmente quieres sacar es sda_out; as√≠, tu esclavo nunca ve los bits y te quedas en el estado SLV_OBJ_ACK.

Cambios m√≠nimos para que el bus deje de ‚Äúsecuestrarse‚Äù

// --------------- HANDSHAKE ---------------
reg ack_r /*verilator coverage_off*/;

always @(posedge clk or negedge rstn) begin
    if (!rstn)
        ack_r <= 1'b0;
    else if (serdat_cs && !ack_r)   // sube UNA vez cuando valid est√° alto
        ack_r <= 1'b1;
    else
        ack_r <= 1'b0;              // vuelve a 0 al siguiente ciclo
end

assign bus_data_enable = ack_r;     // <-- pulso limpio de 1 ciclo

Quita las dos asignaciones a dataArray[bus_data_enable_register] y elimina la l√≠nea que lo conmutaba: el pulso se genera con el registro ack_r y punto.

// --------------- WRITE vs READ ---------------
// El bit 5 de la direcci√≥n indica escritura en este SoC
wire serdat_write = Bus_addr[5];   // tal y como ten√≠as al principio

// --------------- I2C SDA ---------------------
assign I2C_SDA = write_enable ? sda_out : 1'bz;

Resumen‚Äêpaso-a-paso de la transacci√≥n tras los cambios
Ciclo	CPU pone	Tu l√≥gica hace	Se√±ales
0	bit_valid=1, ADDR=0x0400_0004‚Ä¶	i2c_cs=1, serdat_cs=1	
1		Generas ack_r=1 un solo ciclo	bus_data_enable=1
2	CPU ve el ack, baja bit_valid	Con serdat_cs=0, tu CS cae	i2c_cs=0, ack_r=0
3	Bus vuelve al estado IDLE		

El procesador avanza a la siguiente instrucci√≥n y la placa deja de ‚Äúcolgarse‚Äù.
Consejos de depuraci√≥n r√°pida

    Conecta un analizador l√≥gico a bit_valid, i2c_cs, bus_data_enable y I2C_SDA. Ver√°s enseguida si el pulso de ack dura m√°s de un ciclo o si nunca se produce.

    A√±ade assert() en simulaci√≥n:

    assert property (@(posedge clk) !(bus_data_enable && !serdat_cs));

    (el ack no debe quedar alto cuando serdat_cs=0).

Con esos tres cambios tu peripheral volver√° a ceder el bus despu√©s de cada acceso y el sistema ya no quedar√° ‚Äúsecuestrado‚Äù.
You said:
Te voy a pasar el dise√±o del procesador, la l√≥gica de acceso a los buses y la uart. Todas estas piezas funcionan correctamente. Quiero saber como la uart devuelve el contro al procesador despu√©s de que este hable con ella. Qu√© podemos aplicar de ah√≠ en nuestro dise√±o?
ChatGPT said:

¬°Perfecto! Para ver exactamente qu√© hace tu procesador y, sobre todo, qu√© se√±al usa la UART para decirle ‚Äú ya termin√©, suelta el bus ‚Äù, necesito echar un vistazo a los tres bloques que mencionas:

    El ‚Äúbus interface / arbiter‚Äù del procesador
    (donde se decodifican las direcciones, se genera el chip-select de cada perif√©rico y se controla la se√±al de espera / ACK).

    La propia UART
    (normalmente tendr√° una salida ready, ack, tx_done, busy, etc. que el arbiter vigila).

    Cualquier se√±al de wait-state del procesador
    (p. ej. cpu_wait, stall, data_ready, mem_ack, etc.).

Con esos tres archivos (o fragmentos) podr√© se√±alar:

    Qu√© pulso exacto devuelve el control al procesador.

    C√≥mo se desaserta el chip-select en el ciclo siguiente.

    Qu√© partes de ese mecanismo podr√≠as copiar literalmente en tu perif√©rico I¬≤C para que el handshake sea id√©ntico y el core nunca se quede atascado.

Cuando tengas a mano esos m√≥dulos, p√©gamelos aqu√≠ (o sube s√≥lo las porciones relevantes: puertos y siempre/fsm principal). As√≠ podremos mapear ‚ÄúUART_ready ‚Üí bus_data_enable‚Äù paso por paso.
You said:
// Code generated by Icestudio 0.12
// Fri, 18 Jul 2025 01:52:25 GMT

default_nettype none

//---- Top entity
module main #(
 parameter vc35d18 = 'h0200_0008
) (
 input vedf4d3,
 input vclk,
 output v75100e,
 output [0:7] vinit
);
 localparam p1 = vc35d18;
 wire w0;
 wire w2;
 wire [0:31] w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire [0:31] w11;
 wire w12;
 wire [0:31] w13;
 wire [0:31] w14;
 wire [0:31] w15;
 wire w16;
 wire [0:3] w17;
 wire w18;
 assign v75100e = w0;
 assign w2 = vedf4d3;
 assign w5 = vclk;
 assign w6 = vclk;
 assign w7 = vclk;
 assign w6 = w5;
 assign w7 = w5;
 assign w7 = w6;
 assign w9 = w8;
 v35f267 v2ffad9 (
  .v0e28cb(w4),
  .vcbab45(w8)
 );
 v725d0b v8a4f34 (
  .v9b328c(w3)
 );
 v87abc9 v9c5b8c (
  .vcbab45(w12),
  .v132c67(w16)
 );
 v604573 #(
  .v4fde05(p1)
 ) vd7443c (
  .v2ab975(w0),
  .vb6935e(w2),
  .v34e785(w5),
  .v866d25(w9),
  .vad40e9(w10),
  .v9f8bfb(w11),
  .v62ea55(w13),
  .v0fa3a4(w15),
  .vdc4800(w16),
  .vd996e9(w17),
  .vf3ed26(w18)
 );
 vaad680 vd61c1a (
  .v29fe33(w3),
  .vba7c72(w6),
  .v5d0f7b(w8),
  .v006d37(w10),
  .vd67338(w11),
  .v9b0ff0(w12),
  .v8fd87d(w14),
  .ve61aa7(w15),
  .v83dbbe(w17)
 );
 v5242e2 v207e8b (
  .vae8a69(w13),
  .v493538(w14),
  .v58d02d(w18)
 );
 v2b4233 v4c1284 (
  .v6d0651(w4),
  .v4c8225(w7)
 );
 assign vinit = 8'b00000000;
endmodule

//---- Top entity
module v35f267 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v35f267_vd54ca1 vd54ca1 (
  .a(w0),
  .c(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta NOT
//---------------------------------------------------

module v35f267_vd54ca1 (
 input a,
 output c
);
 //-- Puerta NOT
 
 //-- module (input wire a, output wire c);
 
 
 assign c = ~a;
 
 
 //-- endmodule
 
endmodule
//---- Top entity
module v725d0b #(
 parameter vc5c8ea = 0
) (
 output [31:0] v9b328c
);
 localparam p0 = vc5c8ea;
 wire [0:31] w1;
 assign v9b328c = w1;
 v70cd06 #(
  .vc5c8ea(p0)
 ) v38acc0 (
  .v751a1b(w1)
 );
endmodule

//---------------------------------------------------
//-- Valor_00_32bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor constante 0, de 32 bits
//---------------------------------------------------
//---- Top entity
module v70cd06 #(
 parameter vc5c8ea = 0
) (
 output [31:0] v751a1b
);
 localparam p0 = vc5c8ea;
 wire [0:31] w1;
 assign v751a1b = w1;
 v70cd06_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- Constante-32bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor gen√©rico constante, de 32 bits. Su valor se introduce como par√°metro. Por defecto vale 0
//---------------------------------------------------

module v70cd06_v465065 #(
 parameter VALUE = 0
) (
 output [31:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module v87abc9 (
 input v0e28cb,
 input v3ca442,
 input v132c67,
 input v814e6e,
 input vae8923,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 assign w3 = v132c67;
 assign w4 = v814e6e;
 assign w5 = vae8923;
 v87abc9_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .o(w2),
  .c(w3),
  .d(w4),
  .e(w5)
 );
endmodule

//---------------------------------------------------
//-- OR-4
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta OR de 4 entradas
//---------------------------------------------------

module v87abc9_vf4938a (
 input a,
 input b,
 input c,
 input d,
 input e,
 output o
);
 //-- Puerta OR
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign o = a | b | c | d | e;
 
 //-- endmodule
endmodule
//---- Top entity
module v604573 #(
 parameter v4fde05 = 'h0200_0008
) (
 input v34e785,
 input v866d25,
 input vb6935e,
 input [31:0] v9f8bfb,
 input vad40e9,
 input [31:0] v0fa3a4,
 input [3:0] vd996e9,
 output v2ab975,
 output [31:0] v62ea55,
 output vdc4800,
 output vf3ed26
);
 localparam p3 = v4fde05;
 wire w0;
 wire w1;
 wire w2;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire [0:31] w8;
 wire w9;
 wire [0:3] w10;
 wire [0:31] w11;
 wire [0:3] w12;
 wire w13;
 wire w14;
 wire w15;
 wire [0:31] w16;
 wire w17;
 wire [0:31] w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 assign v2ab975 = w1;
 assign v62ea55 = w8;
 assign vdc4800 = w9;
 assign w10 = vd996e9;
 assign w13 = v34e785;
 assign w14 = v866d25;
 assign w15 = vb6935e;
 assign w16 = v9f8bfb;
 assign w17 = vad40e9;
 assign w18 = v0fa3a4;
 assign vf3ed26 = w24;
 assign w20 = w19;
 assign w22 = w21;
 assign w23 = w21;
 assign w23 = w22;
 assign w24 = w21;
 assign w24 = w22;
 assign w24 = w23;
 v35f267 v793e13 (
  .vcbab45(w0),
  .v0e28cb(w2)
 );
 vb2090f v8b2549 (
  .v0e28cb(w0),
  .vcbab45(w9),
  .v3ca442(w23)
 );
 ve4ece1 vb9eeab (
  .va76a47(w1),
  .v3c7d9a(w2),
  .v10961b(w5),
  .vfeadd9(w7),
  .vb7609f(w8),
  .v20a2cd(w11),
  .v8e9021(w12),
  .v0dfcfa(w13),
  .v19f118(w14),
  .v13457e(w15),
  .v3674d3(w18)
 );
 vf9bdaf #(
  .v6b316b(p3)
 ) va6e100 (
  .v18e78c(w4),
  .ve1f562(w16)
 );
 vb2090f vc4db0b (
  .v0e28cb(w4),
  .v3ca442(w17),
  .vcbab45(w21)
 );
 vb2090f v43be95 (
  .vcbab45(w5),
  .v3ca442(w6),
  .v0e28cb(w21)
 );
 v35f267 v2e543c (
  .vcbab45(w6),
  .v0e28cb(w20)
 );
 vb2090f v7253fb (
  .vcbab45(w7),
  .v0e28cb(w19),
  .v3ca442(w22)
 );
 v45c913 v5623aa (
  .v930b03(w10),
  .v593f43(w19)
 );
 v2c97f6 v70047a (
  .v7c9bd8(w11)
 );
 v6a0d89 vf00bfe (
  .v919d0f(w12)
 );
endmodule

//---------------------------------------------------
//-- UART-soc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- UART con la l√≥gica de mapeo
//---------------------------------------------------
//---- Top entity
module vb2090f (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vb2090f_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND
//---------------------------------------------------

module vb2090f_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta AND
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a & b;
 
 //-- endmodule
endmodule
//---- Top entity
module ve4ece1 (
 input v0dfcfa,
 input v19f118,
 input v13457e,
 input [3:0] v8e9021,
 input vfeadd9,
 input v10961b,
 input [31:0] v3674d3,
 input [31:0] v20a2cd,
 output va76a47,
 output [31:0] vc35967,
 output [31:0] vb7609f,
 output v3c7d9a
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:3] w4;
 wire w5;
 wire w6;
 wire [0:31] w7;
 wire [0:31] w8;
 wire [0:31] w9;
 wire [0:31] w10;
 wire w11;
 assign va76a47 = w0;
 assign w1 = v13457e;
 assign w2 = v0dfcfa;
 assign w3 = v19f118;
 assign w4 = v8e9021;
 assign w5 = vfeadd9;
 assign w6 = v10961b;
 assign w7 = v3674d3;
 assign w8 = v20a2cd;
 assign vc35967 = w9;
 assign vb7609f = w10;
 assign v3c7d9a = w11;
 ve4ece1_v7323f5 v7323f5 (
  .ser_tx(w0),
  .ser_rx(w1),
  .clk(w2),
  .resetn(w3),
  .reg_div_we(w4),
  .reg_dat_we(w5),
  .reg_dat_re(w6),
  .reg_dat_di(w7),
  .reg_div_di(w8),
  .reg_div_do(w9),
  .reg_dat_do(w10),
  .reg_dat_wait(w11)
 );
endmodule

//---------------------------------------------------
//-- UART
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Uart para comunicaciones serie con el pico-riscv
//---------------------------------------------------

module ve4ece1_v7323f5 (
 input clk,
 input resetn,
 input ser_rx,
 input [3:0] reg_div_we,
 input reg_dat_we,
 input reg_dat_re,
 input [31:0] reg_dat_di,
 input [31:0] reg_div_di,
 output ser_tx,
 output [31:0] reg_div_do,
 output [31:0] reg_dat_do,
 output reg_dat_wait
);
 reg [31:0] cfg_divider=104;
 
 	reg [3:0] recv_state;
 	reg [31:0] recv_divcnt;
 	reg [7:0] recv_pattern;
 	reg [7:0] recv_buf_data;
 	reg recv_buf_valid;
 
 	reg [9:0] send_pattern;
 	reg [3:0] send_bitcnt;
 	reg [31:0] send_divcnt;
 	reg send_dummy;
 
 	assign reg_div_do = cfg_divider;
 
 	assign reg_dat_wait = reg_dat_we && (send_bitcnt || send_dummy);
 	assign reg_dat_do = recv_buf_valid ? recv_buf_data : ~0;
 /*
 	always @(posedge clk) begin
 		if (!resetn) begin
 			cfg_divider <= 1;
 		end else begin
 			if (reg_div_we[0]) cfg_divider[ 7: 0] <= reg_div_di[ 7: 0];
 			if (reg_div_we[1]) cfg_divider[15: 8] <= reg_div_di[15: 8];
 			if (reg_div_we[2]) cfg_divider[23:16] <= reg_div_di[23:16];
 			if (reg_div_we[3]) cfg_divider[31:24] <= reg_div_di[31:24];
 		end
 	end
 */
 	always @(posedge clk) begin
 		if (!resetn) begin
 			recv_state <= 0;
 			recv_divcnt <= 0;
 			recv_pattern <= 0;
 			recv_buf_data <= 0;
 			recv_buf_valid <= 0;
 		end else begin
 			recv_divcnt <= recv_divcnt + 1;
 			if (reg_dat_re)
 				recv_buf_valid <= 0;
 			case (recv_state)
 				0: begin
 					if (!ser_rx)
 						recv_state <= 1;
 					recv_divcnt <= 0;
 				end
 				1: begin
 					if (2*recv_divcnt > cfg_divider) begin
 						recv_state <= 2;
 						recv_divcnt <= 0;
 					end
 				end
 				10: begin
 					if (recv_divcnt > cfg_divider) begin
 						recv_buf_data <= recv_pattern;
 						recv_buf_valid <= 1;
 						recv_state <= 0;
 					end
 				end
 				default: begin
 					if (recv_divcnt > cfg_divider) begin
 						recv_pattern <= {ser_rx, recv_pattern[7:1]};
 						recv_state <= recv_state + 1;
 						recv_divcnt <= 0;
 					end
 				end
 			endcase
 		end
 	end
 
 	assign ser_tx = send_pattern[0];
 
 	always @(posedge clk) begin
 		if (reg_div_we)
 			send_dummy <= 1;
 		send_divcnt <= send_divcnt + 1;
 		if (!resetn) begin
 			send_pattern <= ~0;
 			send_bitcnt <= 0;
 			send_divcnt <= 0;
 			send_dummy <= 1;
 		end else begin
 			if (send_dummy && !send_bitcnt) begin
 				send_pattern <= ~0;
 				send_bitcnt <= 15;
 				send_divcnt <= 0;
 				send_dummy <= 0;
 			end else
 			if (reg_dat_we && !send_bitcnt) begin
 				send_pattern <= {1'b1, reg_dat_di[7:0], 1'b0};
 				send_bitcnt <= 10;
 				send_divcnt <= 0;
 			end else
 			if (send_divcnt > cfg_divider && send_bitcnt) begin
 				send_pattern <= {1'b1, send_pattern[9:1]};
 				send_bitcnt <= send_bitcnt - 1;
 				send_divcnt <= 0;
 			end
 		end
 	end
endmodule
//---- Top entity
module vf9bdaf #(
 parameter v6b316b = 0
) (
 input [31:0] ve1f562,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = ve1f562;
 vf9bdaf_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 32 bits. Se compara si el operando es igual al par√°metro
//---------------------------------------------------

module vf9bdaf_vd75681 #(
 parameter K = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a == K);
endmodule
//---- Top entity
module v45c913 (
 input [3:0] v930b03,
 output v5b73e8,
 output vc90115,
 output v2812a7,
 output v593f43
);
 wire [0:3] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign w0 = v930b03;
 assign v2812a7 = w1;
 assign v593f43 = w2;
 assign vc90115 = w3;
 assign v5b73e8 = w4;
 v45c913_v9a2a06 v9a2a06 (
  .i(w0),
  .o1(w1),
  .o0(w2),
  .o2(w3),
  .o3(w4)
 );
endmodule

//---------------------------------------------------
//-- Separador-bus
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 4-bits en 4 cables
//---------------------------------------------------

module v45c913_v9a2a06 (
 input [3:0] i,
 output o3,
 output o2,
 output o1,
 output o0
);
 assign o3 = i[3];
 assign o2 = i[2];
 assign o1 = i[1];
 assign o0 = i[0];
endmodule
//---- Top entity
module v2c97f6 #(
 parameter vfffc23 = 0
) (
 output [31:0] v7c9bd8
);
 localparam p0 = vfffc23;
 wire [0:31] w1;
 assign v7c9bd8 = w1;
 v959751 #(
  .vc5c8ea(p0)
 ) v9f49e7 (
  .vbc97e4(w1)
 );
endmodule

//---------------------------------------------------
//-- 32bits-Value_0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 32bits constant value: 0
//---------------------------------------------------
//---- Top entity
module v959751 #(
 parameter vc5c8ea = 0
) (
 output [31:0] vbc97e4
);
 localparam p0 = vc5c8ea;
 wire [0:31] w1;
 assign vbc97e4 = w1;
 v959751_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- 32-bits-gen-constant
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Generic: 32-bits generic constant
//---------------------------------------------------

module v959751_v465065 #(
 parameter VALUE = 0
) (
 output [31:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module v6a0d89 #(
 parameter vfffc23 = 0
) (
 output [3:0] v919d0f
);
 localparam p0 = vfffc23;
 wire [0:3] w1;
 assign v919d0f = w1;
 v9b9118 #(
  .vc5c8ea(p0)
 ) v76a485 (
  .v1ef182(w1)
 );
endmodule

//---------------------------------------------------
//-- 4bits-Value_0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 4bits constant value: 0
//---------------------------------------------------
//---- Top entity
module v9b9118 #(
 parameter vc5c8ea = 0
) (
 output [3:0] v1ef182
);
 localparam p0 = vc5c8ea;
 wire [0:3] w1;
 assign v1ef182 = w1;
 v9b9118_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- 4-bits-gen-constant
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Generic: 4-bits generic constant (0-15)
//---------------------------------------------------

module v9b9118_v465065 #(
 parameter VALUE = 0
) (
 output [3:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module vaad680 (
 input vba7c72,
 input v5d0f7b,
 input v9b0ff0,
 input [31:0] v8fd87d,
 input [31:0] v29fe33,
 output v006d37,
 output v88e319,
 output [31:0] vd67338,
 output [31:0] ve61aa7,
 output [3:0] v83dbbe
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire [0:31] w6;
 wire [0:31] w7;
 wire [0:31] w8;
 wire [0:31] w9;
 wire [0:3] w10;
 wire [0:31] w11;
 wire w12;
 wire [0:31] w13;
 wire [0:5] w14;
 wire [0:5] w15;
 wire [0:5] w16;
 wire [0:31] w17;
 assign w0 = vba7c72;
 assign w1 = vba7c72;
 assign v006d37 = w2;
 assign w3 = v5d0f7b;
 assign v88e319 = w4;
 assign w5 = v9b0ff0;
 assign vd67338 = w6;
 assign w7 = v8fd87d;
 assign ve61aa7 = w8;
 assign w9 = v29fe33;
 assign v83dbbe = w10;
 assign w1 = w0;
 vaad680_v3fb302 v3fb302 (
  .clk(w1),
  .rdata1(w11),
  .wen(w12),
  .rdata2(w13),
  .waddr(w14),
  .raddr1(w15),
  .raddr2(w16),
  .wdata(w17)
 );
 vaad680_vf1da6e vf1da6e (
  .clk(w0),
  .mem_valid(w2),
  .resetn(w3),
  .mem_instr(w4),
  .mem_ready(w5),
  .mem_addr(w6),
  .mem_rdata(w7),
  .mem_wdata(w8),
  .irq(w9),
  .mem_wstrb(w10),
  .cpuregs_rdata1(w11),
  .cpuregs_wen(w12),
  .cpuregs_rdata2(w13),
  .cpuregs_waddr(w14),
  .cpuregs_raddr1(w15),
  .cpuregs_raddr2(w16),
  .cpuregs_wrdata(w17)
 );
endmodule

//---------------------------------------------------
//-- RV32i
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Risc-v de 32Bits. Numeros enteros
//---------------------------------------------------

module vaad680_v3fb302 (
 input clk,
 input wen,
 input [5:0] waddr,
 input [5:0] raddr1,
 input [5:0] raddr2,
 input [31:0] wdata,
 output [31:0] rdata1,
 output [31:0] rdata2
);
 reg [31:0] regs [0:31];
 
 always @(posedge clk)
 	if (wen) regs[waddr[4:0]] <= wdata;
 
 assign rdata1 = regs[raddr1[4:0]];
 assign rdata2 = regs[raddr2[4:0]];
endmodule

module vaad680_vf1da6e (
 input clk,
 input resetn,
 input mem_ready,
 input [31:0] mem_rdata,
 input [31:0] irq,
 input [31:0] cpuregs_rdata1,
 input [31:0] cpuregs_rdata2,
 input pcpi_mul_wr,
 input [31:0] pcpi_mul_rd,
 input pcpi_mul_wait,
 input pcpi_mul_ready,
 input pcpi_div_wr,
 input [31:0] pcpi_div_rd,
 input pcpi_div_wait,
 input pcpi_div_ready,
 output mem_valid,
 output mem_instr,
 output [31:0] mem_addr,
 output [31:0] mem_wdata,
 output [3:0] mem_wstrb,
 output cpuregs_wen,
 output [5:0] cpuregs_waddr,
 output [5:0] cpuregs_raddr1,
 output [5:0] cpuregs_raddr2,
 output [31:0] cpuregs_wrdata,
 output pcpi_valid,
 output [31:0] pcpi_insn,
 output [31:0] pcpi_rs1,
 output [31:0] pcpi_rs2
);
 define PICORV32_REGS picosoc_regs
 
 
 parameter integer MEM_WORDS = 256;
 
 define PICORV32_V
 
 parameter [ 0:0] ENABLE_COUNTERS = 1;
 parameter [ 0:0] ENABLE_COUNTERS64 = 1;
 parameter [ 0:0] ENABLE_REGS_16_31 = 1;
 parameter [ 0:0] ENABLE_REGS_DUALPORT = 1;
 parameter [ 0:0] LATCHED_MEM_RDATA = 0;
 parameter [ 0:0] TWO_STAGE_SHIFT = 1;
 parameter [ 0:0] BARREL_SHIFTER = 1;
 parameter [ 0:0] TWO_CYCLE_COMPARE = 0;
 parameter [ 0:0] TWO_CYCLE_ALU = 0;
 parameter [ 0:0] COMPRESSED_ISA = 0;
 parameter [ 0:0] CATCH_MISALIGN = 1;
 parameter [ 0:0] CATCH_ILLINSN = 1;
 parameter [ 0:0] ENABLE_PCPI = 0;
 parameter [ 0:0] ENABLE_MUL = 0;
 parameter [ 0:0] ENABLE_FAST_MUL = 0;
 parameter [ 0:0] ENABLE_DIV = 0;
 parameter [ 0:0] ENABLE_IRQ = 1;
 parameter [ 0:0] ENABLE_IRQ_QREGS = 0;
 parameter [ 0:0] ENABLE_IRQ_TIMER = 1;
 parameter [ 0:0] ENABLE_TRACE = 0;
 parameter [ 0:0] REGS_INIT_ZERO = 0;
 parameter [31:0] MASKED_IRQ = 32'h 0000_0000;
 parameter [31:0] LATCHED_IRQ = 32'h ffff_ffff;
 parameter [31:0] PROGADDR_RESET = 32'h 0010_0000; // 1 MB into flash,
 parameter [31:0] PROGADDR_IRQ = 32'h 0000_0000;
 parameter [31:0] STACKADDR = (4*MEM_WORDS);       // end of memory
 
 
 reg mem_valid_i;
 assign mem_valid = mem_valid_i;
 reg mem_instr_i;
 assign mem_instr = mem_instr_i;
 reg [31:0] mem_addr_i;
 assign mem_addr = mem_addr_i;
 reg [31:0] mem_wdata_i;
 assign mem_wdata = mem_wdata_i;
 reg [ 3:0] mem_wstrb_i;
 assign mem_wstrb = mem_wstrb_i;
 reg [31:0] eoi;
 
 reg trap;
 
 
 // Pico Co-Processor Interface (PCPI)
 reg        pcpi_valid_i;
 assign pcpi_valid = pcpi_valid_i;
 reg [31:0] pcpi_insn_i;
 assign pcpi_insn = pcpi_insn_i;
 wire     pcpi_wr;
 wire [31:0] pcpi_rd;
 wire pcpi_wait;
 wire pcpi_ready;
 
 
 // Look-Ahead Interface
 wire            mem_la_read;
 wire            mem_la_write;
 wire     [31:0] mem_la_addr;
 reg [31:0] mem_la_wdata;
 reg [ 3:0] mem_la_wstrb;
 
 // Trace Interface
 reg        trace_valid;
 reg [35:0] trace_data;
 
 	localparam integer irq_timer = 0;
 	localparam integer irq_ebreak = 1;
 	localparam integer irq_buserror = 2;
 
 	localparam integer irqregs_offset = ENABLE_REGS_16_31 ? 32 : 16;
 	localparam integer regfile_size = (ENABLE_REGS_16_31 ? 32 : 16) + 4*ENABLE_IRQ*ENABLE_IRQ_QREGS;
 	localparam integer regindex_bits = (ENABLE_REGS_16_31 ? 5 : 4) + ENABLE_IRQ*ENABLE_IRQ_QREGS;
 
 	localparam WITH_PCPI = ENABLE_PCPI || ENABLE_MUL || ENABLE_FAST_MUL || ENABLE_DIV;
 
 	localparam [35:0] TRACE_BRANCH = {4'b 0001, 32'b 0};
 	localparam [35:0] TRACE_ADDR   = {4'b 0010, 32'b 0};
 	localparam [35:0] TRACE_IRQ    = {4'b 1000, 32'b 0};
 
 //-- A√±adido para instanciar los registros
 assign cpuregs_wen = resetn && cpuregs_write && latched_rd;
 
 //FORMAL_KEEP:
 reg [63:0] dbg_ascii_instr;
 reg [31:0] dbg_insn_imm;
 reg [4:0] dbg_insn_rs1;
 reg [4:0] dbg_insn_rs2;
 reg [4:0] dbg_insn_rd;
 reg [31:0] dbg_rs1val;
 reg [31:0] dbg_rs2val;
 reg dbg_rs1val_valid;
 reg dbg_rs2val_valid;
 reg [127:0] dbg_ascii_state;
 
 	reg [63:0] count_cycle, count_instr;
 	reg [31:0] reg_pc, reg_next_pc, reg_op1, reg_op2, reg_out;
 	reg [4:0] reg_sh;
 
 	reg [31:0] next_insn_opcode;
 	reg [31:0] dbg_insn_opcode;
 	reg [31:0] dbg_insn_addr;
 
 	wire dbg_mem_valid = mem_valid_i;
 	wire dbg_mem_instr = mem_instr_i;
 	wire dbg_mem_ready = mem_ready;
 	wire [31:0] dbg_mem_addr  = mem_addr_i;
 	wire [31:0] dbg_mem_wdata = mem_wdata_i;
 	wire [ 3:0] dbg_mem_wstrb = mem_wstrb_i;
 	wire [31:0] dbg_mem_rdata = mem_rdata;
 
 	assign pcpi_rs1 = reg_op1;
 	assign pcpi_rs2 = reg_op2;
 
 	wire [31:0] next_pc;
 
 	reg irq_delay;
 	reg irq_active;
 	reg [31:0] irq_mask;
 	reg [31:0] irq_pending;
 	reg [31:0] timer;
 
 ifndef PICORV32_REGS
 	reg [31:0] cpuregs [0:regfile_size-1];
 
 	integer i;
 	initial begin
 		if (REGS_INIT_ZERO) begin
 			for (i = 0; i < regfile_size; i = i+1)
 				cpuregs[i] = 0;
 		end
 	end
 endif
 
 	task empty_statement;
 		// This task is used by the assert directive in non-formal mode to
 		// avoid empty statement (which are unsupported by plain Verilog syntax).
 		begin end
 	endtask
 
 ifdef DEBUGREGS
 	wire [31:0] dbg_reg_x0  = 0;
 	wire [31:0] dbg_reg_x1  = cpuregs[1];
 	wire [31:0] dbg_reg_x2  = cpuregs[2];
 	wire [31:0] dbg_reg_x3  = cpuregs[3];
 	wire [31:0] dbg_reg_x4  = cpuregs[4];
 	wire [31:0] dbg_reg_x5  = cpuregs[5];
 	wire [31:0] dbg_reg_x6  = cpuregs[6];
 	wire [31:0] dbg_reg_x7  = cpuregs[7];
 	wire [31:0] dbg_reg_x8  = cpuregs[8];
 	wire [31:0] dbg_reg_x9  = cpuregs[9];
 	wire [31:0] dbg_reg_x10 = cpuregs[10];
 	wire [31:0] dbg_reg_x11 = cpuregs[11];
 	wire [31:0] dbg_reg_x12 = cpuregs[12];
 	wire [31:0] dbg_reg_x13 = cpuregs[13];
 	wire [31:0] dbg_reg_x14 = cpuregs[14];
 	wire [31:0] dbg_reg_x15 = cpuregs[15];
 	wire [31:0] dbg_reg_x16 = cpuregs[16];
 	wire [31:0] dbg_reg_x17 = cpuregs[17];
 	wire [31:0] dbg_reg_x18 = cpuregs[18];
 	wire [31:0] dbg_reg_x19 = cpuregs[19];
 	wire [31:0] dbg_reg_x20 = cpuregs[20];
 	wire [31:0] dbg_reg_x21 = cpuregs[21];
 	wire [31:0] dbg_reg_x22 = cpuregs[22];
 	wire [31:0] dbg_reg_x23 = cpuregs[23];
 	wire [31:0] dbg_reg_x24 = cpuregs[24];
 	wire [31:0] dbg_reg_x25 = cpuregs[25];
 	wire [31:0] dbg_reg_x26 = cpuregs[26];
 	wire [31:0] dbg_reg_x27 = cpuregs[27];
 	wire [31:0] dbg_reg_x28 = cpuregs[28];
 	wire [31:0] dbg_reg_x29 = cpuregs[29];
 	wire [31:0] dbg_reg_x30 = cpuregs[30];
 	wire [31:0] dbg_reg_x31 = cpuregs[31];
 endif
 
 	// Internal PCPI Cores
 
 	reg        pcpi_int_wr;
 	reg [31:0] pcpi_int_rd;
 	reg        pcpi_int_wait;
 	reg        pcpi_int_ready;
 
 	generate if (ENABLE_FAST_MUL) begin
 		picorv32_pcpi_fast_mul pcpi_mul (
 			.clk       (clk            ),
 			.resetn    (resetn         ),
 			.pcpi_valid(pcpi_valid_i     ),
 			.pcpi_insn (pcpi_insn_i      ),
 			.pcpi_rs1  (pcpi_rs1       ),
 			.pcpi_rs2  (pcpi_rs2       ),
 			.pcpi_wr   (pcpi_mul_wr    ),
 			.pcpi_rd   (pcpi_mul_rd    ),
 			.pcpi_wait (pcpi_mul_wait  ),
 			.pcpi_ready(pcpi_mul_ready )
 		);
 	end else if (ENABLE_MUL) begin
 		
 	end else begin
 		assign pcpi_mul_wr = 0;
 		assign pcpi_mul_rd = 32'bx;
 		assign pcpi_mul_wait = 0;
 		assign pcpi_mul_ready = 0;
 	end endgenerate
 
 	generate if (ENABLE_DIV) begin
 		
 	end else begin
 		assign pcpi_div_wr = 0;
 		assign pcpi_div_rd = 32'bx;
 		assign pcpi_div_wait = 0;
 		assign pcpi_div_ready = 0;
 	end endgenerate
 
 	always @* begin
 		pcpi_int_wr = 0;
 		pcpi_int_rd = 32'bx;
 		pcpi_int_wait  = |{ENABLE_PCPI && pcpi_wait,  (ENABLE_MUL || ENABLE_FAST_MUL) && pcpi_mul_wait,  ENABLE_DIV && pcpi_div_wait};
 		pcpi_int_ready = |{ENABLE_PCPI && pcpi_ready, (ENABLE_MUL || ENABLE_FAST_MUL) && pcpi_mul_ready, ENABLE_DIV && pcpi_div_ready};
 
 		(* parallel_case *)
 		case (1'b1)
 			ENABLE_PCPI && pcpi_ready: begin
 				pcpi_int_wr = ENABLE_PCPI ? pcpi_wr : 0;
 				pcpi_int_rd = ENABLE_PCPI ? pcpi_rd : 0;
 			end
 			(ENABLE_MUL || ENABLE_FAST_MUL) && pcpi_mul_ready: begin
 				pcpi_int_wr = pcpi_mul_wr;
 				pcpi_int_rd = pcpi_mul_rd;
 			end
 			ENABLE_DIV && pcpi_div_ready: begin
 				pcpi_int_wr = pcpi_div_wr;
 				pcpi_int_rd = pcpi_div_rd;
 			end
 		endcase
 	end
 
 
 	// Memory Interface
 
 	reg [1:0] mem_state;
 	reg [1:0] mem_wordsize;
 	reg [31:0] mem_rdata_word;
 	reg [31:0] mem_rdata_q;
 	reg mem_do_prefetch;
 	reg mem_do_rinst;
 	reg mem_do_rdata;
 	reg mem_do_wdata;
 
 	wire mem_xfer;
 	reg mem_la_secondword, mem_la_firstword_reg, last_mem_valid;
 	wire mem_la_firstword = COMPRESSED_ISA && (mem_do_prefetch || mem_do_rinst) && next_pc[1] && !mem_la_secondword;
 	wire mem_la_firstword_xfer = COMPRESSED_ISA && mem_xfer && (!last_mem_valid ? mem_la_firstword : mem_la_firstword_reg);
 
 	reg prefetched_high_word;
 	reg clear_prefetched_high_word;
 	reg [15:0] mem_16bit_buffer;
 
 	wire [31:0] mem_rdata_latched_noshuffle;
 	wire [31:0] mem_rdata_latched;
 
 	wire mem_la_use_prefetched_high_word = COMPRESSED_ISA && mem_la_firstword && prefetched_high_word && !clear_prefetched_high_word;
 	assign mem_xfer = (mem_valid_i && mem_ready) || (mem_la_use_prefetched_high_word && mem_do_rinst);
 
 	wire mem_busy = |{mem_do_prefetch, mem_do_rinst, mem_do_rdata, mem_do_wdata};
 	wire mem_done = resetn && ((mem_xfer && |mem_state && (mem_do_rinst || mem_do_rdata || mem_do_wdata)) || (&mem_state && mem_do_rinst)) &&
 			(!mem_la_firstword || (~&mem_rdata_latched[1:0] && mem_xfer));
 
 	assign mem_la_write = resetn && !mem_state && mem_do_wdata;
 	assign mem_la_read = resetn && ((!mem_la_use_prefetched_high_word && !mem_state && (mem_do_rinst || mem_do_prefetch || mem_do_rdata)) ||
 			(COMPRESSED_ISA && mem_xfer && (!last_mem_valid ? mem_la_firstword : mem_la_firstword_reg) && !mem_la_secondword && &mem_rdata_latched[1:0]));
 	assign mem_la_addr = (mem_do_prefetch || mem_do_rinst) ? {next_pc[31:2] + mem_la_firstword_xfer, 2'b00} : {reg_op1[31:2], 2'b00};
 
 	assign mem_rdata_latched_noshuffle = (mem_xfer || LATCHED_MEM_RDATA) ? mem_rdata : mem_rdata_q;
 
 	assign mem_rdata_latched = COMPRESSED_ISA && mem_la_use_prefetched_high_word ? {16'bx, mem_16bit_buffer} :
 			COMPRESSED_ISA && mem_la_secondword ? {mem_rdata_latched_noshuffle[15:0], mem_16bit_buffer} :
 			COMPRESSED_ISA && mem_la_firstword ? {16'bx, mem_rdata_latched_noshuffle[31:16]} : mem_rdata_latched_noshuffle;
 
 	always @(posedge clk) begin
 		if (!resetn) begin
 			mem_la_firstword_reg <= 0;
 			last_mem_valid <= 0;
 		end else begin
 			if (!last_mem_valid)
 				mem_la_firstword_reg <= mem_la_firstword;
 			last_mem_valid <= mem_valid_i && !mem_ready;
 		end
 	end
 
 	always @* begin
 		(* full_case *)
 		case (mem_wordsize)
 			0: begin
 				mem_la_wdata = reg_op2;
 				mem_la_wstrb = 4'b1111;
 				mem_rdata_word = mem_rdata;
 			end
 			1: begin
 				mem_la_wdata = {2{reg_op2[15:0]}};
 				mem_la_wstrb = reg_op1[1] ? 4'b1100 : 4'b0011;
 				case (reg_op1[1])
 					1'b0: mem_rdata_word = {16'b0, mem_rdata[15: 0]};
 					1'b1: mem_rdata_word = {16'b0, mem_rdata[31:16]};
 				endcase
 			end
 			2: begin
 				mem_la_wdata = {4{reg_op2[7:0]}};
 				mem_la_wstrb = 4'b0001 << reg_op1[1:0];
 				case (reg_op1[1:0])
 					2'b00: mem_rdata_word = {24'b0, mem_rdata[ 7: 0]};
 					2'b01: mem_rdata_word = {24'b0, mem_rdata[15: 8]};
 					2'b10: mem_rdata_word = {24'b0, mem_rdata[23:16]};
 					2'b11: mem_rdata_word = {24'b0, mem_rdata[31:24]};
 				endcase
 			end
 		endcase
 	end
 
 	always @(posedge clk) begin
 		if (mem_xfer) begin
 			mem_rdata_q <= COMPRESSED_ISA ? mem_rdata_latched : mem_rdata;
 			next_insn_opcode <= COMPRESSED_ISA ? mem_rdata_latched : mem_rdata;
 		end
 
 		if (COMPRESSED_ISA && mem_done && (mem_do_prefetch || mem_do_rinst)) begin
 			case (mem_rdata_latched[1:0])
 				2'b00: begin // Quadrant 0
 					case (mem_rdata_latched[15:13])
 						3'b000: begin // C.ADDI4SPN
 							mem_rdata_q[14:12] <= 3'b000;
 							mem_rdata_q[31:20] <= {2'b0, mem_rdata_latched[10:7], mem_rdata_latched[12:11], mem_rdata_latched[5], mem_rdata_latched[6], 2'b00};
 						end
 						3'b010: begin // C.LW
 							mem_rdata_q[31:20] <= {5'b0, mem_rdata_latched[5], mem_rdata_latched[12:10], mem_rdata_latched[6], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 						3'b 110: begin // C.SW
 							{mem_rdata_q[31:25], mem_rdata_q[11:7]} <= {5'b0, mem_rdata_latched[5], mem_rdata_latched[12:10], mem_rdata_latched[6], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 					endcase
 				end
 				2'b01: begin // Quadrant 1
 					case (mem_rdata_latched[15:13])
 						3'b 000: begin // C.ADDI
 							mem_rdata_q[14:12] <= 3'b000;
 							mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 						end
 						3'b 010: begin // C.LI
 							mem_rdata_q[14:12] <= 3'b000;
 							mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 						end
 						3'b 011: begin
 							if (mem_rdata_latched[11:7] == 2) begin // C.ADDI16SP
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[4:3],
 										mem_rdata_latched[5], mem_rdata_latched[2], mem_rdata_latched[6], 4'b 0000});
 							end else begin // C.LUI
 								mem_rdata_q[31:12] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 							end
 						end
 						3'b100: begin
 							if (mem_rdata_latched[11:10] == 2'b00) begin // C.SRLI
 								mem_rdata_q[31:25] <= 7'b0000000;
 								mem_rdata_q[14:12] <= 3'b 101;
 							end
 							if (mem_rdata_latched[11:10] == 2'b01) begin // C.SRAI
 								mem_rdata_q[31:25] <= 7'b0100000;
 								mem_rdata_q[14:12] <= 3'b 101;
 							end
 							if (mem_rdata_latched[11:10] == 2'b10) begin // C.ANDI
 								mem_rdata_q[14:12] <= 3'b111;
 								mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 							end
 							if (mem_rdata_latched[12:10] == 3'b011) begin // C.SUB, C.XOR, C.OR, C.AND
 								if (mem_rdata_latched[6:5] == 2'b00) mem_rdata_q[14:12] <= 3'b000;
 								if (mem_rdata_latched[6:5] == 2'b01) mem_rdata_q[14:12] <= 3'b100;
 								if (mem_rdata_latched[6:5] == 2'b10) mem_rdata_q[14:12] <= 3'b110;
 								if (mem_rdata_latched[6:5] == 2'b11) mem_rdata_q[14:12] <= 3'b111;
 								mem_rdata_q[31:25] <= mem_rdata_latched[6:5] == 2'b00 ? 7'b0100000 : 7'b0000000;
 							end
 						end
 						3'b 110: begin // C.BEQZ
 							mem_rdata_q[14:12] <= 3'b000;
 							{ mem_rdata_q[31], mem_rdata_q[7], mem_rdata_q[30:25], mem_rdata_q[11:8] } <=
 									$signed({mem_rdata_latched[12], mem_rdata_latched[6:5], mem_rdata_latched[2],
 											mem_rdata_latched[11:10], mem_rdata_latched[4:3]});
 						end
 						3'b 111: begin // C.BNEZ
 							mem_rdata_q[14:12] <= 3'b001;
 							{ mem_rdata_q[31], mem_rdata_q[7], mem_rdata_q[30:25], mem_rdata_q[11:8] } <=
 									$signed({mem_rdata_latched[12], mem_rdata_latched[6:5], mem_rdata_latched[2],
 											mem_rdata_latched[11:10], mem_rdata_latched[4:3]});
 						end
 					endcase
 				end
 				2'b10: begin // Quadrant 2
 					case (mem_rdata_latched[15:13])
 						3'b000: begin // C.SLLI
 							mem_rdata_q[31:25] <= 7'b0000000;
 							mem_rdata_q[14:12] <= 3'b 001;
 						end
 						3'b010: begin // C.LWSP
 							mem_rdata_q[31:20] <= {4'b0, mem_rdata_latched[3:2], mem_rdata_latched[12], mem_rdata_latched[6:4], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 						3'b100: begin
 							if (mem_rdata_latched[12] == 0 && mem_rdata_latched[6:2] == 0) begin // C.JR
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:20] <= 12'b0;
 							end
 							if (mem_rdata_latched[12] == 0 && mem_rdata_latched[6:2] != 0) begin // C.MV
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:25] <= 7'b0000000;
 							end
 							if (mem_rdata_latched[12] != 0 && mem_rdata_latched[11:7] != 0 && mem_rdata_latched[6:2] == 0) begin // C.JALR
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:20] <= 12'b0;
 							end
 							if (mem_rdata_latched[12] != 0 && mem_rdata_latched[6:2] != 0) begin // C.ADD
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:25] <= 7'b0000000;
 							end
 						end
 						3'b110: begin // C.SWSP
 							{mem_rdata_q[31:25], mem_rdata_q[11:7]} <= {4'b0, mem_rdata_latched[8:7], mem_rdata_latched[12:9], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 					endcase
 				end
 			endcase
 		end
 	end
 /*
 	always @(posedge clk) begin
 		if (resetn && !trap) begin
 			if (mem_do_prefetch || mem_do_rinst || mem_do_rdata)
 				//assert(!mem_do_wdata);
 
 			if (mem_do_prefetch || mem_do_rinst)
 				//assert(!mem_do_rdata);
 
 			if (mem_do_rdata)
 				//assert(!mem_do_prefetch && !mem_do_rinst);
 
 			if (mem_do_wdata)
 				//assert(!(mem_do_prefetch || mem_do_rinst || mem_do_rdata));
 
 			if (mem_state == 2 || mem_state == 3)
 				//assert(mem_valid || mem_do_prefetch);
 		end
 	end*/
 
 	always @(posedge clk) begin
 		if (!resetn || trap) begin
 			if (!resetn)
 				mem_state <= 0;
 			if (!resetn || mem_ready)
 				mem_valid_i <= 0;
 			mem_la_secondword <= 0;
 			prefetched_high_word <= 0;
 		end else begin
 			if (mem_la_read || mem_la_write) begin
 				mem_addr_i <= mem_la_addr;
 				mem_wstrb_i <= mem_la_wstrb & {4{mem_la_write}};
 			end
 			if (mem_la_write) begin
 				mem_wdata_i <= mem_la_wdata;
 			end
 			case (mem_state)
 				0: begin
 					if (mem_do_prefetch || mem_do_rinst || mem_do_rdata) begin
 						mem_valid_i <= !mem_la_use_prefetched_high_word;
 						mem_instr_i <= mem_do_prefetch || mem_do_rinst;
 						mem_wstrb_i <= 0;
 						mem_state <= 1;
 					end
 					if (mem_do_wdata) begin
 						mem_valid_i <= 1;
 						mem_instr_i <= 0;
 						mem_state <= 2;
 					end
 				end
 				1: begin
 					//assert(mem_wstrb == 0);
 					//assert(mem_do_prefetch || mem_do_rinst || mem_do_rdata);
 					//assert(mem_valid == !mem_la_use_prefetched_high_word);
 					//assert(mem_instr == (mem_do_prefetch || mem_do_rinst));
 					if (mem_xfer) begin
 						if (COMPRESSED_ISA && mem_la_read) begin
 							mem_valid_i <= 1;
 							mem_la_secondword <= 1;
 							if (!mem_la_use_prefetched_high_word)
 								mem_16bit_buffer <= mem_rdata[31:16];
 						end else begin
 							mem_valid_i <= 0;
 							mem_la_secondword <= 0;
 							if (COMPRESSED_ISA && !mem_do_rdata) begin
 								if (~&mem_rdata[1:0] || mem_la_secondword) begin
 									mem_16bit_buffer <= mem_rdata[31:16];
 									prefetched_high_word <= 1;
 								end else begin
 									prefetched_high_word <= 0;
 								end
 							end
 							mem_state <= mem_do_rinst || mem_do_rdata ? 0 : 3;
 						end
 					end
 				end
 				2: begin
 					//assert(mem_wstrb != 0);
 					//assert(mem_do_wdata);
 					if (mem_xfer) begin
 						mem_valid_i <= 0;
 						mem_state <= 0;
 					end
 				end
 				3: begin
 					//assert(mem_wstrb == 0);
 					//assert(mem_do_prefetch);
 					if (mem_do_rinst) begin
 						mem_state <= 0;
 					end
 				end
 			endcase
 		end
 
 		if (clear_prefetched_high_word)
 			prefetched_high_word <= 0;
 	end
 
 
 	// Instruction Decoder
 
 	reg instr_lui, instr_auipc, instr_jal, instr_jalr;
 	reg instr_beq, instr_bne, instr_blt, instr_bge, instr_bltu, instr_bgeu;
 	reg instr_lb, instr_lh, instr_lw, instr_lbu, instr_lhu, instr_sb, instr_sh, instr_sw;
 	reg instr_addi, instr_slti, instr_sltiu, instr_xori, instr_ori, instr_andi, instr_slli, instr_srli, instr_srai;
 	reg instr_add, instr_sub, instr_sll, instr_slt, instr_sltu, instr_xor, instr_srl, instr_sra, instr_or, instr_and;
 	reg instr_rdcycle, instr_rdcycleh, instr_rdinstr, instr_rdinstrh, instr_ecall_ebreak;
 	reg instr_getq, instr_setq, instr_retirq, instr_maskirq, instr_waitirq, instr_timer;
 	wire instr_trap;
 
 	reg [regindex_bits-1:0] decoded_rd, decoded_rs1, decoded_rs2;
 	reg [31:0] decoded_imm, decoded_imm_uj;
 	reg decoder_trigger;
 	reg decoder_trigger_q;
 	reg decoder_pseudo_trigger;
 	reg decoder_pseudo_trigger_q;
 	reg compressed_instr;
 
 	reg is_lui_auipc_jal;
 	reg is_lb_lh_lw_lbu_lhu;
 	reg is_slli_srli_srai;
 	reg is_jalr_addi_slti_sltiu_xori_ori_andi;
 	reg is_sb_sh_sw;
 	reg is_sll_srl_sra;
 	reg is_lui_auipc_jal_jalr_addi_add_sub;
 	reg is_slti_blt_slt;
 	reg is_sltiu_bltu_sltu;
 	reg is_beq_bne_blt_bge_bltu_bgeu;
 	reg is_lbu_lhu_lw;
 	reg is_alu_reg_imm;
 	reg is_alu_reg_reg;
 	reg is_compare;
 
 	assign instr_trap = (CATCH_ILLINSN || WITH_PCPI) && !{instr_lui, instr_auipc, instr_jal, instr_jalr,
 			instr_beq, instr_bne, instr_blt, instr_bge, instr_bltu, instr_bgeu,
 			instr_lb, instr_lh, instr_lw, instr_lbu, instr_lhu, instr_sb, instr_sh, instr_sw,
 			instr_addi, instr_slti, instr_sltiu, instr_xori, instr_ori, instr_andi, instr_slli, instr_srli, instr_srai,
 			instr_add, instr_sub, instr_sll, instr_slt, instr_sltu, instr_xor, instr_srl, instr_sra, instr_or, instr_and,
 			instr_rdcycle, instr_rdcycleh, instr_rdinstr, instr_rdinstrh,
 			instr_getq, instr_setq, instr_retirq, instr_maskirq, instr_waitirq, instr_timer};
 
 	wire is_rdcycle_rdcycleh_rdinstr_rdinstrh;
 	assign is_rdcycle_rdcycleh_rdinstr_rdinstrh = |{instr_rdcycle, instr_rdcycleh, instr_rdinstr, instr_rdinstrh};
 
 	reg [63:0] new_ascii_instr;
 	/*
 	FORMAL_KEEP reg [63:0] dbg_ascii_instr;
 	FORMAL_KEEP reg [31:0] dbg_insn_imm;
 	FORMAL_KEEP reg [4:0] dbg_insn_rs1;
 	FORMAL_KEEP reg [4:0] dbg_insn_rs2;
 	FORMAL_KEEP reg [4:0] dbg_insn_rd;
 	FORMAL_KEEP reg [31:0] dbg_rs1val;
 	FORMAL_KEEP reg [31:0] dbg_rs2val;
 	FORMAL_KEEP reg dbg_rs1val_valid;
 	FORMAL_KEEP reg dbg_rs2val_valid;*/
 
 	always @* begin
 		new_ascii_instr = "";
 
 		if (instr_lui)      new_ascii_instr = "lui";
 		if (instr_auipc)    new_ascii_instr = "auipc";
 		if (instr_jal)      new_ascii_instr = "jal";
 		if (instr_jalr)     new_ascii_instr = "jalr";
 
 		if (instr_beq)      new_ascii_instr = "beq";
 		if (instr_bne)      new_ascii_instr = "bne";
 		if (instr_blt)      new_ascii_instr = "blt";
 		if (instr_bge)      new_ascii_instr = "bge";
 		if (instr_bltu)     new_ascii_instr = "bltu";
 		if (instr_bgeu)     new_ascii_instr = "bgeu";
 
 		if (instr_lb)       new_ascii_instr = "lb";
 		if (instr_lh)       new_ascii_instr = "lh";
 		if (instr_lw)       new_ascii_instr = "lw";
 		if (instr_lbu)      new_ascii_instr = "lbu";
 		if (instr_lhu)      new_ascii_instr = "lhu";
 		if (instr_sb)       new_ascii_instr = "sb";
 		if (instr_sh)       new_ascii_instr = "sh";
 		if (instr_sw)       new_ascii_instr = "sw";
 
 		if (instr_addi)     new_ascii_instr = "addi";
 		if (instr_slti)     new_ascii_instr = "slti";
 		if (instr_sltiu)    new_ascii_instr = "sltiu";
 		if (instr_xori)     new_ascii_instr = "xori";
 		if (instr_ori)      new_ascii_instr = "ori";
 		if (instr_andi)     new_ascii_instr = "andi";
 		if (instr_slli)     new_ascii_instr = "slli";
 		if (instr_srli)     new_ascii_instr = "srli";
 		if (instr_srai)     new_ascii_instr = "srai";
 
 		if (instr_add)      new_ascii_instr = "add";
 		if (instr_sub)      new_ascii_instr = "sub";
 		if (instr_sll)      new_ascii_instr = "sll";
 		if (instr_slt)      new_ascii_instr = "slt";
 		if (instr_sltu)     new_ascii_instr = "sltu";
 		if (instr_xor)      new_ascii_instr = "xor";
 		if (instr_srl)      new_ascii_instr = "srl";
 		if (instr_sra)      new_ascii_instr = "sra";
 		if (instr_or)       new_ascii_instr = "or";
 		if (instr_and)      new_ascii_instr = "and";
 
 		if (instr_rdcycle)  new_ascii_instr = "rdcycle";
 		if (instr_rdcycleh) new_ascii_instr = "rdcycleh";
 		if (instr_rdinstr)  new_ascii_instr = "rdinstr";
 		if (instr_rdinstrh) new_ascii_instr = "rdinstrh";
 
 		if (instr_getq)     new_ascii_instr = "getq";
 		if (instr_setq)     new_ascii_instr = "setq";
 		if (instr_retirq)   new_ascii_instr = "retirq";
 		if (instr_maskirq)  new_ascii_instr = "maskirq";
 		if (instr_waitirq)  new_ascii_instr = "waitirq";
 		if (instr_timer)    new_ascii_instr = "timer";
 	end
 
 	reg [63:0] q_ascii_instr;
 	reg [31:0] q_insn_imm;
 	reg [31:0] q_insn_opcode;
 	reg [4:0] q_insn_rs1;
 	reg [4:0] q_insn_rs2;
 	reg [4:0] q_insn_rd;
 	reg dbg_next;
 
 	wire launch_next_insn;
 	reg dbg_valid_insn;
 
 	reg [63:0] cached_ascii_instr;
 	reg [31:0] cached_insn_imm;
 	reg [31:0] cached_insn_opcode;
 	reg [4:0] cached_insn_rs1;
 	reg [4:0] cached_insn_rs2;
 	reg [4:0] cached_insn_rd;
 
 	always @(posedge clk) begin
 		q_ascii_instr <= dbg_ascii_instr;
 		q_insn_imm <= dbg_insn_imm;
 		q_insn_opcode <= dbg_insn_opcode;
 		q_insn_rs1 <= dbg_insn_rs1;
 		q_insn_rs2 <= dbg_insn_rs2;
 		q_insn_rd <= dbg_insn_rd;
 		dbg_next <= launch_next_insn;
 
 		if (!resetn || trap)
 			dbg_valid_insn <= 0;
 		else if (launch_next_insn)
 			dbg_valid_insn <= 1;
 
 		if (decoder_trigger_q) begin
 			cached_ascii_instr <= new_ascii_instr;
 			cached_insn_imm <= decoded_imm;
 			if (&next_insn_opcode[1:0])
 				cached_insn_opcode <= next_insn_opcode;
 			else
 				cached_insn_opcode <= {16'b0, next_insn_opcode[15:0]};
 			cached_insn_rs1 <= decoded_rs1;
 			cached_insn_rs2 <= decoded_rs2;
 			cached_insn_rd <= decoded_rd;
 		end
 
 		if (launch_next_insn) begin
 			dbg_insn_addr <= next_pc;
 		end
 	end
 
 	always @* begin
 		dbg_ascii_instr = q_ascii_instr;
 		dbg_insn_imm = q_insn_imm;
 		dbg_insn_opcode = q_insn_opcode;
 		dbg_insn_rs1 = q_insn_rs1;
 		dbg_insn_rs2 = q_insn_rs2;
 		dbg_insn_rd = q_insn_rd;
 
 		if (dbg_next) begin
 			if (decoder_pseudo_trigger_q) begin
 				dbg_ascii_instr = cached_ascii_instr;
 				dbg_insn_imm = cached_insn_imm;
 				dbg_insn_opcode = cached_insn_opcode;
 				dbg_insn_rs1 = cached_insn_rs1;
 				dbg_insn_rs2 = cached_insn_rs2;
 				dbg_insn_rd = cached_insn_rd;
 			end else begin
 				dbg_ascii_instr = new_ascii_instr;
 				if (&next_insn_opcode[1:0])
 					dbg_insn_opcode = next_insn_opcode;
 				else
 					dbg_insn_opcode = {16'b0, next_insn_opcode[15:0]};
 				dbg_insn_imm = decoded_imm;
 				dbg_insn_rs1 = decoded_rs1;
 				dbg_insn_rs2 = decoded_rs2;
 				dbg_insn_rd = decoded_rd;
 			end
 		end
 	end
 
 ifdef DEBUGASM
 	always @(posedge clk) begin
 		if (dbg_next) begin
 			$display("debugasm %x %x %s", dbg_insn_addr, dbg_insn_opcode, dbg_ascii_instr ? dbg_ascii_instr : "*");
 		end
 	end
 endif
 
 ifdef DEBUG
 	always @(posedge clk) begin
 		if (dbg_next) begin
 			if (&dbg_insn_opcode[1:0])
 				$display("DECODE: 0x%08x 0x%08x %-0s", dbg_insn_addr, dbg_insn_opcode, dbg_ascii_instr ? dbg_ascii_instr : "UNKNOWN");
 			else
 				$display("DECODE: 0x%08x     0x%04x %-0s", dbg_insn_addr, dbg_insn_opcode[15:0], dbg_ascii_instr ? dbg_ascii_instr : "UNKNOWN");
 		end
 	end
 endif
 
 	always @(posedge clk) begin
 		is_lui_auipc_jal <= |{instr_lui, instr_auipc, instr_jal};
 		is_lui_auipc_jal_jalr_addi_add_sub <= |{instr_lui, instr_auipc, instr_jal, instr_jalr, instr_addi, instr_add, instr_sub};
 		is_slti_blt_slt <= |{instr_slti, instr_blt, instr_slt};
 		is_sltiu_bltu_sltu <= |{instr_sltiu, instr_bltu, instr_sltu};
 		is_lbu_lhu_lw <= |{instr_lbu, instr_lhu, instr_lw};
 		is_compare <= |{is_beq_bne_blt_bge_bltu_bgeu, instr_slti, instr_slt, instr_sltiu, instr_sltu};
 
 		if (mem_do_rinst && mem_done) begin
 			instr_lui     <= mem_rdata_latched[6:0] == 7'b0110111;
 			instr_auipc   <= mem_rdata_latched[6:0] == 7'b0010111;
 			instr_jal     <= mem_rdata_latched[6:0] == 7'b1101111;
 			instr_jalr    <= mem_rdata_latched[6:0] == 7'b1100111 && mem_rdata_latched[14:12] == 3'b000;
 			instr_retirq  <= mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000010 && ENABLE_IRQ;
 			instr_waitirq <= mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000100 && ENABLE_IRQ;
 
 			is_beq_bne_blt_bge_bltu_bgeu <= mem_rdata_latched[6:0] == 7'b1100011;
 			is_lb_lh_lw_lbu_lhu          <= mem_rdata_latched[6:0] == 7'b0000011;
 			is_sb_sh_sw                  <= mem_rdata_latched[6:0] == 7'b0100011;
 			is_alu_reg_imm               <= mem_rdata_latched[6:0] == 7'b0010011;
 			is_alu_reg_reg               <= mem_rdata_latched[6:0] == 7'b0110011;
 
 			{ decoded_imm_uj[31:20], decoded_imm_uj[10:1], decoded_imm_uj[11], decoded_imm_uj[19:12], decoded_imm_uj[0] } <= $signed({mem_rdata_latched[31:12], 1'b0});
 
 			decoded_rd <= mem_rdata_latched[11:7];
 			decoded_rs1 <= mem_rdata_latched[19:15];
 			decoded_rs2 <= mem_rdata_latched[24:20];
 
 			if (mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000000 && ENABLE_IRQ && ENABLE_IRQ_QREGS)
 				decoded_rs1[regindex_bits-1] <= 1; // instr_getq
 
 			if (mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000010 && ENABLE_IRQ)
 				decoded_rs1 <= ENABLE_IRQ_QREGS ? irqregs_offset : 3; // instr_retirq
 
 			compressed_instr <= 0;
 			if (COMPRESSED_ISA && mem_rdata_latched[1:0] != 2'b11) begin
 				compressed_instr <= 1;
 				decoded_rd <= 0;
 				decoded_rs1 <= 0;
 				decoded_rs2 <= 0;
 
 				{ decoded_imm_uj[31:11], decoded_imm_uj[4], decoded_imm_uj[9:8], decoded_imm_uj[10], decoded_imm_uj[6],
 				  decoded_imm_uj[7], decoded_imm_uj[3:1], decoded_imm_uj[5], decoded_imm_uj[0] } <= $signed({mem_rdata_latched[12:2], 1'b0});
 
 				case (mem_rdata_latched[1:0])
 					2'b00: begin // Quadrant 0
 						case (mem_rdata_latched[15:13])
 							3'b000: begin // C.ADDI4SPN
 								is_alu_reg_imm <= |mem_rdata_latched[12:5];
 								decoded_rs1 <= 2;
 								decoded_rd <= 8 + mem_rdata_latched[4:2];
 							end
 							3'b010: begin // C.LW
 								is_lb_lh_lw_lbu_lhu <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rd <= 8 + mem_rdata_latched[4:2];
 							end
 							3'b110: begin // C.SW
 								is_sb_sh_sw <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rs2 <= 8 + mem_rdata_latched[4:2];
 							end
 						endcase
 					end
 					2'b01: begin // Quadrant 1
 						case (mem_rdata_latched[15:13])
 							3'b000: begin // C.NOP / C.ADDI
 								is_alu_reg_imm <= 1;
 								decoded_rd <= mem_rdata_latched[11:7];
 								decoded_rs1 <= mem_rdata_latched[11:7];
 							end
 							3'b001: begin // C.JAL
 								instr_jal <= 1;
 								decoded_rd <= 1;
 							end
 							3'b 010: begin // C.LI
 								is_alu_reg_imm <= 1;
 								decoded_rd <= mem_rdata_latched[11:7];
 								decoded_rs1 <= 0;
 							end
 							3'b 011: begin
 								if (mem_rdata_latched[12] || mem_rdata_latched[6:2]) begin
 									if (mem_rdata_latched[11:7] == 2) begin // C.ADDI16SP
 										is_alu_reg_imm <= 1;
 										decoded_rd <= mem_rdata_latched[11:7];
 										decoded_rs1 <= mem_rdata_latched[11:7];
 									end else begin // C.LUI
 										instr_lui <= 1;
 										decoded_rd <= mem_rdata_latched[11:7];
 										decoded_rs1 <= 0;
 									end
 								end
 							end
 							3'b100: begin
 								if (!mem_rdata_latched[11] && !mem_rdata_latched[12]) begin // C.SRLI, C.SRAI
 									is_alu_reg_imm <= 1;
 									decoded_rd <= 8 + mem_rdata_latched[9:7];
 									decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 									decoded_rs2 <= {mem_rdata_latched[12], mem_rdata_latched[6:2]};
 								end
 								if (mem_rdata_latched[11:10] == 2'b10) begin // C.ANDI
 									is_alu_reg_imm <= 1;
 									decoded_rd <= 8 + mem_rdata_latched[9:7];
 									decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								end
 								if (mem_rdata_latched[12:10] == 3'b011) begin // C.SUB, C.XOR, C.OR, C.AND
 									is_alu_reg_reg <= 1;
 									decoded_rd <= 8 + mem_rdata_latched[9:7];
 									decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 									decoded_rs2 <= 8 + mem_rdata_latched[4:2];
 								end
 							end
 							3'b101: begin // C.J
 								instr_jal <= 1;
 							end
 							3'b110: begin // C.BEQZ
 								is_beq_bne_blt_bge_bltu_bgeu <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rs2 <= 0;
 							end
 							3'b111: begin // C.BNEZ
 								is_beq_bne_blt_bge_bltu_bgeu <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rs2 <= 0;
 							end
 						endcase
 					end
 					2'b10: begin // Quadrant 2
 						case (mem_rdata_latched[15:13])
 							3'b000: begin // C.SLLI
 								if (!mem_rdata_latched[12]) begin
 									is_alu_reg_imm <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= mem_rdata_latched[11:7];
 									decoded_rs2 <= {mem_rdata_latched[12], mem_rdata_latched[6:2]};
 								end
 							end
 							3'b010: begin // C.LWSP
 								if (mem_rdata_latched[11:7]) begin
 									is_lb_lh_lw_lbu_lhu <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= 2;
 								end
 							end
 							3'b100: begin
 								if (mem_rdata_latched[12] == 0 && mem_rdata_latched[11:7] != 0 && mem_rdata_latched[6:2] == 0) begin // C.JR
 									instr_jalr <= 1;
 									decoded_rd <= 0;
 									decoded_rs1 <= mem_rdata_latched[11:7];
 								end
 								if (mem_rdata_latched[12] == 0 && mem_rdata_latched[6:2] != 0) begin // C.MV
 									is_alu_reg_reg <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= 0;
 									decoded_rs2 <= mem_rdata_latched[6:2];
 								end
 								if (mem_rdata_latched[12] != 0 && mem_rdata_latched[11:7] != 0 && mem_rdata_latched[6:2] == 0) begin // C.JALR
 									instr_jalr <= 1;
 									decoded_rd <= 1;
 									decoded_rs1 <= mem_rdata_latched[11:7];
 								end
 								if (mem_rdata_latched[12] != 0 && mem_rdata_latched[6:2] != 0) begin // C.ADD
 									is_alu_reg_reg <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= mem_rdata_latched[11:7];
 									decoded_rs2 <= mem_rdata_latched[6:2];
 								end
 							end
 							3'b110: begin // C.SWSP
 								is_sb_sh_sw <= 1;
 								decoded_rs1 <= 2;
 								decoded_rs2 <= mem_rdata_latched[6:2];
 							end
 						endcase
 					end
 				endcase
 			end
 		end
 
 		if (decoder_trigger && !decoder_pseudo_trigger) begin
 			pcpi_insn_i <= WITH_PCPI ? mem_rdata_q : 'bx;
 
 			instr_beq   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b000;
 			instr_bne   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b001;
 			instr_blt   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b100;
 			instr_bge   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b101;
 			instr_bltu  <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b110;
 			instr_bgeu  <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b111;
 
 			instr_lb    <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b000;
 			instr_lh    <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b001;
 			instr_lw    <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b010;
 			instr_lbu   <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b100;
 			instr_lhu   <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b101;
 
 			instr_sb    <= is_sb_sh_sw && mem_rdata_q[14:12] == 3'b000;
 			instr_sh    <= is_sb_sh_sw && mem_rdata_q[14:12] == 3'b001;
 			instr_sw    <= is_sb_sh_sw && mem_rdata_q[14:12] == 3'b010;
 
 			instr_addi  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b000;
 			instr_slti  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b010;
 			instr_sltiu <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b011;
 			instr_xori  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b100;
 			instr_ori   <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b110;
 			instr_andi  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b111;
 
 			instr_slli  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_srli  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_srai  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000;
 
 			instr_add   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b000 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_sub   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b000 && mem_rdata_q[31:25] == 7'b0100000;
 			instr_sll   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_slt   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b010 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_sltu  <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b011 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_xor   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b100 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_srl   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_sra   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000;
 			instr_or    <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b110 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_and   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b111 && mem_rdata_q[31:25] == 7'b0000000;
 
 			instr_rdcycle  <= ((mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11000000000000000010) ||
 			                   (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11000000000100000010)) && ENABLE_COUNTERS;
 			instr_rdcycleh <= ((mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11001000000000000010) ||
 			                   (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11001000000100000010)) && ENABLE_COUNTERS && ENABLE_COUNTERS64;
 			instr_rdinstr  <=  (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11000000001000000010) && ENABLE_COUNTERS;
 			instr_rdinstrh <=  (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11001000001000000010) && ENABLE_COUNTERS && ENABLE_COUNTERS64;
 
 			instr_ecall_ebreak <= ((mem_rdata_q[6:0] == 7'b1110011 && !mem_rdata_q[31:21] && !mem_rdata_q[19:7]) ||
 					(COMPRESSED_ISA && mem_rdata_q[15:0] == 16'h9002));
 
 			instr_getq    <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000000 && ENABLE_IRQ && ENABLE_IRQ_QREGS;
 			instr_setq    <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000001 && ENABLE_IRQ && ENABLE_IRQ_QREGS;
 			instr_maskirq <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000011 && ENABLE_IRQ;
 			instr_timer   <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000101 && ENABLE_IRQ && ENABLE_IRQ_TIMER;
 
 			is_slli_srli_srai <= is_alu_reg_imm && |{
 				mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000
 			};
 
 			is_jalr_addi_slti_sltiu_xori_ori_andi <= instr_jalr || is_alu_reg_imm && |{
 				mem_rdata_q[14:12] == 3'b000,
 				mem_rdata_q[14:12] == 3'b010,
 				mem_rdata_q[14:12] == 3'b011,
 				mem_rdata_q[14:12] == 3'b100,
 				mem_rdata_q[14:12] == 3'b110,
 				mem_rdata_q[14:12] == 3'b111
 			};
 
 			is_sll_srl_sra <= is_alu_reg_reg && |{
 				mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000
 			};
 
 			is_lui_auipc_jal_jalr_addi_add_sub <= 0;
 			is_compare <= 0;
 
 			(* parallel_case *)
 			case (1'b1)
 				instr_jal:
 					decoded_imm <= decoded_imm_uj;
 				|{instr_lui, instr_auipc}:
 					decoded_imm <= mem_rdata_q[31:12] << 12;
 				|{instr_jalr, is_lb_lh_lw_lbu_lhu, is_alu_reg_imm}:
 					decoded_imm <= $signed(mem_rdata_q[31:20]);
 				is_beq_bne_blt_bge_bltu_bgeu:
 					decoded_imm <= $signed({mem_rdata_q[31], mem_rdata_q[7], mem_rdata_q[30:25], mem_rdata_q[11:8], 1'b0});
 				is_sb_sh_sw:
 					decoded_imm <= $signed({mem_rdata_q[31:25], mem_rdata_q[11:7]});
 				default:
 					decoded_imm <= 1'bx;
 			endcase
 		end
 
 		if (!resetn) begin
 			is_beq_bne_blt_bge_bltu_bgeu <= 0;
 			is_compare <= 0;
 
 			instr_beq   <= 0;
 			instr_bne   <= 0;
 			instr_blt   <= 0;
 			instr_bge   <= 0;
 			instr_bltu  <= 0;
 			instr_bgeu  <= 0;
 
 			instr_addi  <= 0;
 			instr_slti  <= 0;
 			instr_sltiu <= 0;
 			instr_xori  <= 0;
 			instr_ori   <= 0;
 			instr_andi  <= 0;
 
 			instr_add   <= 0;
 			instr_sub   <= 0;
 			instr_sll   <= 0;
 			instr_slt   <= 0;
 			instr_sltu  <= 0;
 			instr_xor   <= 0;
 			instr_srl   <= 0;
 			instr_sra   <= 0;
 			instr_or    <= 0;
 			instr_and   <= 0;
 		end
 	end
 
 
 	// Main State Machine
 
 	localparam cpu_state_trap   = 8'b10000000;
 	localparam cpu_state_fetch  = 8'b01000000;
 	localparam cpu_state_ld_rs1 = 8'b00100000;
 	localparam cpu_state_ld_rs2 = 8'b00010000;
 	localparam cpu_state_exec   = 8'b00001000;
 	localparam cpu_state_shift  = 8'b00000100;
 	localparam cpu_state_stmem  = 8'b00000010;
 	localparam cpu_state_ldmem  = 8'b00000001;
 
 	reg [7:0] cpu_state;
 	reg [1:0] irq_state;
 
 	//FORMAL_KEEP reg [127:0] dbg_ascii_state;
 
 	always @* begin
 		dbg_ascii_state = "";
 		if (cpu_state == cpu_state_trap)   dbg_ascii_state = "trap";
 		if (cpu_state == cpu_state_fetch)  dbg_ascii_state = "fetch";
 		if (cpu_state == cpu_state_ld_rs1) dbg_ascii_state = "ld_rs1";
 		if (cpu_state == cpu_state_ld_rs2) dbg_ascii_state = "ld_rs2";
 		if (cpu_state == cpu_state_exec)   dbg_ascii_state = "exec";
 		if (cpu_state == cpu_state_shift)  dbg_ascii_state = "shift";
 		if (cpu_state == cpu_state_stmem)  dbg_ascii_state = "stmem";
 		if (cpu_state == cpu_state_ldmem)  dbg_ascii_state = "ldmem";
 	end
 
 	reg set_mem_do_rinst;
 	reg set_mem_do_rdata;
 	reg set_mem_do_wdata;
 
 	reg latched_store;
 	reg latched_stalu;
 	reg latched_branch;
 	reg latched_compr;
 	reg latched_trace;
 	reg latched_is_lu;
 	reg latched_is_lh;
 	reg latched_is_lb;
 	reg [regindex_bits-1:0] latched_rd;
 
 	reg [31:0] current_pc;
 	assign next_pc = latched_store && latched_branch ? reg_out & ~1 : reg_next_pc;
 
 	reg [3:0] pcpi_timeout_counter;
 	reg pcpi_timeout;
 
 	reg [31:0] next_irq_pending;
 	reg do_waitirq;
 
 	reg [31:0] alu_out, alu_out_q;
 	reg alu_out_0, alu_out_0_q;
 	reg alu_wait, alu_wait_2;
 
 	reg [31:0] alu_add_sub;
 	reg [31:0] alu_shl, alu_shr;
 	reg alu_eq, alu_ltu, alu_lts;
 
 	generate if (TWO_CYCLE_ALU) begin
 		always @(posedge clk) begin
 			alu_add_sub <= instr_sub ? reg_op1 - reg_op2 : reg_op1 + reg_op2;
 			alu_eq <= reg_op1 == reg_op2;
 			alu_lts <= $signed(reg_op1) < $signed(reg_op2);
 			alu_ltu <= reg_op1 < reg_op2;
 			alu_shl <= reg_op1 << reg_op2[4:0];
 			alu_shr <= $signed({instr_sra || instr_srai ? reg_op1[31] : 1'b0, reg_op1}) >>> reg_op2[4:0];
 		end
 	end else begin
 		always @* begin
 			alu_add_sub = instr_sub ? reg_op1 - reg_op2 : reg_op1 + reg_op2;
 			alu_eq = reg_op1 == reg_op2;
 			alu_lts = $signed(reg_op1) < $signed(reg_op2);
 			alu_ltu = reg_op1 < reg_op2;
 			alu_shl = reg_op1 << reg_op2[4:0];
 			alu_shr = $signed({instr_sra || instr_srai ? reg_op1[31] : 1'b0, reg_op1}) >>> reg_op2[4:0];
 		end
 	end endgenerate
 
 	always @* begin
 		alu_out_0 = 'bx;
 		(* parallel_case, full_case *)
 		case (1'b1)
 			instr_beq:
 				alu_out_0 = alu_eq;
 			instr_bne:
 				alu_out_0 = !alu_eq;
 			instr_bge:
 				alu_out_0 = !alu_lts;
 			instr_bgeu:
 				alu_out_0 = !alu_ltu;
 			is_slti_blt_slt && (!TWO_CYCLE_COMPARE || !{instr_beq,instr_bne,instr_bge,instr_bgeu}):
 				alu_out_0 = alu_lts;
 			is_sltiu_bltu_sltu && (!TWO_CYCLE_COMPARE || !{instr_beq,instr_bne,instr_bge,instr_bgeu}):
 				alu_out_0 = alu_ltu;
 		endcase
 
 		alu_out = 'bx;
 		(* parallel_case, full_case *)
 		case (1'b1)
 			is_lui_auipc_jal_jalr_addi_add_sub:
 				alu_out = alu_add_sub;
 			is_compare:
 				alu_out = alu_out_0;
 			instr_xori || instr_xor:
 				alu_out = reg_op1 ^ reg_op2;
 			instr_ori || instr_or:
 				alu_out = reg_op1 | reg_op2;
 			instr_andi || instr_and:
 				alu_out = reg_op1 & reg_op2;
 			BARREL_SHIFTER && (instr_sll || instr_slli):
 				alu_out = alu_shl;
 			BARREL_SHIFTER && (instr_srl || instr_srli || instr_sra || instr_srai):
 				alu_out = alu_shr;
 		endcase
 
 ifdef RISCV_FORMAL_BLACKBOX_ALU
 		alu_out_0 = $anyseq;
 		alu_out = $anyseq;
 endif
 	end
 
 	reg clear_prefetched_high_word_q;
 	always @(posedge clk) clear_prefetched_high_word_q <= clear_prefetched_high_word;
 
 	always @* begin
 		clear_prefetched_high_word = clear_prefetched_high_word_q;
 		if (!prefetched_high_word)
 			clear_prefetched_high_word = 0;
 		if (latched_branch || irq_state || !resetn)
 			clear_prefetched_high_word = COMPRESSED_ISA;
 	end
 
 	reg cpuregs_write;
 	reg [31:0] cpuregs_wrdata_i;
     assign cpuregs_wrdata = cpuregs_wrdata_i;
 	reg [31:0] cpuregs_rs1;
 	reg [31:0] cpuregs_rs2;
 	reg [regindex_bits-1:0] decoded_rs;
 
 	always @* begin
 		cpuregs_write = 0;
 		cpuregs_wrdata_i = 'bx;
 
 		if (cpu_state == cpu_state_fetch) begin
 			(* parallel_case *)
 			case (1'b1)
 				latched_branch: begin
 					cpuregs_wrdata_i = reg_pc + (latched_compr ? 2 : 4);
 					cpuregs_write = 1;
 				end
 				latched_store && !latched_branch: begin
 					cpuregs_wrdata_i = latched_stalu ? alu_out_q : reg_out;
 					cpuregs_write = 1;
 				end
 				ENABLE_IRQ && irq_state[0]: begin
 					cpuregs_wrdata_i = reg_next_pc | latched_compr;
 					cpuregs_write = 1;
 				end
 				ENABLE_IRQ && irq_state[1]: begin
 					cpuregs_wrdata_i = irq_pending & ~irq_mask;
 					cpuregs_write = 1;
 				end
 			endcase
 		end
 	end
 
 ifndef PICORV32_REGS
 	always @(posedge clk) begin
 		if (resetn && cpuregs_write && latched_rd)
 			cpuregs[latched_rd] <= cpuregs_wrdata_i;
 	end
 
 	always @* begin
 		decoded_rs = 'bx;
 		if (ENABLE_REGS_DUALPORT) begin
 ifndef RISCV_FORMAL_BLACKBOX_REGS
 			cpuregs_rs1 = decoded_rs1 ? cpuregs[decoded_rs1] : 0;
 			cpuregs_rs2 = decoded_rs2 ? cpuregs[decoded_rs2] : 0;
 else
 			cpuregs_rs1 = decoded_rs1 ? $anyseq : 0;
 			cpuregs_rs2 = decoded_rs2 ? $anyseq : 0;
 endif
 		end else begin
 			decoded_rs = (cpu_state == cpu_state_ld_rs2) ? decoded_rs2 : decoded_rs1;
 ifndef RISCV_FORMAL_BLACKBOX_REGS
 			cpuregs_rs1 = decoded_rs ? cpuregs[decoded_rs] : 0;
 else
 			cpuregs_rs1 = decoded_rs ? $anyseq : 0;
 endif
 			cpuregs_rs2 = cpuregs_rs1;
 		end
 	end
 else
 
 	assign cpuregs_waddr = latched_rd;
 	assign cpuregs_raddr1 = ENABLE_REGS_DUALPORT ? decoded_rs1 : decoded_rs;
 	assign cpuregs_raddr2 = ENABLE_REGS_DUALPORT ? decoded_rs2 : 0;
 
 	always @* begin
 		decoded_rs = 'bx;
 		if (ENABLE_REGS_DUALPORT) begin
 			cpuregs_rs1 = decoded_rs1 ? cpuregs_rdata1 : 0;
 			cpuregs_rs2 = decoded_rs2 ? cpuregs_rdata2 : 0;
 		end else begin
 			decoded_rs = (cpu_state == cpu_state_ld_rs2) ? decoded_rs2 : decoded_rs1;
 			cpuregs_rs1 = decoded_rs ? cpuregs_rdata1 : 0;
 			cpuregs_rs2 = cpuregs_rs1;
 		end
 	end
 endif
 
 	assign launch_next_insn = cpu_state == cpu_state_fetch && decoder_trigger && (!ENABLE_IRQ || irq_delay || irq_active || !(irq_pending & ~irq_mask));
 
 	always @(posedge clk) begin
 		trap <= 0;
 		reg_sh <= 'bx;
 		reg_out <= 'bx;
 		set_mem_do_rinst = 0;
 		set_mem_do_rdata = 0;
 		set_mem_do_wdata = 0;
 
 		alu_out_0_q <= alu_out_0;
 		alu_out_q <= alu_out;
 
 		alu_wait <= 0;
 		alu_wait_2 <= 0;
 
 		if (launch_next_insn) begin
 			dbg_rs1val <= 'bx;
 			dbg_rs2val <= 'bx;
 			dbg_rs1val_valid <= 0;
 			dbg_rs2val_valid <= 0;
 		end
 
 		if (WITH_PCPI && CATCH_ILLINSN) begin
 			if (resetn && pcpi_valid_i && !pcpi_int_wait) begin
 				if (pcpi_timeout_counter)
 					pcpi_timeout_counter <= pcpi_timeout_counter - 1;
 			end else
 				pcpi_timeout_counter <= ~0;
 			pcpi_timeout <= !pcpi_timeout_counter;
 		end
 
 		if (ENABLE_COUNTERS) begin
 			count_cycle <= resetn ? count_cycle + 1 : 0;
 			if (!ENABLE_COUNTERS64) count_cycle[63:32] <= 0;
 		end else begin
 			count_cycle <= 'bx;
 			count_instr <= 'bx;
 		end
 
 		next_irq_pending = ENABLE_IRQ ? irq_pending & LATCHED_IRQ : 'bx;
 
 		if (ENABLE_IRQ && ENABLE_IRQ_TIMER && timer) begin
 			if (timer - 1 == 0)
 				next_irq_pending[irq_timer] = 1;
 			timer <= timer - 1;
 		end
 
 		if (ENABLE_IRQ) begin
 			next_irq_pending = next_irq_pending | irq;
 		end
 
 		decoder_trigger <= mem_do_rinst && mem_done;
 		decoder_trigger_q <= decoder_trigger;
 		decoder_pseudo_trigger <= 0;
 		decoder_pseudo_trigger_q <= decoder_pseudo_trigger;
 		do_waitirq <= 0;
 
 		trace_valid <= 0;
 
 		if (!ENABLE_TRACE)
 			trace_data <= 'bx;
 
 		if (!resetn) begin
 			reg_pc <= PROGADDR_RESET;
 			reg_next_pc <= PROGADDR_RESET;
 			if (ENABLE_COUNTERS)
 				count_instr <= 0;
 			latched_store <= 0;
 			latched_stalu <= 0;
 			latched_branch <= 0;
 			latched_trace <= 0;
 			latched_is_lu <= 0;
 			latched_is_lh <= 0;
 			latched_is_lb <= 0;
 			pcpi_valid_i <= 0;
 			pcpi_timeout <= 0;
 			irq_active <= 0;
 			irq_delay <= 0;
 			irq_mask <= ~0;
 			next_irq_pending = 0;
 			irq_state <= 0;
 			eoi <= 0;
 			timer <= 0;
 			if (~STACKADDR) begin
 				latched_store <= 1;
 				latched_rd <= 2;
 				reg_out <= STACKADDR;
 			end
 			cpu_state <= cpu_state_fetch;
 		end else
 		(* parallel_case, full_case *)
 		case (cpu_state)
 			cpu_state_trap: begin
 				trap <= 1;
 			end
 
 			cpu_state_fetch: begin
 				mem_do_rinst <= !decoder_trigger && !do_waitirq;
 				mem_wordsize <= 0;
 
 				current_pc = reg_next_pc;
 
 				(* parallel_case *)
 				case (1'b1)
 					latched_branch: begin
 						current_pc = latched_store ? (latched_stalu ? alu_out_q : reg_out) & ~1 : reg_next_pc;
 						//debug($display("ST_RD:  %2d 0x%08x, BRANCH 0x%08x", latched_rd, reg_pc + (latched_compr ? 2 : 4), current_pc);)
 					end
 					latched_store && !latched_branch: begin
 						//debug($display("ST_RD:  %2d 0x%08x", latched_rd, latched_stalu ? alu_out_q : reg_out);)
 					end
 					ENABLE_IRQ && irq_state[0]: begin
 						current_pc = PROGADDR_IRQ;
 						irq_active <= 1;
 						mem_do_rinst <= 1;
 					end
 					ENABLE_IRQ && irq_state[1]: begin
 						eoi <= irq_pending & ~irq_mask;
 						next_irq_pending = next_irq_pending & irq_mask;
 					end
 				endcase
 
 				if (ENABLE_TRACE && latched_trace) begin
 					latched_trace <= 0;
 					trace_valid <= 1;
 					if (latched_branch)
 						trace_data <= (irq_active ? TRACE_IRQ : 0) | TRACE_BRANCH | (current_pc & 32'hfffffffe);
 					else
 						trace_data <= (irq_active ? TRACE_IRQ : 0) | (latched_stalu ? alu_out_q : reg_out);
 				end
 
 				reg_pc <= current_pc;
 				reg_next_pc <= current_pc;
 
 				latched_store <= 0;
 				latched_stalu <= 0;
 				latched_branch <= 0;
 				latched_is_lu <= 0;
 				latched_is_lh <= 0;
 				latched_is_lb <= 0;
 				latched_rd <= decoded_rd;
 				latched_compr <= compressed_instr;
 
 				if (ENABLE_IRQ && ((decoder_trigger && !irq_active && !irq_delay && |(irq_pending & ~irq_mask)) || irq_state)) begin
 					irq_state <=
 						irq_state == 2'b00 ? 2'b01 :
 						irq_state == 2'b01 ? 2'b10 : 2'b00;
 					latched_compr <= latched_compr;
 					if (ENABLE_IRQ_QREGS)
 						latched_rd <= irqregs_offset | irq_state[0];
 					else
 						latched_rd <= irq_state[0] ? 4 : 3;
 				end else
 				if (ENABLE_IRQ && (decoder_trigger || do_waitirq) && instr_waitirq) begin
 					if (irq_pending) begin
 						latched_store <= 1;
 						reg_out <= irq_pending;
 						reg_next_pc <= current_pc + (compressed_instr ? 2 : 4);
 						mem_do_rinst <= 1;
 					end else
 						do_waitirq <= 1;
 				end else
 				if (decoder_trigger) begin
 					//debug($display("-- %-0t", $time);)
 					irq_delay <= irq_active;
 					reg_next_pc <= current_pc + (compressed_instr ? 2 : 4);
 					if (ENABLE_TRACE)
 						latched_trace <= 1;
 					if (ENABLE_COUNTERS) begin
 						count_instr <= count_instr + 1;
 						if (!ENABLE_COUNTERS64) count_instr[63:32] <= 0;
 					end
 					if (instr_jal) begin
 						mem_do_rinst <= 1;
 						reg_next_pc <= current_pc + decoded_imm_uj;
 						latched_branch <= 1;
 					end else begin
 						mem_do_rinst <= 0;
 						mem_do_prefetch <= !instr_jalr && !instr_retirq;
 						cpu_state <= cpu_state_ld_rs1;
 					end
 				end
 			end
 
 			cpu_state_ld_rs1: begin
 				reg_op1 <= 'bx;
 				reg_op2 <= 'bx;
 
 				(* parallel_case *)
 				case (1'b1)
 					(CATCH_ILLINSN || WITH_PCPI) && instr_trap: begin
 						if (WITH_PCPI) begin
 							//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 							reg_op1 <= cpuregs_rs1;
 							dbg_rs1val <= cpuregs_rs1;
 							dbg_rs1val_valid <= 1;
 							if (ENABLE_REGS_DUALPORT) begin
 								pcpi_valid_i <= 1;
 								//debug($display("LD_RS2: %2d 0x%08x", decoded_rs2, cpuregs_rs2);)
 								reg_sh <= cpuregs_rs2;
 								reg_op2 <= cpuregs_rs2;
 								dbg_rs2val <= cpuregs_rs2;
 								dbg_rs2val_valid <= 1;
 								if (pcpi_int_ready) begin
 									mem_do_rinst <= 1;
 									pcpi_valid_i <= 0;
 									reg_out <= pcpi_int_rd;
 									latched_store <= pcpi_int_wr;
 									cpu_state <= cpu_state_fetch;
 								end else
 								if (CATCH_ILLINSN && (pcpi_timeout || instr_ecall_ebreak)) begin
 									pcpi_valid_i <= 0;
 									//debug($display("EBREAK OR UNSUPPORTED INSN AT 0x%08x", reg_pc);)
 									if (ENABLE_IRQ && !irq_mask[irq_ebreak] && !irq_active) begin
 										next_irq_pending[irq_ebreak] = 1;
 										cpu_state <= cpu_state_fetch;
 									end else
 										cpu_state <= cpu_state_trap;
 								end
 							end else begin
 								cpu_state <= cpu_state_ld_rs2;
 							end
 						end else begin
 							//debug($display("EBREAK OR UNSUPPORTED INSN AT 0x%08x", reg_pc);)
 							if (ENABLE_IRQ && !irq_mask[irq_ebreak] && !irq_active) begin
 								next_irq_pending[irq_ebreak] = 1;
 								cpu_state <= cpu_state_fetch;
 							end else
 								cpu_state <= cpu_state_trap;
 						end
 					end
 					ENABLE_COUNTERS && is_rdcycle_rdcycleh_rdinstr_rdinstrh: begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							instr_rdcycle:
 								reg_out <= count_cycle[31:0];
 							instr_rdcycleh && ENABLE_COUNTERS64:
 								reg_out <= count_cycle[63:32];
 							instr_rdinstr:
 								reg_out <= count_instr[31:0];
 							instr_rdinstrh && ENABLE_COUNTERS64:
 								reg_out <= count_instr[63:32];
 						endcase
 						latched_store <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					is_lui_auipc_jal: begin
 						reg_op1 <= instr_lui ? 0 : reg_pc;
 						reg_op2 <= decoded_imm;
 						if (TWO_CYCLE_ALU)
 							alu_wait <= 1;
 						else
 							mem_do_rinst <= mem_do_prefetch;
 						cpu_state <= cpu_state_exec;
 					end
 					ENABLE_IRQ && ENABLE_IRQ_QREGS && instr_getq: begin
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_out <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						latched_store <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && ENABLE_IRQ_QREGS && instr_setq: begin
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_out <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						latched_rd <= latched_rd | irqregs_offset;
 						latched_store <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && instr_retirq: begin
 						//eoi <= 0;
 						irq_active <= 0;
 						latched_branch <= 1;
 						latched_store <= 1;
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_out <= CATCH_MISALIGN ? (cpuregs_rs1 & 32'h fffffffe) : cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && instr_maskirq: begin
 						latched_store <= 1;
 						reg_out <= irq_mask;
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						irq_mask <= cpuregs_rs1 | MASKED_IRQ;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && ENABLE_IRQ_TIMER && instr_timer: begin
 						latched_store <= 1;
 						reg_out <= timer;
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						timer <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					is_lb_lh_lw_lbu_lhu && !instr_trap: begin
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_ldmem;
 						mem_do_rinst <= 1;
 					end
 					is_slli_srli_srai && !BARREL_SHIFTER: begin
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						reg_sh <= decoded_rs2;
 						cpu_state <= cpu_state_shift;
 					end
 					is_jalr_addi_slti_sltiu_xori_ori_andi, is_slli_srli_srai && BARREL_SHIFTER: begin
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						reg_op2 <= is_slli_srli_srai && BARREL_SHIFTER ? decoded_rs2 : decoded_imm;
 						if (TWO_CYCLE_ALU)
 							alu_wait <= 1;
 						else
 							mem_do_rinst <= mem_do_prefetch;
 						cpu_state <= cpu_state_exec;
 					end
 					default: begin
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						if (ENABLE_REGS_DUALPORT) begin
 							//debug($display("LD_RS2: %2d 0x%08x", decoded_rs2, cpuregs_rs2);)
 							reg_sh <= cpuregs_rs2;
 							reg_op2 <= cpuregs_rs2;
 							dbg_rs2val <= cpuregs_rs2;
 							dbg_rs2val_valid <= 1;
 							(* parallel_case *)
 							case (1'b1)
 								is_sb_sh_sw: begin
 									cpu_state <= cpu_state_stmem;
 									mem_do_rinst <= 1;
 								end
 								is_sll_srl_sra && !BARREL_SHIFTER: begin
 									cpu_state <= cpu_state_shift;
 								end
 								default: begin
 									if (TWO_CYCLE_ALU || (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu)) begin
 										alu_wait_2 <= TWO_CYCLE_ALU && (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu);
 										alu_wait <= 1;
 									end else
 										mem_do_rinst <= mem_do_prefetch;
 									cpu_state <= cpu_state_exec;
 								end
 							endcase
 						end else
 							cpu_state <= cpu_state_ld_rs2;
 					end
 				endcase
 			end
 
 			cpu_state_ld_rs2: begin
 				//debug($display("LD_RS2: %2d 0x%08x", decoded_rs2, cpuregs_rs2);)
 				reg_sh <= cpuregs_rs2;
 				reg_op2 <= cpuregs_rs2;
 				dbg_rs2val <= cpuregs_rs2;
 				dbg_rs2val_valid <= 1;
 
 				(* parallel_case *)
 				case (1'b1)
 					WITH_PCPI && instr_trap: begin
 						pcpi_valid_i <= 1;
 						if (pcpi_int_ready) begin
 							mem_do_rinst <= 1;
 							pcpi_valid_i <= 0;
 							reg_out <= pcpi_int_rd;
 							latched_store <= pcpi_int_wr;
 							cpu_state <= cpu_state_fetch;
 						end else
 						if (CATCH_ILLINSN && (pcpi_timeout || instr_ecall_ebreak)) begin
 							pcpi_valid_i <= 0;
 							//debug($display("EBREAK OR UNSUPPORTED INSN AT 0x%08x", reg_pc);)
 							if (ENABLE_IRQ && !irq_mask[irq_ebreak] && !irq_active) begin
 								next_irq_pending[irq_ebreak] = 1;
 								cpu_state <= cpu_state_fetch;
 							end else
 								cpu_state <= cpu_state_trap;
 						end
 					end
 					is_sb_sh_sw: begin
 						cpu_state <= cpu_state_stmem;
 						mem_do_rinst <= 1;
 					end
 					is_sll_srl_sra && !BARREL_SHIFTER: begin
 						cpu_state <= cpu_state_shift;
 					end
 					default: begin
 						if (TWO_CYCLE_ALU || (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu)) begin
 							alu_wait_2 <= TWO_CYCLE_ALU && (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu);
 							alu_wait <= 1;
 						end else
 							mem_do_rinst <= mem_do_prefetch;
 						cpu_state <= cpu_state_exec;
 					end
 				endcase
 			end
 
 			cpu_state_exec: begin
 				reg_out <= reg_pc + decoded_imm;
 				if ((TWO_CYCLE_ALU || TWO_CYCLE_COMPARE) && (alu_wait || alu_wait_2)) begin
 					mem_do_rinst <= mem_do_prefetch && !alu_wait_2;
 					alu_wait <= alu_wait_2;
 				end else
 				if (is_beq_bne_blt_bge_bltu_bgeu) begin
 					latched_rd <= 0;
 					latched_store <= TWO_CYCLE_COMPARE ? alu_out_0_q : alu_out_0;
 					latched_branch <= TWO_CYCLE_COMPARE ? alu_out_0_q : alu_out_0;
 					if (mem_done)
 						cpu_state <= cpu_state_fetch;
 					if (TWO_CYCLE_COMPARE ? alu_out_0_q : alu_out_0) begin
 						decoder_trigger <= 0;
 						set_mem_do_rinst = 1;
 					end
 				end else begin
 					latched_branch <= instr_jalr;
 					latched_store <= 1;
 					latched_stalu <= 1;
 					cpu_state <= cpu_state_fetch;
 				end
 			end
 
 			cpu_state_shift: begin
 				latched_store <= 1;
 				if (reg_sh == 0) begin
 					reg_out <= reg_op1;
 					mem_do_rinst <= mem_do_prefetch;
 					cpu_state <= cpu_state_fetch;
 				end else if (TWO_STAGE_SHIFT && reg_sh >= 4) begin
 					(* parallel_case, full_case *)
 					case (1'b1)
 						instr_slli || instr_sll: reg_op1 <= reg_op1 << 4;
 						instr_srli || instr_srl: reg_op1 <= reg_op1 >> 4;
 						instr_srai || instr_sra: reg_op1 <= $signed(reg_op1) >>> 4;
 					endcase
 					reg_sh <= reg_sh - 4;
 				end else begin
 					(* parallel_case, full_case *)
 					case (1'b1)
 						instr_slli || instr_sll: reg_op1 <= reg_op1 << 1;
 						instr_srli || instr_srl: reg_op1 <= reg_op1 >> 1;
 						instr_srai || instr_sra: reg_op1 <= $signed(reg_op1) >>> 1;
 					endcase
 					reg_sh <= reg_sh - 1;
 				end
 			end
 
 			cpu_state_stmem: begin
 				if (ENABLE_TRACE)
 					reg_out <= reg_op2;
 				if (!mem_do_prefetch || mem_done) begin
 					if (!mem_do_wdata) begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							instr_sb: mem_wordsize <= 2;
 							instr_sh: mem_wordsize <= 1;
 							instr_sw: mem_wordsize <= 0;
 						endcase
 						if (ENABLE_TRACE) begin
 							trace_valid <= 1;
 							trace_data <= (irq_active ? TRACE_IRQ : 0) | TRACE_ADDR | ((reg_op1 + decoded_imm) & 32'hffffffff);
 						end
 						reg_op1 <= reg_op1 + decoded_imm;
 						set_mem_do_wdata = 1;
 					end
 					if (!mem_do_prefetch && mem_done) begin
 						cpu_state <= cpu_state_fetch;
 						decoder_trigger <= 1;
 						decoder_pseudo_trigger <= 1;
 					end
 				end
 			end
 
 			cpu_state_ldmem: begin
 				latched_store <= 1;
 				if (!mem_do_prefetch || mem_done) begin
 					if (!mem_do_rdata) begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							instr_lb || instr_lbu: mem_wordsize <= 2;
 							instr_lh || instr_lhu: mem_wordsize <= 1;
 							instr_lw: mem_wordsize <= 0;
 						endcase
 						latched_is_lu <= is_lbu_lhu_lw;
 						latched_is_lh <= instr_lh;
 						latched_is_lb <= instr_lb;
 						if (ENABLE_TRACE) begin
 							trace_valid <= 1;
 							trace_data <= (irq_active ? TRACE_IRQ : 0) | TRACE_ADDR | ((reg_op1 + decoded_imm) & 32'hffffffff);
 						end
 						reg_op1 <= reg_op1 + decoded_imm;
 						set_mem_do_rdata = 1;
 					end
 					if (!mem_do_prefetch && mem_done) begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							latched_is_lu: reg_out <= mem_rdata_word;
 							latched_is_lh: reg_out <= $signed(mem_rdata_word[15:0]);
 							latched_is_lb: reg_out <= $signed(mem_rdata_word[7:0]);
 						endcase
 						decoder_trigger <= 1;
 						decoder_pseudo_trigger <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 				end
 			end
 		endcase
 
 		if (CATCH_MISALIGN && resetn && (mem_do_rdata || mem_do_wdata)) begin
 			if (mem_wordsize == 0 && reg_op1[1:0] != 0) begin
 				//debug($display("MISALIGNED WORD: 0x%08x", reg_op1);)
 				if (ENABLE_IRQ && !irq_mask[irq_buserror] && !irq_active) begin
 					next_irq_pending[irq_buserror] = 1;
 				end else
 					cpu_state <= cpu_state_trap;
 			end
 			if (mem_wordsize == 1 && reg_op1[0] != 0) begin
 				//debug($display("MISALIGNED HALFWORD: 0x%08x", reg_op1);)
 				if (ENABLE_IRQ && !irq_mask[irq_buserror] && !irq_active) begin
 					next_irq_pending[irq_buserror] = 1;
 				end else
 					cpu_state <= cpu_state_trap;
 			end
 		end
 		if (CATCH_MISALIGN && resetn && mem_do_rinst && (COMPRESSED_ISA ? reg_pc[0] : |reg_pc[1:0])) begin
 			//debug($display("MISALIGNED INSTRUCTION: 0x%08x", reg_pc);)
 			if (ENABLE_IRQ && !irq_mask[irq_buserror] && !irq_active) begin
 				next_irq_pending[irq_buserror] = 1;
 			end else
 				cpu_state <= cpu_state_trap;
 		end
 		if (!CATCH_ILLINSN && decoder_trigger_q && !decoder_pseudo_trigger_q && instr_ecall_ebreak) begin
 			cpu_state <= cpu_state_trap;
 		end
 
 		if (!resetn || mem_done) begin
 			mem_do_prefetch <= 0;
 			mem_do_rinst <= 0;
 			mem_do_rdata <= 0;
 			mem_do_wdata <= 0;
 		end
 
 		if (set_mem_do_rinst)
 			mem_do_rinst <= 1;
 		if (set_mem_do_rdata)
 			mem_do_rdata <= 1;
 		if (set_mem_do_wdata)
 			mem_do_wdata <= 1;
 
 		irq_pending <= next_irq_pending & ~MASKED_IRQ;
 
 		if (!CATCH_MISALIGN) begin
 			if (COMPRESSED_ISA) begin
 				reg_pc[0] <= 0;
 				reg_next_pc[0] <= 0;
 			end else begin
 				reg_pc[1:0] <= 0;
 				reg_next_pc[1:0] <= 0;
 			end
 		end
 		current_pc = 'bx;
 	end
 
 ifdef RISCV_FORMAL
 	reg dbg_irq_call;
 	reg dbg_irq_enter;
 	reg [31:0] dbg_irq_ret;
 	always @(posedge clk) begin
 		rvfi_valid <= resetn && (launch_next_insn || trap) && dbg_valid_insn;
 		rvfi_order <= resetn ? rvfi_order + rvfi_valid : 0;
 
 		rvfi_insn <= dbg_insn_opcode;
 		rvfi_rs1_addr <= dbg_rs1val_valid ? dbg_insn_rs1 : 0;
 		rvfi_rs2_addr <= dbg_rs2val_valid ? dbg_insn_rs2 : 0;
 		rvfi_pc_rdata <= dbg_insn_addr;
 		rvfi_rs1_rdata <= dbg_rs1val_valid ? dbg_rs1val : 0;
 		rvfi_rs2_rdata <= dbg_rs2val_valid ? dbg_rs2val : 0;
 		rvfi_trap <= trap;
 		rvfi_halt <= trap;
 		rvfi_intr <= dbg_irq_enter;
 		rvfi_mode <= 3;
 
 		if (!resetn) begin
 			dbg_irq_call <= 0;
 			dbg_irq_enter <= 0;
 		end else
 		if (rvfi_valid) begin
 			dbg_irq_call <= 0;
 			dbg_irq_enter <= dbg_irq_call;
 		end else
 		if (irq_state == 1) begin
 			dbg_irq_call <= 1;
 			dbg_irq_ret <= next_pc;
 		end
 
 		if (!resetn) begin
 			rvfi_rd_addr <= 0;
 			rvfi_rd_wdata <= 0;
 		end else
 		if (cpuregs_write && !irq_state) begin
 			rvfi_rd_addr <= latched_rd;
 			rvfi_rd_wdata <= latched_rd ? cpuregs_wrdata_i : 0;
 		end else
 		if (rvfi_valid) begin
 			rvfi_rd_addr <= 0;
 			rvfi_rd_wdata <= 0;
 		end
 
 		casez (dbg_insn_opcode)
 			32'b 0000000_?????_000??_???_?????_0001011: begin // getq
 				rvfi_rs1_addr <= 0;
 				rvfi_rs1_rdata <= 0;
 			end
 			32'b 0000001_?????_?????_???_000??_0001011: begin // setq
 				rvfi_rd_addr <= 0;
 				rvfi_rd_wdata <= 0;
 			end
 			32'b 0000010_?????_00000_???_00000_0001011: begin // retirq
 				rvfi_rs1_addr <= 0;
 				rvfi_rs1_rdata <= 0;
 			end
 		endcase
 
 		if (!dbg_irq_call) begin
 			if (dbg_mem_instr) begin
 				rvfi_mem_addr <= 0;
 				rvfi_mem_rmask <= 0;
 				rvfi_mem_wmask <= 0;
 				rvfi_mem_rdata <= 0;
 				rvfi_mem_wdata <= 0;
 			end else
 			if (dbg_mem_valid && dbg_mem_ready) begin
 				rvfi_mem_addr <= dbg_mem_addr;
 				rvfi_mem_rmask <= dbg_mem_wstrb ? 0 : ~0;
 				rvfi_mem_wmask <= dbg_mem_wstrb;
 				rvfi_mem_rdata <= dbg_mem_rdata;
 				rvfi_mem_wdata <= dbg_mem_wdata;
 			end
 		end
 	end
 
 	always @* begin
 		rvfi_pc_wdata = dbg_irq_call ? dbg_irq_ret : dbg_insn_addr;
 	end
 endif
 
 	// Formal Verification
 ifdef FORMAL
 	reg [3:0] last_mem_nowait;
 	always @(posedge clk)
 		last_mem_nowait <= {last_mem_nowait, mem_ready || !mem_valid_i};
 
 	// stall the memory interface for max 4 cycles
 	restrict property (|last_mem_nowait || mem_ready || !mem_valid_i);
 
 	// resetn low in first cycle, after that resetn high
 	restrict property (resetn != $initstate);
 
 	// this just makes it much easier to read traces. uncomment as needed.
 	// assume property (mem_valid || !mem_ready);
 
 	reg ok;
 	always @* begin
 		if (resetn) begin
 			// instruction fetches are read-only
 			if (mem_valid_i && mem_instr_i)
 				assert (mem_wstrb_i == 0);
 
 			// cpu_state must be valid
 			ok = 0;
 			if (cpu_state == cpu_state_trap)   ok = 1;
 			if (cpu_state == cpu_state_fetch)  ok = 1;
 			if (cpu_state == cpu_state_ld_rs1) ok = 1;
 			if (cpu_state == cpu_state_ld_rs2) ok = !ENABLE_REGS_DUALPORT;
 			if (cpu_state == cpu_state_exec)   ok = 1;
 			if (cpu_state == cpu_state_shift)  ok = 1;
 			if (cpu_state == cpu_state_stmem)  ok = 1;
 			if (cpu_state == cpu_state_ldmem)  ok = 1;
 			assert (ok);
 		end
 	end
 
 	reg last_mem_la_read = 0;
 	reg last_mem_la_write = 0;
 	reg [31:0] last_mem_la_addr;
 	reg [31:0] last_mem_la_wdata;
 	reg [3:0] last_mem_la_wstrb = 0;
 
 	always @(posedge clk) begin
 		last_mem_la_read <= mem_la_read;
 		last_mem_la_write <= mem_la_write;
 		last_mem_la_addr <= mem_la_addr;
 		last_mem_la_wdata <= mem_la_wdata;
 		last_mem_la_wstrb <= mem_la_wstrb;
 
 		if (last_mem_la_read) begin
 			assert(mem_valid_i);
 			assert(mem_addr_i == last_mem_la_addr);
 			assert(mem_wstrb_i == 0);
 		end
 		if (last_mem_la_write) begin
 			assert(mem_valid_i);
 			assert(mem_addr_i == last_mem_la_addr);
 			assert(mem_wdata_i == last_mem_la_wdata);
 			assert(mem_wstrb_i == last_mem_la_wstrb);
 		end
 		if (mem_la_read || mem_la_write) begin
 			assert(!mem_valid_i || mem_ready);
 		end
 	end
 endif
 
endmodule
//---- Top entity
module v5242e2 (
 input [31:0] v917e97,
 input [31:0] v5664d9,
 input [31:0] v918400,
 input [31:0] vae8a69,
 input vec88a9,
 input v76f74e,
 input ve3469f,
 input v58d02d,
 output [31:0] v493538
);
 wire [0:1] w0;
 wire w1;
 wire [0:31] w2;
 wire [0:31] w3;
 wire [0:31] w4;
 wire [0:31] w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:31] w10;
 wire [0:31] w11;
 wire [0:31] w12;
 assign w2 = v917e97;
 assign w3 = v5664d9;
 assign w4 = v918400;
 assign w5 = vae8a69;
 assign w6 = vec88a9;
 assign w7 = v76f74e;
 assign w8 = v58d02d;
 assign w9 = ve3469f;
 assign v493538 = w10;
 v6835fc ve38aa0 (
  .ved33bc(w0),
  .v2828a2(w2),
  .v86e1b9(w3),
  .v010aaa(w4),
  .v930664(w5),
  .v242732(w11)
 );
 veecece vfd598f (
  .vfd29cc(w0),
  .v5a4b06(w1),
  .v78af34(w6),
  .v78ff37(w7),
  .v44b9b7(w8),
  .v259301(w9)
 );
 vad96c0 v4b1d09 (
  .ve50a7b(w1),
  .v9960f4(w10),
  .v231daa(w11),
  .v95bea5(w12)
 );
 v2c97f6 vde5edd (
  .v7c9bd8(w12)
 );
endmodule

//---------------------------------------------------
//-- Bus-4
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bus de 32 bits de 4 canales
//---------------------------------------------------
//---- Top entity
module v6835fc (
 input [31:0] v2828a2,
 input [31:0] v86e1b9,
 input [31:0] v010aaa,
 input [31:0] v930664,
 input [1:0] ved33bc,
 output [31:0] v242732
);
 wire [0:31] w0;
 wire [0:31] w1;
 wire [0:31] w2;
 wire [0:31] w3;
 wire [0:31] w4;
 wire [0:1] w5;
 assign w0 = v2828a2;
 assign w1 = v86e1b9;
 assign w2 = v010aaa;
 assign w3 = v930664;
 assign v242732 = w4;
 assign w5 = ved33bc;
 v6835fc_ve4e0df ve4e0df (
  .i3(w0),
  .i2(w1),
  .i1(w2),
  .i0(w3),
  .o(w4),
  .s(w5)
 );
endmodule

//---------------------------------------------------
//-- Mux-4-1-32bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Multiplexor de 4 a 1 de 32 bits
//---------------------------------------------------

module v6835fc_ve4e0df (
 input [31:0] i3,
 input [31:0] i2,
 input [31:0] i1,
 input [31:0] i0,
 input [1:0] s,
 output [31:0] o
);
 //-- Multiplexor de 4 a 1, 
 //-- de 32 bits
 
 assign o = (s == 3'h0) ? i0 :
            (s == 3'h1) ? i1 :
            (s == 3'h2) ? i2 : 
            (s == 3'h3) ? i3 :
            32'h0;
            
 
 
endmodule
//---- Top entity
module veecece (
 input v78af34,
 input v78ff37,
 input v259301,
 input v44b9b7,
 output [1:0] vfd29cc,
 output v5a4b06
);
 wire [0:1] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign vfd29cc = w0;
 assign v5a4b06 = w1;
 assign w2 = v78af34;
 assign w3 = v78ff37;
 assign w4 = v259301;
 assign w5 = v44b9b7;
 veecece_v4407ca v4407ca (
  .y(w0),
  .zero(w1),
  .i3(w2),
  .i2(w3),
  .i1(w4),
  .i0(w5)
 );
endmodule

//---------------------------------------------------
//-- Codificador-4-2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Codificador de 4 a 2, con prioridad. La salida zero se activa cuando ninguna entrada est√° activad
//---------------------------------------------------

module veecece_v4407ca (
 input i3,
 input i2,
 input i1,
 input i0,
 output [1:0] y,
 output zero
);
 //-- Codificador de 4 a 1
 
 //-- Se√±alizar que todos son ceros
 assign zero = ({i3,i2,i1,i0}==4'b00);
 
 
 assign y = (i3 == 1) ? 2'h3 :
            (i2 == 1) ? 2'h2 :
            (i1 == 1) ? 2'h1 : 0;
           
 
endmodule
//---- Top entity
module vad96c0 (
 input [31:0] v95bea5,
 input [31:0] v231daa,
 input ve50a7b,
 output [31:0] v9960f4
);
 wire w0;
 wire [0:31] w1;
 wire [0:31] w2;
 wire [0:31] w3;
 assign w0 = ve50a7b;
 assign v9960f4 = w1;
 assign w2 = v231daa;
 assign w3 = v95bea5;
 vad96c0_v4d0636 v4d0636 (
  .sel(w0),
  .o(w1),
  .i0(w2),
  .i1(w3)
 );
endmodule

//---------------------------------------------------
//-- 32-bits-Mux-2-1-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 2-to-1 Multplexer (32-bit channels). Verilog implementation
//---------------------------------------------------

module vad96c0_v4d0636 (
 input [31:0] i1,
 input [31:0] i0,
 input sel,
 output [31:0] o
);
 //-- 2-to-1 Multiplexer 
 
 assign o = sel ? i1 : i0;
endmodule
//---- Top entity
module v2b4233 #(
 parameter v55b764 = 1
) (
 input v4c8225,
 output v6d0651
);
 localparam p1 = v55b764;
 wire w0;
 wire w2;
 wire [0:5] w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 assign v6d0651 = w5;
 assign w7 = v4c8225;
 assign w8 = v4c8225;
 assign w9 = v4c8225;
 assign w6 = w2;
 assign w8 = w7;
 assign w9 = w7;
 assign w9 = w8;
 v21cfcc v3023dc (
  .v9fb85f(w4)
 );
 v2814a1 vf701ed (
  .vc7a3dc(w2),
  .v1c1141(w3)
 );
 vef2764 #(
  .v573b2a(p1)
 ) v9d4f65 (
  .v4642b6(w0),
  .v27dec4(w4),
  .v92a149(w6),
  .v6dda25(w8)
 );
 v192520 v2efe33 (
  .v65c173(w0),
  .v15fb32(w3),
  .vdd729a(w9)
 );
 vae13be vb7abdc (
  .ve78ab8(w2),
  .v3487af(w5),
  .ved8395(w7)
 );
endmodule

//---------------------------------------------------
//-- Init-tic
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Emitir un tic inicial al arrancar, y nunca m√°s. Se esperan 32 tics antes de emitir el tic de inicializaci√≥n
//---------------------------------------------------
//---- Top entity
module v21cfcc (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v21cfcc_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

//---------------------------------------------------
//-- 0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Un bit constante a 0
//---------------------------------------------------

module v21cfcc_vb2eccd (
 output q
);
 //-- Bit constante a 0
 assign q = 1'b0;
 
 
endmodule
//---- Top entity
module v2814a1 (
 input [5:0] v1c1141,
 output vc7a3dc,
 output [4:0] vaa52cb
);
 wire [0:5] w0;
 wire [0:4] w1;
 wire w2;
 assign w0 = v1c1141;
 assign vaa52cb = w1;
 assign vc7a3dc = w2;
 v2814a1_v9a2a06 v9a2a06 (
  .i(w0),
  .o0(w1),
  .o1(w2)
 );
endmodule

//---------------------------------------------------
//-- Separador-bus-1-5
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 6-bits en 1 bit y bus de 5 bits
//---------------------------------------------------

module v2814a1_v9a2a06 (
 input [5:0] i,
 output o1,
 output [4:0] o0
);
 assign o1 = i[5];
 assign o0 = i[4:0];
 
endmodule
//---- Top entity
module vef2764 #(
 parameter v573b2a = 0
) (
 input v6dda25,
 input v27dec4,
 input v92a149,
 output v4642b6
);
 localparam p3 = v573b2a;
 wire w0;
 wire w1;
 wire w2;
 wire w4;
 assign w0 = v27dec4;
 assign w1 = v92a149;
 assign w2 = v6dda25;
 assign v4642b6 = w4;
 vef2764_v56c60e #(
  .INI(p3)
 ) v56c60e (
  .set(w0),
  .reset(w1),
  .clk(w2),
  .q(w4)
 );
endmodule

//---------------------------------------------------
//-- RS-FF-set-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- RS-FF-set-verilog. RS Flip-flop with priority set. Implementation in verilog
//---------------------------------------------------

module vef2764_v56c60e #(
 parameter INI = 0
) (
 input clk,
 input set,
 input reset,
 output q
);
 //-- Initial value
 reg qi = INI;
 
 always @(posedge clk)
 begin
 
   //-- Priority on set
   //-- It is first checked
   if (set == 1'b1) 
     qi <= 1'b1;
     
   //-- Second: check reset
   else if (reset == 1'b1)
     qi <= 1'b0;
     
   //-- In any other case the FF
   //-- remains in its current 
   //-- state (no change)
 end
 
 //-- Connect the register with the
 //-- output
 assign q = qi;
 
endmodule
//---- Top entity
module v192520 (
 input vdd729a,
 input v65c173,
 output [5:0] v15fb32
);
 wire w0;
 wire [0:5] w1;
 wire w2;
 assign w0 = vdd729a;
 assign v15fb32 = w1;
 assign w2 = v65c173;
 v192520_ve444b7 ve444b7 (
  .clk(w0),
  .q(w1),
  .ena(w2)
 );
endmodule

//---------------------------------------------------
//-- Contador-6bits-up-system-ena
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Contador del sistema, ascendente, de 6 bits, con enable 
//---------------------------------------------------

module v192520_ve444b7 (
 input clk,
 input ena,
 output [5:0] q
);
 reg [5:0] q_i;
 assign q = q_i;
 
 always @(posedge clk)
 begin
   if (ena)
     q_i <= q_i + 1;
 end
endmodule
//---- Top entity
module vae13be (
 input ved8395,
 input ve78ab8,
 output v1c9ba2,
 output v3487af
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign w0 = ve78ab8;
 assign w1 = ved8395;
 assign w4 = ve78ab8;
 assign v3487af = w5;
 assign w4 = w0;
 v3676a0 v9d4cda (
  .v0e28cb(w2),
  .vcbab45(w3)
 );
 vba518e v57aa83 (
  .v0e28cb(w3),
  .v3ca442(w4),
  .vcbab45(w5)
 );
 v58ed2b v4953b3 (
  .vf54559(w0),
  .va4102a(w1),
  .ve8318d(w2)
 );
endmodule

//---------------------------------------------------
//-- Rising-edge-detector
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Rising-edge detector. It generates a 1-period pulse (tic) when a rising edge is detected on the input. Block implementation
//---------------------------------------------------
//---- Top entity
module v3676a0 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v3676a0_vd54ca1 vd54ca1 (
  .a(w0),
  .q(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- NOT gate (Verilog implementation)
//---------------------------------------------------

module v3676a0_vd54ca1 (
 input a,
 output q
);
 //-- NOT Gate
 assign q = ~a;
 
 
endmodule
//---- Top entity
module vba518e (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vba518e_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Two bits input And gate
//---------------------------------------------------

module vba518e_vf4938a (
 input a,
 input b,
 output c
);
 //-- AND gate
 //-- Verilog implementation
 
 assign c = a & b;
 
endmodule
//---- Top entity
module v58ed2b #(
 parameter v71e305 = 0
) (
 input va4102a,
 input vf54559,
 output va58c5b,
 output ve8318d
);
 localparam p2 = v71e305;
 wire w0;
 wire w1;
 wire w3;
 assign w0 = va4102a;
 assign ve8318d = w1;
 assign w3 = vf54559;
 v58ed2b_vb8adf8 #(
  .INI(p2)
 ) vb8adf8 (
  .clk(w0),
  .q(w1),
  .d(w3)
 );
endmodule

//---------------------------------------------------
//-- sys-DFF-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- System - D Flip-flop. Capture data every system clock cycle. Verilog implementation
//---------------------------------------------------

module v58ed2b_vb8adf8 #(
 parameter INI = 0
) (
 input clk,
 input d,
 output q
);
 //-- Initial value
 reg qi = INI;
 
 //-- Capture the input data  
 //-- on the rising edge of  
 //-- the system clock
 always @(posedge clk)
   qi <= d;
   
 //-- Connect the register with the
 //-- output
 assign q = qi;
endmodule
ChatGPT said:
1 ¬∑ Qu√© hace EXACTAMENTE la UART para ‚Äúsoltar‚Äù el bus

                                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
ADDR, DATA, WE/RD, VALID  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  DECODER   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CS_UART (=w4)
                                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                               ‚îÇ     UART core        ‚îÇ
      DATA_IN (reg_dat_di)  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫   ‚îÇ  ve4ece1_v7323f5     ‚îÇ
                                               ‚îÇ                      ‚îÇ
      reg_dat_we (write strobe = CS ‚àß WE) ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ  inicia env√≠o        ‚îÇ
                                               ‚îÇ                      ‚îÇ
      **reg_dat_wait**  (=w2)  ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚îÇ  =1 mientras  tx_busy‚îÇ
                                               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚îÇ ¬¨reg_dat_wait (w0)
                 ‚ñº
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ   AND   ‚îÇ  (= vb2090f v8b2549)
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚ñº
        **bus_data_enable** (=w9)  ‚Üí  vuelve al procesador

    CS_UART (w4) se genera cuando la direcci√≥n del acceso coincide con 0x0200_0008 y VALID est√° a 1.

    Si el acceso es de escritura, reg_dat_we = CS_UART ‚àß WE arranca la transmisi√≥n dentro de la UART.

    La propia UART pone reg_dat_wait a 1 mientras el ‚Äúshift-register‚Äù est√° ocupado (send_bitcnt || send_dummy).

    La l√≥gica de bus forma el ACK con bus_data_enable = CS_UART ‚àß ¬¨reg_dat_wait
    (NOT gate v35f267 + AND vb2090f).

    De esta forma el procesador queda parado todo el tiempo que reg_dat_wait est√© a 1.
    En cuanto la UART termina, reg_dat_wait pasa a 0, el AND emite un pulso de bus_data_enable y
    el core baja VALID, con lo que CS_UART cae y el bus vuelve al estado IDLE en el siguiente ciclo.

    Es un ‚Äúwait-state generator‚Äù de un solo bit:
    CS permanece alto ‚Üí la UART conduce el bus ‚Üí cuando el perif√©rico indica ready (‚Äúwait=0‚Äù) ‚Üí se emite ACK ‚Üí CS se desaserta.

2 ¬∑ Qu√© partes puedes copiar para tu perif√©rico I¬≤C
UART	Tu I¬≤C	Acci√≥n a implementar
CS_UART (address match)	i2c_cs (= addr_match ‚àß VALID)	Ya lo tienes.
reg_dat_wait	I2C_Busy (salida busy_out de tu FSM)	Conecta igual.
bus_data_enable = CS ‚àß ¬¨wait	bus_data_enable = i2c_cs ‚àß ¬¨I2C_Busy	Clave: genera el ACK s√≥lo cuando busy_out vuelva a 0.
Generador de pulso (NOT+AND)	Identical NOT (~I2C_Busy) + AND with i2c_cs	O un flip-flop para empaquetar el pulso a 1 solo ciclo.
Multiplexor de datos	En tu main_vecfcb9 ya usas el codificador veecece	No cambies nada: el dato del bus ya se selecciona con la misma l√≥gica.

// ---- Hand-shake ‚Äúready/ack‚Äù para tu perif√©rico -----------------
reg ack_r;

/*  Pulso de 1 ciclo cuando la transacci√≥n puede cerrarse  */
always @(posedge clk or negedge rstn) begin
    if (!rstn)
        ack_r <= 1'b0;
    else if (i2c_cs && !I2C_Busy)   // listo y seleccionado
        ack_r <= 1'b1;              // <- se levanta
    else
        ack_r <= 1'b0;              // <- vuelve a 0 al ciclo siguiente
end

assign bus_data_enable = ack_r;     // mismo hilo que la UART

    Para escritura: el procesador s√≥lo necesita saber que ha depositado el dato en la interfaz, as√≠ que puedes levantar el ack_r inmediatamente o retrasarlo a la ca√≠da de I2C_Busy si quieres impedir que el software lance varias escrituras seguidas demasiado r√°pido.

    Para lectura: debes mantener I2C_Busy en 1 hasta que data_ready est√© v√°lido, para que el core no intente leer un resultado inexistente. Una vez copiados los bytes en data_out, baja I2C_Busy ‚Üí se dispara el pulso de ACK y el core recibe el dato.

3 ¬∑ Checklist para que el bus nunca vuelva a ‚Äúsecuestrarse‚Äù

    i2c_cs puro

    i2c_cs = (addr[31:6] == 6'h100) & VALID;   // s√≥lo direcci√≥n+valid

    bus_data_enable un pulso
    alto un √∫nico ciclo; derivado de ¬¨I2C_Busy.

    I2C_Busy limpio
    ‚Äì 1 mientras el FSM de main_v626e75 est√© en cualquier estado ‚â† READY.

    Sin feedbacks cruzados
    No conmutar bus_data_enable dentro de la misma RAM de registros (evita el viejo
    dataArray[bus_data_enable_register] <= !dataArray[...]); usa el flip-flop dedicado de arriba.

    Analizador l√≥gico
    Mira VALID, i2c_cs, I2C_Busy, bus_data_enable.
    Deber√≠as ver: VALID‚Üë ‚Üí i2c_cs‚Üë ‚Üí (espera) ‚Üí bus_data_enable ‚Üë ‚Üí al ciclo siguiente VALID ‚Üì y i2c_cs ‚Üì.

Con ese esquema tu dise√±o de I¬≤C ‚Äúhablar√°‚Äù con el procesador exactamente igual que la UART: el bus se libera siempre que el perif√©rico afirme ‚Äúya he terminado‚Äù y nunca m√°s volver√° a dejar la placa colgada.
You said:
jose@jose-NBLK-WAX9X:~/SE_Alhambra-II/Practicas/Practica3/Hardware$ cat MemoriaRAM.v 
// Code generated by Icestudio 0.12
// Fri, 18 Jul 2025 16:02:08 GMT

default_nettype none

//---- Top entity
module main #(
 parameter v6cd675 = 1024
) (
 input vclk,
 output [0:7] vinit
);
 localparam p0 = v6cd675;
 wire w1;
 assign w1 = vclk;
 vaba674 #(
  .v6478b6(p0)
 ) v9df961 (
  .v04ad7a(w1)
 );
 assign vinit = 8'b00000000;
endmodule

//---- Top entity
module vaba674 #(
 parameter v6478b6 = 1024
) (
 input v04ad7a,
 input [3:0] vd728f0,
 input v22c516,
 input vd7d395,
 input [31:0] v387cca,
 input [31:0] v8d6432,
 output v69f1ab,
 output [31:0] v13ce3e
);
 localparam p2 = v6478b6;
 wire [0:21] w0;
 wire [0:23] w1;
 wire w3;
 wire [0:3] w4;
 wire w5;
 wire w6;
 wire w7;
 wire [0:31] w8;
 wire [0:31] w9;
 wire w10;
 wire w11;
 wire [0:3] w12;
 wire [0:31] w13;
 wire w14;
 wire [0:31] w15;
 wire w16;
 wire w17;
 assign w8 = v387cca;
 assign w9 = v387cca;
 assign w10 = v22c516;
 assign w11 = vd7d395;
 assign w12 = vd728f0;
 assign w13 = v8d6432;
 assign v69f1ab = w14;
 assign v13ce3e = w15;
 assign w16 = v04ad7a;
 assign w17 = v04ad7a;
 assign w5 = w3;
 assign w9 = w8;
 assign w17 = w16;
 vf0a7c1 v00b15c (
  .vd903fe(w1),
  .v2ebc76(w9)
 );
 v359d9b v2b0874 (
  .vc5ea70(w0),
  .v84d8ec(w1)
 );
 vf6999a vaf52fa (
  .v7b40f2(w3),
  .vfa6171(w6),
  .v76af38(w7),
  .v7cacc4(w11)
 );
 v127665 #(
  .v16d6b8(p2)
 ) v9d2eb0 (
  .v18e78c(w7),
  .v229966(w8)
 );
 v35f267 v19c0ab (
  .vcbab45(w6),
  .v0e28cb(w10)
 );
 v13d09a vc5282a (
  .ve2642f(w4),
  .v76af38(w5),
  .vd317b3(w12)
 );
 v58ed2b ve2ae4f (
  .vf54559(w3),
  .ve8318d(w14),
  .va4102a(w16)
 );
 v33720b v13b1f8 (
  .va79cbd(w0),
  .vc52d9a(w4),
  .v72eed5(w13),
  .v02f96f(w15),
  .vfa6941(w17)
 );
endmodule

//---------------------------------------------------
//-- RAM-1KB-soc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- RAM block (1KB) with logic
//---------------------------------------------------
//---- Top entity
module vf0a7c1 (
 input [31:0] v2ebc76,
 output [7:0] v87715f,
 output [23:0] vd903fe
);
 wire [0:31] w0;
 wire [0:23] w1;
 wire [0:7] w2;
 assign w0 = v2ebc76;
 assign vd903fe = w1;
 assign v87715f = w2;
 vf0a7c1_v9a2a06 v9a2a06 (
  .i(w0),
  .o0(w1),
  .o1(w2)
 );
endmodule

//---------------------------------------------------
//-- Separador-8-24
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 32-bits en buses de 8 y 24 bits
//---------------------------------------------------

module vf0a7c1_v9a2a06 (
 input [31:0] i,
 output [7:0] o1,
 output [23:0] o0
);
 assign o1 = i[31:24];
 assign o0 = i[23:0];
endmodule
//---- Top entity
module v359d9b (
 input [23:0] v84d8ec,
 output [21:0] vc5ea70,
 output [1:0] v47f12b
);
 wire [0:21] w0;
 wire [0:1] w1;
 wire [0:23] w2;
 assign vc5ea70 = w0;
 assign v47f12b = w1;
 assign w2 = v84d8ec;
 v359d9b_v9a2a06 v9a2a06 (
  .o1(w0),
  .o0(w1),
  .i(w2)
 );
endmodule

//---------------------------------------------------
//-- Separador-22-2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 24-bits en dos buses de 22 y 2 bits
//---------------------------------------------------

module v359d9b_v9a2a06 (
 input [23:0] i,
 output [21:0] o1,
 output [1:0] o0
);
 assign o1 = i[23:2];
 assign o0 = i[1:0];
endmodule
//---- Top entity
module vf6999a (
 input vfa6171,
 input v7cacc4,
 input v76af38,
 output v7b40f2
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign v7b40f2 = w1;
 assign w2 = vfa6171;
 assign w3 = v7cacc4;
 assign w4 = v76af38;
 vb2090f v85500b (
  .vcbab45(w0),
  .v0e28cb(w2),
  .v3ca442(w3)
 );
 vb2090f v241483 (
  .v0e28cb(w0),
  .vcbab45(w1),
  .v3ca442(w4)
 );
endmodule

//---------------------------------------------------
//-- AND3
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND de 3 entradas
//---------------------------------------------------
//---- Top entity
module vb2090f (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vb2090f_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND
//---------------------------------------------------

module vb2090f_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta AND
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a & b;
 
 //-- endmodule
endmodule
//---- Top entity
module v127665 #(
 parameter v16d6b8 = 1
) (
 input [31:0] v229966,
 output v18e78c
);
 localparam p1 = v16d6b8;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = v229966;
 v127665_vd75681 #(
  .B(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Menor-que-1-op
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador menor que, de un operando de 32 bits
//---------------------------------------------------

module v127665_vd75681 #(
 parameter B = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a < B);
endmodule
//---- Top entity
module v35f267 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v35f267_vd54ca1 vd54ca1 (
  .a(w0),
  .c(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta NOT
//---------------------------------------------------

module v35f267_vd54ca1 (
 input a,
 output c
);
 //-- Puerta NOT
 
 //-- module (input wire a, output wire c);
 
 
 assign c = ~a;
 
 
 //-- endmodule
 
endmodule
//---- Top entity
module v13d09a (
 input [3:0] vd317b3,
 input v76af38,
 output [3:0] ve2642f
);
 wire w0;
 wire [0:3] w1;
 wire [0:3] w2;
 assign w0 = v76af38;
 assign w1 = vd317b3;
 assign ve2642f = w2;
 v13d09a_vce9fab vce9fab (
  .b(w0),
  .a(w1),
  .o(w2)
 );
endmodule

//---------------------------------------------------
//-- AND-4-1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND de dos operandos, de 1 y 4 bits
//---------------------------------------------------

module v13d09a_vce9fab (
 input [3:0] a,
 input b,
 output [3:0] o
);
 assign o[3] = a[3] & b;
 assign o[2] = a[2] & b;
 assign o[1] = a[1] & b;
 assign o[0] = a[0] & b;
endmodule
//---- Top entity
module v58ed2b #(
 parameter v71e305 = 0
) (
 input va4102a,
 input vf54559,
 output va58c5b,
 output ve8318d
);
 localparam p2 = v71e305;
 wire w0;
 wire w1;
 wire w3;
 assign w0 = va4102a;
 assign ve8318d = w1;
 assign w3 = vf54559;
 v58ed2b_vb8adf8 #(
  .INI(p2)
 ) vb8adf8 (
  .clk(w0),
  .q(w1),
  .d(w3)
 );
endmodule

//---------------------------------------------------
//-- sys-DFF-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- System - D Flip-flop. Capture data every system clock cycle. Verilog implementation
//---------------------------------------------------

module v58ed2b_vb8adf8 #(
 parameter INI = 0
) (
 input clk,
 input d,
 output q
);
 //-- Initial value
 reg qi = INI;
 
 //-- Capture the input data  
 //-- on the rising edge of  
 //-- the system clock
 always @(posedge clk)
   qi <= d;
   
 //-- Connect the register with the
 //-- output
 assign q = qi;
endmodule
//---- Top entity
module v33720b (
 input vfa6941,
 input [3:0] vc52d9a,
 input [21:0] va79cbd,
 input [31:0] v72eed5,
 output [31:0] v02f96f
);
 wire [0:3] w0;
 wire [0:21] w1;
 wire [0:31] w2;
 wire [0:31] w3;
 wire w4;
 assign w0 = vc52d9a;
 assign w1 = va79cbd;
 assign w2 = v72eed5;
 assign v02f96f = w3;
 assign w4 = vfa6941;
 v33720b_v0ae20e v0ae20e (
  .wen(w0),
  .addr(w1),
  .wdata(w2),
  .rdata(w3),
  .clk(w4)
 );
endmodule

//---------------------------------------------------
//-- RAM-1KB
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Memoria ram de 1KB (256x32bits)
//---------------------------------------------------

module v33720b_v0ae20e (
 input clk,
 input [3:0] wen,
 input [21:0] addr,
 input [31:0] wdata,
 output [31:0] rdata
);
 localparam integer WORDS = 256;
 
 reg [31:0] mem [0:WORDS-1];
 reg [31:0] rdata_i;
 assign rdata = rdata_i;
 
 	always @(posedge clk) begin
 		rdata_i <= mem[addr];
 		if (wen[0]) mem[addr][ 7: 0] <= wdata[ 7: 0];
 		if (wen[1]) mem[addr][15: 8] <= wdata[15: 8];
 		if (wen[2]) mem[addr][23:16] <= wdata[23:16];
 		if (wen[3]) mem[addr][31:24] <= wdata[31:24];
 	end
endmodule


Esta es la implementaci√≥n de la memoria ram. Tambi√©n funciona, que puedo usar de referencia de esto. Me gustar√≠a que la m√°quina de estados del i2c fuera as√≠ncrona y la interfaz fuera s√≠ncrona. Una vez se comienza la comunicaci√≥n i2c, los datos se van enviando por los pines que toca mientras la placa vuelve a su funcionamiento normal. Cuando termina de comunicarse, el m√≥dulo con la m√°quina de estados escribe en la interfaz, pero esto no es comunicado inmediatamente al procesador. Ser√° comunicado cuando el procesador acceda al registro con esta informaci√≥n. Es esto posible?
ChatGPT said:
¬øSe puede dejar la CPU ‚Äúen paz‚Äù mientras el I¬≤C sigue trabajando?

S√≠. La clave es separar bien:

    Dominio s√≠ncrono de bus (reloj clk_sys)

        donde viven los registros‚Äêinterfaz que ve el procesador (igual que tu RAM).

    Dominio propio del I¬≤C (reloj clk_i2c ‚âà SCL¬∑4)

        donde corre la FSM que genera SCL/SDA.

Luego unes ambos con un par de flip-flops de sincronizaci√≥n + flags.
Eso es exactamente lo que ya ocurre entre la CPU y la UART ‚Äîy en menor medida entre la CPU y tu RAM‚Äî, s√≥lo que ahora hay dos relojes.
1. Patr√≥n general (el mismo que en tu RAM)

      CPU                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 dominio I¬≤C
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ RegBank ‚îÇ<‚îÄ‚îÄ‚îÄ‚îêsync‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ   bus AXI  ‚îÇ‚îÄ‚îÄ CS ‚îÄ‚î¨‚îÄ‚îÄ‚ñ∫‚îÇ(clk_sys) ‚îÇ    ‚îÇ        ‚îÇ  ‚îÇ  FSM I¬≤C    ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ        ‚îÇ  ‚îÇ(clk_i2c)    ‚îÇ
                        ‚îÇ                  ‚îÇ        ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚ñº                  ‚îÇ        ‚îÇ
                +--------------+           ‚îÇ        ‚îÇ
      WDATA ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  START bit   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ   SDA/SCL
                +--------------+                    ‚îÇ
                |  STATUS bit  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄbusy‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                +--------------+                    ‚îÇ
                |  DATA_OUT    ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄdata_ready‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                +--------------+

    Escritura (CS && WE):
    ‚Äì CPU pone datos y ‚Äústart=1‚Äù en el banco de registros.
    ‚Äì bus_data_enable se genera un ciclo, el core suelta el bus.
    ‚Äì Un sincr. a clk_i2c detecta el flanco de start, arranca la FSM.

    Funcionamiento as√≠ncrono:
    ‚Äì FSM avanza estados, maneja SCL/SDA.
    ‚Äì Mantiene busy=1 mientras trabaja.

    Fin de transacci√≥n:
    ‚Äì FSM copia el byte recibido (si lo hay) en DATA_OUT, baja busy, sube un pulso data_ready en su reloj.

    Lectura (CS && !WE):
    ‚Äì CPU lee STATUS; si busy==0 puede leer DATA_OUT.
    ‚Äì Cuando accede, se produce otro pulso bus_data_enable y el ciclo acaba como en la UART.

As√≠ la CPU no espera mientras el I¬≤C opera; s√≥lo vuelve a mirar cuando le convenga.
2. C√≥mo reciclar bloques de tu dise√±o existente
Bloque que ya tienes	Para qu√© te sirve aqu√≠	Ajustes m√≠nimos
Mux + codificador (v6835fc, veecece)	Seleccionar qu√© registro expone el perif√©rico	Ninguno: son puro combinacional en clk_sys.
Flip-flop de ‚Äòbusy‚Äô (v58ed2b)	1 bit sincronizado a clk_sys que refleja busy_i2c_sync	Sencillamente conecta la salida de la FSM (sincronizada).
AND de ack (vb2090f + NOT)	bus_data_enable = i2c_cs ‚àß ¬¨busy_sync	Sustituye ¬¨reg_dat_wait por ¬¨busy_sync.
RAM de 1 kB (v33720b_v0ae20e)	Ejemplo de memoria dual puerto S √ó C, un lado escribe y otro lee	Para I¬≤C basta con un registro, pero la idea es la misma.
3. Clock-domain crossing (CDC) en 2 se√±ales

// dominio clk_sys  ----------------------------
reg start_sys;
always @(posedge clk_sys)
    if (cs && we && addr==START) start_sys <= 1'b1;
    else if (ack_sys)            start_sys <= 1'b0;

// sincr. a clk_i2c ----------------------------
reg start_i2c_meta, start_i2c;
always @(posedge clk_i2c) begin
    start_i2c_meta <= start_sys;
    start_i2c      <= start_i2c_meta;
end
wire start_pulse_i2c = start_i2c & ~start_i2c_d; // flanco detectado

// idem para BUSY -> dominio sys
reg  busy_i2c, busy_i2c_sync_meta, busy_sys;
...
always @(posedge clk_sys) begin
    busy_i2c_sync_meta <= busy_i2c;
    busy_sys           <= busy_i2c_sync_meta;
end

Con estos dos cables (start, busy) y, si lo necesitas, un FIFO de 1 palabra para DATA_OUT, la
frontera de reloj queda resuelta sin metastabilidad.
4. Lectura diferida ‚â† ‚Äúpush‚Äù al procesador

    En memory-mapped I/O nunca se ‚Äúempujan‚Äù datos; el core es quien lee cuando quiera.

    El perif√©rico s√≥lo actualiza sus registros internos y baja busy.

    Que el software los vea o no depende de cu√°ndo haga la lectura.

Esto ya pasa con la UART: el registro reg_dat_do se llena cuando llega un byte, pero el
RISC-V lo ve √∫nicamente al ejecutar lw xN, 0(UART_BASE).
Conclusi√≥n

    S√≠ es posible (y habitual) que la FSM I¬≤C corra con su propio reloj mientras la CPU sigue ejecutando c√≥digo.

    Usa el mismo wait/ack que la UART:
    i2c_cs mantiene la selecci√≥n; busy_sync impide el ACK; al terminar, bus_data_enable libera el bus.

    Los datos recibidos quedan en registros dentro del dominio clk_sys; el procesador los leer√° cuando acceda.

    El dise√±o de tu RAM y de la UART ya contienen todos los bloques l√≥gicos que necesitas ‚Äîsolo hay que conectarlos con una buena sincronizaci√≥n de reloj.

You said:
Por el momento, vamos a concentrarnos en la interfaz. Este es el dise√±o actual.

parameter W_SLV_ADDR        = 3'b000;  // 0x04000000
parameter W_RW              = 3'b001;  // 0x04000004
parameter W_N_PQTS          = 3'b010;  // 0x04000008
parameter R_STATE           = 3'b011;  // 0x0400000C
parameter R_BUSY            = 3'b100;  // 0x04000010
parameter R_DATA_OUT        = 3'b101;  // 0x04000014
parameter S_ENABLE          = 3'b110;  // 0x04000018
parameter W_DATA_WRITE      = 3'b111;  // 0x0400001C

// √çndice en el array de registros
parameter slv_addr_register         = 0;
parameter rw_register               = 1;
parameter num_pqts_register         = 2;
parameter state_register            = 3;
parameter busy_register             = 4;
parameter data_out_register         = 5;
parameter enable_register           = 6;
parameter bus_data_enable_register  = 7;


//Entrada desde bus de datos
reg [7:0] dataArray [7:0];
reg [31:0] buffer_data_out;
reg [31:0] data_wr = 32'b0;

assign slv_addr[6:0] = dataArray[slv_addr_register][6:0];      
assign rw = dataArray[rw_register][0];                   
assign n_paquetes[2:0] = dataArray[num_pqts_register][2:0];    

assign enable_start = dataArray[enable_register][0];                                    
assign bus_data_enable = dataArray[bus_data_enable_register][0];      

assign data_write = data_wr;             
assign bus_data_out = buffer_data_out;     
assign check = dataArray[W_N_PQTS];

wire serdat_write = valid;

always @(posedge clk or negedge rstn) begin
    if (!rstn) begin
        // Reset completo de los registros
        dataArray[0] <= 8'b0;
        dataArray[1] <= 8'b0;
        dataArray[2] <= 8'b0;
        dataArray[3] <= 8'b0;
        dataArray[4] <= 8'b0;
        dataArray[5] <= 8'b0;
        dataArray[6] <= 8'b0;
        dataArray[7] <= 8'b0;
        buffer_data_out <= 32'b0;
        data_wr <= 32'b0;

    end else begin
        // Registros actualizados por hardware (FSM)
        dataArray[state_register]    <= {4'b0, I2C_State};
        dataArray[busy_register]     <= {7'b0, I2C_Busy};
        dataArray[data_out_register] <= data_out;
        

        // Interfaz externa desde CPU
        if (serdat_cs) begin
        dataArray[bus_data_enable_register] <= !dataArray[bus_data_enable_register];
            if (serdat_write) begin
                // ----------- ESCRITURA -----------
                if (Bus_addr[4:2] == W_DATA_WRITE) begin
                    data_wr <= Bus_data;
                end else begin
                    dataArray[Bus_addr[4:2]] <= Bus_data[7:0];
                end
            end else begin
                // ----------- LECTURA -----------
                buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
                dataArray[bus_data_enable_register] <= 8'b00000001;
            end
        end

        // Limpieza de registros de un solo ciclo
        dataArray[enable_register] <= 8'b0;
    end
end


Por el momento quiero poder escribir en los registros que despu√©s pasaremos a la fsm datos y que no congele la placa. C√≥mo podemos hacer esto?
ChatGPT said:
El problema real

    El core RISC-V mantiene valid (y por tanto serdat_cs) alto hasta que tu perif√©rico le devuelve un pulso de ‚Äúfin de ciclo‚Äù (bus_data_enable).

    En el c√≥digo de arriba ese pulso no existe:

    dataArray[bus_data_enable_register] <= !dataArray[bus_data_enable_register];

    ‚Äì unas veces queda todo el rato a 1, otras alterna 0/1 varios ciclos.
    ‚Äì el procesador no reconoce un flanco limpio ‚Üí se bloquea.

La UART y la RAM no se cuelgan porque emiten un ACK de 1 solo ciclo en cuanto han acabado la operaci√≥n.
Soluci√≥n paso-a-paso
1. Separa el ‚ÄúACK‚Äù de tu array de registros

No lo guardes dentro de dataArray; hazlo con un flip-flop dedicado.

reg ack_r;          // pulso a CLK del bus
assign bus_data_enable = ack_r;

2. Detecta el acceso y genera el pulso

always @(posedge clk or negedge rstn) begin
    if (!rstn)
        ack_r <= 1'b0;
    else begin
        if (serdat_cs)           // hay ciclo activo
            ack_r <= 1'b1;       // sube UNA vez
        else
            ack_r <= 1'b0;       // al siguiente ciclo vuelve a 0
    end
end

Con esto:

valid ‚îÄ‚îÄ‚ñà‚ñà‚ñà‚ñà‚ñà‚îÄ‚îÄ‚îÄ‚îÄ                (<‚Äì lo mantiene la CPU)
cs     ‚îÄ‚îÄ‚ñà‚ñà‚ñà‚ñà‚ñà‚îÄ‚îÄ‚îÄ‚îÄ
ack    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñà‚îÄ‚îÄ‚îÄ                (pulso de 1 ciclo)

y el core suelta el bus inmediatamente despu√©s.
3. Corrige la detecci√≥n de escritura / lectura

valid no distingue read de write. Usa la l√≠nea real WE (en tu top es v8859f4):

wire serdat_write = serdat_cs & WE;   // WE = 1 escritura

4. Escribe o lee sin tocar ack_r

if (serdat_cs) begin
    if (serdat_write) begin
        // -------- ESCRITURA ----------
        if (Bus_addr[4:2] == W_DATA_WRITE)
            data_wr <= Bus_data;
        else
            dataArray[Bus_addr[4:2]] <= Bus_data[7:0];
    end else begin
        // -------- LECTURA ------------
        buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
    end
end

    IMPORTANTE: ya no modificas dataArray[bus_data_enable_register].

5. Limpieza de ‚Äúun solo ciclo‚Äù

Sigue limpiando enable_start, pero NO toques ack_r aqu√≠; se autolimita solo:

dataArray[enable_register] <= 8'b0;

C√≥digo completo de la interfaz (resumen)

// ‚Ä¶ par√°metros, dataArray, etc ‚Ä¶

reg ack_r;                          // ‚Üê nuevo
assign bus_data_enable = ack_r;     // ‚Üê directo al bus

wire serdat_write = serdat_cs & WE; // WE viene del bus (v8859f4)

//--------------------------------------------------
always @(posedge clk or negedge rstn) begin
    if (!rstn) begin
        integer i;
        for (i=0;i<8;i=i+1) dataArray[i] <= 8'b0;
        buffer_data_out <= 32'b0;
        data_wr <= 32'b0;
        ack_r <= 1'b0;
    end else begin
        // 1) registros que escribe la FSM I¬≤C
        dataArray[state_register]    <= {4'b0, I2C_State};
        dataArray[busy_register]     <= {7'b0, I2C_Busy};
        dataArray[data_out_register] <= data_out;

        // 2) acceso desde CPU
        if (serdat_cs) begin
            // --- genera el ACK ---
            ack_r <= 1'b1;

            if (serdat_write) begin
                if (Bus_addr[4:2] == W_DATA_WRITE)
                    data_wr <= Bus_data;
                else
                    dataArray[Bus_addr[4:2]] <= Bus_data[7:0];
            end else begin
                buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
            end
        end else begin
            ack_r <= 1'b0;   // vuelve a 0 autom√°ticamente
        end

        // 3) flags de un solo ciclo
        dataArray[enable_register] <= 8'b0;
    end
end

Qu√© has conseguido

    La CPU nunca se congela: siempre recibe un pulso de bus_data_enable en el mismo ciclo en que pone valid.

    Puedes escribir cualquier registro (W_SLV_ADDR, W_RW, ‚Ä¶) y la l√≥gica I¬≤C los ver√° en el siguiente reloj.

    Lecturas funcionan igual: el dato se copia a buffer_data_out, se emite el pulso y el procesador contin√∫a.

Cuando a√±adas la FSM I¬≤C s√≥lo tendr√°s que mantener I2C_Busy=1 mientras est√© transmitiendo; al ponerse a 0, ¬°la interfaz ya tiene todo el handshake listo!
You said:
jose@jose-NBLK-WAX9X:~/SE_Alhambra-II/Practicas/Practica3/Hardware$ cat McMENU.v 
// Code generated by Icestudio 0.12
// Fri, 18 Jul 2025 16:30:29 GMT

default_nettype none

//---- Top entity
module main #(
 parameter v6fa141 = 'h0400_0001,
 parameter ve6cd8f = 100000
) (
 input vclk,
 output vc8ba52,
 output v25ca25,
 output vf0c8ca,
 output v4cf3c7,
 output [7:0] v908c16,
 output vc96455,
 output [0:0] vinit,
 inout v90dcc6
);
 localparam p8 = v6fa141;
 localparam p9 = ve6cd8f;
 localparam p10 = v6fa141;
 wire w0;
 wire [0:31] w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire [0:7] w7;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire [0:31] w20;
 wire w21;
 wire [0:31] w22;
 wire [0:31] w23;
 wire [0:31] w24;
 wire w25;
 wire w26;
 assign v25ca25 = w0;
 assign w0 = v90dcc6;
 assign v4cf3c7 = w3;
 assign vc8ba52 = w4;
 assign vf0c8ca = w5;
 assign v908c16 = w7;
 assign w11 = v90dcc6;
 assign vc96455 = w12;
 assign w13 = vclk;
 assign w14 = vclk;
 assign w15 = vclk;
 assign w5 = w4;
 assign w11 = w0;
 assign w14 = w13;
 assign w15 = w13;
 assign w15 = w14;
 assign w17 = w16;
 assign w18 = w16;
 assign w18 = w17;
 assign w26 = w25;
 v35f267 v4e2e11 (
  .v0e28cb(w2),
  .vcbab45(w16)
 );
 v725d0b v5155a4 (
  .v9b328c(w1)
 );
 v87abc9 v4f46a0 (
  .vcbab45(w21),
  .vae8923(w26)
 );
 vaad680 v35feaf (
  .v29fe33(w1),
  .vba7c72(w13),
  .v5d0f7b(w16),
  .v006d37(w19),
  .vd67338(w20),
  .v9b0ff0(w21),
  .ve61aa7(w22),
  .v8fd87d(w23)
 );
 v5242e2 v8d6708 (
  .v493538(w23),
  .v917e97(w24),
  .vec88a9(w25)
 );
 v2b4233 vb8ec14 (
  .v6d0651(w2),
  .v4c8225(w14)
 );
 main_v3541f5 v3541f5 (
  .x(w3),
  .a(w6),
  .rst(w18)
 );
 v0c6f7c #(
  .vec4673(p8),
  .v9c4340(p9),
  .v8eaf13(p10)
 ) v562235 (
  .v9127c2(w4),
  .va77527(w6),
  .vaac567(w7),
  .v80923c(w11),
  .vf73703(w12),
  .v87186f(w15),
  .v4dc0ee(w17),
  .v8859f4(w19),
  .v867561(w20),
  .v23504b(w22),
  .v504d16(w24),
  .vfe2384(w25)
 );
 assign vinit = 1'b0;
endmodule

//---- Top entity
module v35f267 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v35f267_vd54ca1 vd54ca1 (
  .a(w0),
  .c(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta NOT
//---------------------------------------------------

module v35f267_vd54ca1 (
 input a,
 output c
);
 //-- Puerta NOT
 
 //-- module (input wire a, output wire c);
 
 
 assign c = ~a;
 
 
 //-- endmodule
 
endmodule
//---- Top entity
module v725d0b #(
 parameter vc5c8ea = 0
) (
 output [31:0] v9b328c
);
 localparam p0 = vc5c8ea;
 wire [0:31] w1;
 assign v9b328c = w1;
 v70cd06 #(
  .vc5c8ea(p0)
 ) v38acc0 (
  .v751a1b(w1)
 );
endmodule

//---------------------------------------------------
//-- Valor_00_32bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor constante 0, de 32 bits
//---------------------------------------------------
//---- Top entity
module v70cd06 #(
 parameter vc5c8ea = 0
) (
 output [31:0] v751a1b
);
 localparam p0 = vc5c8ea;
 wire [0:31] w1;
 assign v751a1b = w1;
 v70cd06_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- Constante-32bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor gen√©rico constante, de 32 bits. Su valor se introduce como par√°metro. Por defecto vale 0
//---------------------------------------------------

module v70cd06_v465065 #(
 parameter VALUE = 0
) (
 output [31:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module v87abc9 (
 input v0e28cb,
 input v3ca442,
 input v132c67,
 input v814e6e,
 input vae8923,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 assign w3 = v132c67;
 assign w4 = v814e6e;
 assign w5 = vae8923;
 v87abc9_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .o(w2),
  .c(w3),
  .d(w4),
  .e(w5)
 );
endmodule

//---------------------------------------------------
//-- OR-4
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta OR de 4 entradas
//---------------------------------------------------

module v87abc9_vf4938a (
 input a,
 input b,
 input c,
 input d,
 input e,
 output o
);
 //-- Puerta OR
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign o = a | b | c | d | e;
 
 //-- endmodule
endmodule
//---- Top entity
module vaad680 (
 input vba7c72,
 input v5d0f7b,
 input v9b0ff0,
 input [31:0] v8fd87d,
 input [31:0] v29fe33,
 output v006d37,
 output v88e319,
 output [31:0] vd67338,
 output [31:0] ve61aa7,
 output [3:0] v83dbbe
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire [0:31] w6;
 wire [0:31] w7;
 wire [0:31] w8;
 wire [0:31] w9;
 wire [0:3] w10;
 wire [0:31] w11;
 wire w12;
 wire [0:31] w13;
 wire [0:5] w14;
 wire [0:5] w15;
 wire [0:5] w16;
 wire [0:31] w17;
 assign w0 = vba7c72;
 assign w1 = vba7c72;
 assign v006d37 = w2;
 assign w3 = v5d0f7b;
 assign v88e319 = w4;
 assign w5 = v9b0ff0;
 assign vd67338 = w6;
 assign w7 = v8fd87d;
 assign ve61aa7 = w8;
 assign w9 = v29fe33;
 assign v83dbbe = w10;
 assign w1 = w0;
 vaad680_v3fb302 v3fb302 (
  .clk(w1),
  .rdata1(w11),
  .wen(w12),
  .rdata2(w13),
  .waddr(w14),
  .raddr1(w15),
  .raddr2(w16),
  .wdata(w17)
 );
 vaad680_vf1da6e vf1da6e (
  .clk(w0),
  .mem_valid(w2),
  .resetn(w3),
  .mem_instr(w4),
  .mem_ready(w5),
  .mem_addr(w6),
  .mem_rdata(w7),
  .mem_wdata(w8),
  .irq(w9),
  .mem_wstrb(w10),
  .cpuregs_rdata1(w11),
  .cpuregs_wen(w12),
  .cpuregs_rdata2(w13),
  .cpuregs_waddr(w14),
  .cpuregs_raddr1(w15),
  .cpuregs_raddr2(w16),
  .cpuregs_wrdata(w17)
 );
endmodule

//---------------------------------------------------
//-- RV32i
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Risc-v de 32Bits. Numeros enteros
//---------------------------------------------------

module vaad680_v3fb302 (
 input clk,
 input wen,
 input [5:0] waddr,
 input [5:0] raddr1,
 input [5:0] raddr2,
 input [31:0] wdata,
 output [31:0] rdata1,
 output [31:0] rdata2
);
 reg [31:0] regs [0:31];
 
 always @(posedge clk)
 	if (wen) regs[waddr[4:0]] <= wdata;
 
 assign rdata1 = regs[raddr1[4:0]];
 assign rdata2 = regs[raddr2[4:0]];
endmodule

module vaad680_vf1da6e (
 input clk,
 input resetn,
 input mem_ready,
 input [31:0] mem_rdata,
 input [31:0] irq,
 input [31:0] cpuregs_rdata1,
 input [31:0] cpuregs_rdata2,
 input pcpi_mul_wr,
 input [31:0] pcpi_mul_rd,
 input pcpi_mul_wait,
 input pcpi_mul_ready,
 input pcpi_div_wr,
 input [31:0] pcpi_div_rd,
 input pcpi_div_wait,
 input pcpi_div_ready,
 output mem_valid,
 output mem_instr,
 output [31:0] mem_addr,
 output [31:0] mem_wdata,
 output [3:0] mem_wstrb,
 output cpuregs_wen,
 output [5:0] cpuregs_waddr,
 output [5:0] cpuregs_raddr1,
 output [5:0] cpuregs_raddr2,
 output [31:0] cpuregs_wrdata,
 output pcpi_valid,
 output [31:0] pcpi_insn,
 output [31:0] pcpi_rs1,
 output [31:0] pcpi_rs2
);
 define PICORV32_REGS picosoc_regs
 
 
 parameter integer MEM_WORDS = 256;
 
 define PICORV32_V
 
 parameter [ 0:0] ENABLE_COUNTERS = 1;
 parameter [ 0:0] ENABLE_COUNTERS64 = 1;
 parameter [ 0:0] ENABLE_REGS_16_31 = 1;
 parameter [ 0:0] ENABLE_REGS_DUALPORT = 1;
 parameter [ 0:0] LATCHED_MEM_RDATA = 0;
 parameter [ 0:0] TWO_STAGE_SHIFT = 1;
 parameter [ 0:0] BARREL_SHIFTER = 1;
 parameter [ 0:0] TWO_CYCLE_COMPARE = 0;
 parameter [ 0:0] TWO_CYCLE_ALU = 0;
 parameter [ 0:0] COMPRESSED_ISA = 0;
 parameter [ 0:0] CATCH_MISALIGN = 1;
 parameter [ 0:0] CATCH_ILLINSN = 1;
 parameter [ 0:0] ENABLE_PCPI = 0;
 parameter [ 0:0] ENABLE_MUL = 0;
 parameter [ 0:0] ENABLE_FAST_MUL = 0;
 parameter [ 0:0] ENABLE_DIV = 0;
 parameter [ 0:0] ENABLE_IRQ = 1;
 parameter [ 0:0] ENABLE_IRQ_QREGS = 0;
 parameter [ 0:0] ENABLE_IRQ_TIMER = 1;
 parameter [ 0:0] ENABLE_TRACE = 0;
 parameter [ 0:0] REGS_INIT_ZERO = 0;
 parameter [31:0] MASKED_IRQ = 32'h 0000_0000;
 parameter [31:0] LATCHED_IRQ = 32'h ffff_ffff;
 parameter [31:0] PROGADDR_RESET = 32'h 0010_0000; // 1 MB into flash,
 parameter [31:0] PROGADDR_IRQ = 32'h 0000_0000;
 parameter [31:0] STACKADDR = (4*MEM_WORDS);       // end of memory
 
 
 reg mem_valid_i;
 assign mem_valid = mem_valid_i;
 reg mem_instr_i;
 assign mem_instr = mem_instr_i;
 reg [31:0] mem_addr_i;
 assign mem_addr = mem_addr_i;
 reg [31:0] mem_wdata_i;
 assign mem_wdata = mem_wdata_i;
 reg [ 3:0] mem_wstrb_i;
 assign mem_wstrb = mem_wstrb_i;
 reg [31:0] eoi;
 
 reg trap;
 
 
 // Pico Co-Processor Interface (PCPI)
 reg        pcpi_valid_i;
 assign pcpi_valid = pcpi_valid_i;
 reg [31:0] pcpi_insn_i;
 assign pcpi_insn = pcpi_insn_i;
 wire     pcpi_wr;
 wire [31:0] pcpi_rd;
 wire pcpi_wait;
 wire pcpi_ready;
 
 
 // Look-Ahead Interface
 wire            mem_la_read;
 wire            mem_la_write;
 wire     [31:0] mem_la_addr;
 reg [31:0] mem_la_wdata;
 reg [ 3:0] mem_la_wstrb;
 
 // Trace Interface
 reg        trace_valid;
 reg [35:0] trace_data;
 
 	localparam integer irq_timer = 0;
 	localparam integer irq_ebreak = 1;
 	localparam integer irq_buserror = 2;
 
 	localparam integer irqregs_offset = ENABLE_REGS_16_31 ? 32 : 16;
 	localparam integer regfile_size = (ENABLE_REGS_16_31 ? 32 : 16) + 4*ENABLE_IRQ*ENABLE_IRQ_QREGS;
 	localparam integer regindex_bits = (ENABLE_REGS_16_31 ? 5 : 4) + ENABLE_IRQ*ENABLE_IRQ_QREGS;
 
 	localparam WITH_PCPI = ENABLE_PCPI || ENABLE_MUL || ENABLE_FAST_MUL || ENABLE_DIV;
 
 	localparam [35:0] TRACE_BRANCH = {4'b 0001, 32'b 0};
 	localparam [35:0] TRACE_ADDR   = {4'b 0010, 32'b 0};
 	localparam [35:0] TRACE_IRQ    = {4'b 1000, 32'b 0};
 
 //-- A√±adido para instanciar los registros
 assign cpuregs_wen = resetn && cpuregs_write && latched_rd;
 
 //FORMAL_KEEP:
 reg [63:0] dbg_ascii_instr;
 reg [31:0] dbg_insn_imm;
 reg [4:0] dbg_insn_rs1;
 reg [4:0] dbg_insn_rs2;
 reg [4:0] dbg_insn_rd;
 reg [31:0] dbg_rs1val;
 reg [31:0] dbg_rs2val;
 reg dbg_rs1val_valid;
 reg dbg_rs2val_valid;
 reg [127:0] dbg_ascii_state;
 
 	reg [63:0] count_cycle, count_instr;
 	reg [31:0] reg_pc, reg_next_pc, reg_op1, reg_op2, reg_out;
 	reg [4:0] reg_sh;
 
 	reg [31:0] next_insn_opcode;
 	reg [31:0] dbg_insn_opcode;
 	reg [31:0] dbg_insn_addr;
 
 	wire dbg_mem_valid = mem_valid_i;
 	wire dbg_mem_instr = mem_instr_i;
 	wire dbg_mem_ready = mem_ready;
 	wire [31:0] dbg_mem_addr  = mem_addr_i;
 	wire [31:0] dbg_mem_wdata = mem_wdata_i;
 	wire [ 3:0] dbg_mem_wstrb = mem_wstrb_i;
 	wire [31:0] dbg_mem_rdata = mem_rdata;
 
 	assign pcpi_rs1 = reg_op1;
 	assign pcpi_rs2 = reg_op2;
 
 	wire [31:0] next_pc;
 
 	reg irq_delay;
 	reg irq_active;
 	reg [31:0] irq_mask;
 	reg [31:0] irq_pending;
 	reg [31:0] timer;
 
 ifndef PICORV32_REGS
 	reg [31:0] cpuregs [0:regfile_size-1];
 
 	integer i;
 	initial begin
 		if (REGS_INIT_ZERO) begin
 			for (i = 0; i < regfile_size; i = i+1)
 				cpuregs[i] = 0;
 		end
 	end
 endif
 
 	task empty_statement;
 		// This task is used by the assert directive in non-formal mode to
 		// avoid empty statement (which are unsupported by plain Verilog syntax).
 		begin end
 	endtask
 
 ifdef DEBUGREGS
 	wire [31:0] dbg_reg_x0  = 0;
 	wire [31:0] dbg_reg_x1  = cpuregs[1];
 	wire [31:0] dbg_reg_x2  = cpuregs[2];
 	wire [31:0] dbg_reg_x3  = cpuregs[3];
 	wire [31:0] dbg_reg_x4  = cpuregs[4];
 	wire [31:0] dbg_reg_x5  = cpuregs[5];
 	wire [31:0] dbg_reg_x6  = cpuregs[6];
 	wire [31:0] dbg_reg_x7  = cpuregs[7];
 	wire [31:0] dbg_reg_x8  = cpuregs[8];
 	wire [31:0] dbg_reg_x9  = cpuregs[9];
 	wire [31:0] dbg_reg_x10 = cpuregs[10];
 	wire [31:0] dbg_reg_x11 = cpuregs[11];
 	wire [31:0] dbg_reg_x12 = cpuregs[12];
 	wire [31:0] dbg_reg_x13 = cpuregs[13];
 	wire [31:0] dbg_reg_x14 = cpuregs[14];
 	wire [31:0] dbg_reg_x15 = cpuregs[15];
 	wire [31:0] dbg_reg_x16 = cpuregs[16];
 	wire [31:0] dbg_reg_x17 = cpuregs[17];
 	wire [31:0] dbg_reg_x18 = cpuregs[18];
 	wire [31:0] dbg_reg_x19 = cpuregs[19];
 	wire [31:0] dbg_reg_x20 = cpuregs[20];
 	wire [31:0] dbg_reg_x21 = cpuregs[21];
 	wire [31:0] dbg_reg_x22 = cpuregs[22];
 	wire [31:0] dbg_reg_x23 = cpuregs[23];
 	wire [31:0] dbg_reg_x24 = cpuregs[24];
 	wire [31:0] dbg_reg_x25 = cpuregs[25];
 	wire [31:0] dbg_reg_x26 = cpuregs[26];
 	wire [31:0] dbg_reg_x27 = cpuregs[27];
 	wire [31:0] dbg_reg_x28 = cpuregs[28];
 	wire [31:0] dbg_reg_x29 = cpuregs[29];
 	wire [31:0] dbg_reg_x30 = cpuregs[30];
 	wire [31:0] dbg_reg_x31 = cpuregs[31];
 endif
 
 	// Internal PCPI Cores
 
 	reg        pcpi_int_wr;
 	reg [31:0] pcpi_int_rd;
 	reg        pcpi_int_wait;
 	reg        pcpi_int_ready;
 
 	generate if (ENABLE_FAST_MUL) begin
 		picorv32_pcpi_fast_mul pcpi_mul (
 			.clk       (clk            ),
 			.resetn    (resetn         ),
 			.pcpi_valid(pcpi_valid_i     ),
 			.pcpi_insn (pcpi_insn_i      ),
 			.pcpi_rs1  (pcpi_rs1       ),
 			.pcpi_rs2  (pcpi_rs2       ),
 			.pcpi_wr   (pcpi_mul_wr    ),
 			.pcpi_rd   (pcpi_mul_rd    ),
 			.pcpi_wait (pcpi_mul_wait  ),
 			.pcpi_ready(pcpi_mul_ready )
 		);
 	end else if (ENABLE_MUL) begin
 		
 	end else begin
 		assign pcpi_mul_wr = 0;
 		assign pcpi_mul_rd = 32'bx;
 		assign pcpi_mul_wait = 0;
 		assign pcpi_mul_ready = 0;
 	end endgenerate
 
 	generate if (ENABLE_DIV) begin
 		
 	end else begin
 		assign pcpi_div_wr = 0;
 		assign pcpi_div_rd = 32'bx;
 		assign pcpi_div_wait = 0;
 		assign pcpi_div_ready = 0;
 	end endgenerate
 
 	always @* begin
 		pcpi_int_wr = 0;
 		pcpi_int_rd = 32'bx;
 		pcpi_int_wait  = |{ENABLE_PCPI && pcpi_wait,  (ENABLE_MUL || ENABLE_FAST_MUL) && pcpi_mul_wait,  ENABLE_DIV && pcpi_div_wait};
 		pcpi_int_ready = |{ENABLE_PCPI && pcpi_ready, (ENABLE_MUL || ENABLE_FAST_MUL) && pcpi_mul_ready, ENABLE_DIV && pcpi_div_ready};
 
 		(* parallel_case *)
 		case (1'b1)
 			ENABLE_PCPI && pcpi_ready: begin
 				pcpi_int_wr = ENABLE_PCPI ? pcpi_wr : 0;
 				pcpi_int_rd = ENABLE_PCPI ? pcpi_rd : 0;
 			end
 			(ENABLE_MUL || ENABLE_FAST_MUL) && pcpi_mul_ready: begin
 				pcpi_int_wr = pcpi_mul_wr;
 				pcpi_int_rd = pcpi_mul_rd;
 			end
 			ENABLE_DIV && pcpi_div_ready: begin
 				pcpi_int_wr = pcpi_div_wr;
 				pcpi_int_rd = pcpi_div_rd;
 			end
 		endcase
 	end
 
 
 	// Memory Interface
 
 	reg [1:0] mem_state;
 	reg [1:0] mem_wordsize;
 	reg [31:0] mem_rdata_word;
 	reg [31:0] mem_rdata_q;
 	reg mem_do_prefetch;
 	reg mem_do_rinst;
 	reg mem_do_rdata;
 	reg mem_do_wdata;
 
 	wire mem_xfer;
 	reg mem_la_secondword, mem_la_firstword_reg, last_mem_valid;
 	wire mem_la_firstword = COMPRESSED_ISA && (mem_do_prefetch || mem_do_rinst) && next_pc[1] && !mem_la_secondword;
 	wire mem_la_firstword_xfer = COMPRESSED_ISA && mem_xfer && (!last_mem_valid ? mem_la_firstword : mem_la_firstword_reg);
 
 	reg prefetched_high_word;
 	reg clear_prefetched_high_word;
 	reg [15:0] mem_16bit_buffer;
 
 	wire [31:0] mem_rdata_latched_noshuffle;
 	wire [31:0] mem_rdata_latched;
 
 	wire mem_la_use_prefetched_high_word = COMPRESSED_ISA && mem_la_firstword && prefetched_high_word && !clear_prefetched_high_word;
 	assign mem_xfer = (mem_valid_i && mem_ready) || (mem_la_use_prefetched_high_word && mem_do_rinst);
 
 	wire mem_busy = |{mem_do_prefetch, mem_do_rinst, mem_do_rdata, mem_do_wdata};
 	wire mem_done = resetn && ((mem_xfer && |mem_state && (mem_do_rinst || mem_do_rdata || mem_do_wdata)) || (&mem_state && mem_do_rinst)) &&
 			(!mem_la_firstword || (~&mem_rdata_latched[1:0] && mem_xfer));
 
 	assign mem_la_write = resetn && !mem_state && mem_do_wdata;
 	assign mem_la_read = resetn && ((!mem_la_use_prefetched_high_word && !mem_state && (mem_do_rinst || mem_do_prefetch || mem_do_rdata)) ||
 			(COMPRESSED_ISA && mem_xfer && (!last_mem_valid ? mem_la_firstword : mem_la_firstword_reg) && !mem_la_secondword && &mem_rdata_latched[1:0]));
 	assign mem_la_addr = (mem_do_prefetch || mem_do_rinst) ? {next_pc[31:2] + mem_la_firstword_xfer, 2'b00} : {reg_op1[31:2], 2'b00};
 
 	assign mem_rdata_latched_noshuffle = (mem_xfer || LATCHED_MEM_RDATA) ? mem_rdata : mem_rdata_q;
 
 	assign mem_rdata_latched = COMPRESSED_ISA && mem_la_use_prefetched_high_word ? {16'bx, mem_16bit_buffer} :
 			COMPRESSED_ISA && mem_la_secondword ? {mem_rdata_latched_noshuffle[15:0], mem_16bit_buffer} :
 			COMPRESSED_ISA && mem_la_firstword ? {16'bx, mem_rdata_latched_noshuffle[31:16]} : mem_rdata_latched_noshuffle;
 
 	always @(posedge clk) begin
 		if (!resetn) begin
 			mem_la_firstword_reg <= 0;
 			last_mem_valid <= 0;
 		end else begin
 			if (!last_mem_valid)
 				mem_la_firstword_reg <= mem_la_firstword;
 			last_mem_valid <= mem_valid_i && !mem_ready;
 		end
 	end
 
 	always @* begin
 		(* full_case *)
 		case (mem_wordsize)
 			0: begin
 				mem_la_wdata = reg_op2;
 				mem_la_wstrb = 4'b1111;
 				mem_rdata_word = mem_rdata;
 			end
 			1: begin
 				mem_la_wdata = {2{reg_op2[15:0]}};
 				mem_la_wstrb = reg_op1[1] ? 4'b1100 : 4'b0011;
 				case (reg_op1[1])
 					1'b0: mem_rdata_word = {16'b0, mem_rdata[15: 0]};
 					1'b1: mem_rdata_word = {16'b0, mem_rdata[31:16]};
 				endcase
 			end
 			2: begin
 				mem_la_wdata = {4{reg_op2[7:0]}};
 				mem_la_wstrb = 4'b0001 << reg_op1[1:0];
 				case (reg_op1[1:0])
 					2'b00: mem_rdata_word = {24'b0, mem_rdata[ 7: 0]};
 					2'b01: mem_rdata_word = {24'b0, mem_rdata[15: 8]};
 					2'b10: mem_rdata_word = {24'b0, mem_rdata[23:16]};
 					2'b11: mem_rdata_word = {24'b0, mem_rdata[31:24]};
 				endcase
 			end
 		endcase
 	end
 
 	always @(posedge clk) begin
 		if (mem_xfer) begin
 			mem_rdata_q <= COMPRESSED_ISA ? mem_rdata_latched : mem_rdata;
 			next_insn_opcode <= COMPRESSED_ISA ? mem_rdata_latched : mem_rdata;
 		end
 
 		if (COMPRESSED_ISA && mem_done && (mem_do_prefetch || mem_do_rinst)) begin
 			case (mem_rdata_latched[1:0])
 				2'b00: begin // Quadrant 0
 					case (mem_rdata_latched[15:13])
 						3'b000: begin // C.ADDI4SPN
 							mem_rdata_q[14:12] <= 3'b000;
 							mem_rdata_q[31:20] <= {2'b0, mem_rdata_latched[10:7], mem_rdata_latched[12:11], mem_rdata_latched[5], mem_rdata_latched[6], 2'b00};
 						end
 						3'b010: begin // C.LW
 							mem_rdata_q[31:20] <= {5'b0, mem_rdata_latched[5], mem_rdata_latched[12:10], mem_rdata_latched[6], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 						3'b 110: begin // C.SW
 							{mem_rdata_q[31:25], mem_rdata_q[11:7]} <= {5'b0, mem_rdata_latched[5], mem_rdata_latched[12:10], mem_rdata_latched[6], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 					endcase
 				end
 				2'b01: begin // Quadrant 1
 					case (mem_rdata_latched[15:13])
 						3'b 000: begin // C.ADDI
 							mem_rdata_q[14:12] <= 3'b000;
 							mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 						end
 						3'b 010: begin // C.LI
 							mem_rdata_q[14:12] <= 3'b000;
 							mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 						end
 						3'b 011: begin
 							if (mem_rdata_latched[11:7] == 2) begin // C.ADDI16SP
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[4:3],
 										mem_rdata_latched[5], mem_rdata_latched[2], mem_rdata_latched[6], 4'b 0000});
 							end else begin // C.LUI
 								mem_rdata_q[31:12] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 							end
 						end
 						3'b100: begin
 							if (mem_rdata_latched[11:10] == 2'b00) begin // C.SRLI
 								mem_rdata_q[31:25] <= 7'b0000000;
 								mem_rdata_q[14:12] <= 3'b 101;
 							end
 							if (mem_rdata_latched[11:10] == 2'b01) begin // C.SRAI
 								mem_rdata_q[31:25] <= 7'b0100000;
 								mem_rdata_q[14:12] <= 3'b 101;
 							end
 							if (mem_rdata_latched[11:10] == 2'b10) begin // C.ANDI
 								mem_rdata_q[14:12] <= 3'b111;
 								mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 							end
 							if (mem_rdata_latched[12:10] == 3'b011) begin // C.SUB, C.XOR, C.OR, C.AND
 								if (mem_rdata_latched[6:5] == 2'b00) mem_rdata_q[14:12] <= 3'b000;
 								if (mem_rdata_latched[6:5] == 2'b01) mem_rdata_q[14:12] <= 3'b100;
 								if (mem_rdata_latched[6:5] == 2'b10) mem_rdata_q[14:12] <= 3'b110;
 								if (mem_rdata_latched[6:5] == 2'b11) mem_rdata_q[14:12] <= 3'b111;
 								mem_rdata_q[31:25] <= mem_rdata_latched[6:5] == 2'b00 ? 7'b0100000 : 7'b0000000;
 							end
 						end
 						3'b 110: begin // C.BEQZ
 							mem_rdata_q[14:12] <= 3'b000;
 							{ mem_rdata_q[31], mem_rdata_q[7], mem_rdata_q[30:25], mem_rdata_q[11:8] } <=
 									$signed({mem_rdata_latched[12], mem_rdata_latched[6:5], mem_rdata_latched[2],
 											mem_rdata_latched[11:10], mem_rdata_latched[4:3]});
 						end
 						3'b 111: begin // C.BNEZ
 							mem_rdata_q[14:12] <= 3'b001;
 							{ mem_rdata_q[31], mem_rdata_q[7], mem_rdata_q[30:25], mem_rdata_q[11:8] } <=
 									$signed({mem_rdata_latched[12], mem_rdata_latched[6:5], mem_rdata_latched[2],
 											mem_rdata_latched[11:10], mem_rdata_latched[4:3]});
 						end
 					endcase
 				end
 				2'b10: begin // Quadrant 2
 					case (mem_rdata_latched[15:13])
 						3'b000: begin // C.SLLI
 							mem_rdata_q[31:25] <= 7'b0000000;
 							mem_rdata_q[14:12] <= 3'b 001;
 						end
 						3'b010: begin // C.LWSP
 							mem_rdata_q[31:20] <= {4'b0, mem_rdata_latched[3:2], mem_rdata_latched[12], mem_rdata_latched[6:4], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 						3'b100: begin
 							if (mem_rdata_latched[12] == 0 && mem_rdata_latched[6:2] == 0) begin // C.JR
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:20] <= 12'b0;
 							end
 							if (mem_rdata_latched[12] == 0 && mem_rdata_latched[6:2] != 0) begin // C.MV
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:25] <= 7'b0000000;
 							end
 							if (mem_rdata_latched[12] != 0 && mem_rdata_latched[11:7] != 0 && mem_rdata_latched[6:2] == 0) begin // C.JALR
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:20] <= 12'b0;
 							end
 							if (mem_rdata_latched[12] != 0 && mem_rdata_latched[6:2] != 0) begin // C.ADD
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:25] <= 7'b0000000;
 							end
 						end
 						3'b110: begin // C.SWSP
 							{mem_rdata_q[31:25], mem_rdata_q[11:7]} <= {4'b0, mem_rdata_latched[8:7], mem_rdata_latched[12:9], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 					endcase
 				end
 			endcase
 		end
 	end
 /*
 	always @(posedge clk) begin
 		if (resetn && !trap) begin
 			if (mem_do_prefetch || mem_do_rinst || mem_do_rdata)
 				//assert(!mem_do_wdata);
 
 			if (mem_do_prefetch || mem_do_rinst)
 				//assert(!mem_do_rdata);
 
 			if (mem_do_rdata)
 				//assert(!mem_do_prefetch && !mem_do_rinst);
 
 			if (mem_do_wdata)
 				//assert(!(mem_do_prefetch || mem_do_rinst || mem_do_rdata));
 
 			if (mem_state == 2 || mem_state == 3)
 				//assert(mem_valid || mem_do_prefetch);
 		end
 	end*/
 
 	always @(posedge clk) begin
 		if (!resetn || trap) begin
 			if (!resetn)
 				mem_state <= 0;
 			if (!resetn || mem_ready)
 				mem_valid_i <= 0;
 			mem_la_secondword <= 0;
 			prefetched_high_word <= 0;
 		end else begin
 			if (mem_la_read || mem_la_write) begin
 				mem_addr_i <= mem_la_addr;
 				mem_wstrb_i <= mem_la_wstrb & {4{mem_la_write}};
 			end
 			if (mem_la_write) begin
 				mem_wdata_i <= mem_la_wdata;
 			end
 			case (mem_state)
 				0: begin
 					if (mem_do_prefetch || mem_do_rinst || mem_do_rdata) begin
 						mem_valid_i <= !mem_la_use_prefetched_high_word;
 						mem_instr_i <= mem_do_prefetch || mem_do_rinst;
 						mem_wstrb_i <= 0;
 						mem_state <= 1;
 					end
 					if (mem_do_wdata) begin
 						mem_valid_i <= 1;
 						mem_instr_i <= 0;
 						mem_state <= 2;
 					end
 				end
 				1: begin
 					//assert(mem_wstrb == 0);
 					//assert(mem_do_prefetch || mem_do_rinst || mem_do_rdata);
 					//assert(mem_valid == !mem_la_use_prefetched_high_word);
 					//assert(mem_instr == (mem_do_prefetch || mem_do_rinst));
 					if (mem_xfer) begin
 						if (COMPRESSED_ISA && mem_la_read) begin
 							mem_valid_i <= 1;
 							mem_la_secondword <= 1;
 							if (!mem_la_use_prefetched_high_word)
 								mem_16bit_buffer <= mem_rdata[31:16];
 						end else begin
 							mem_valid_i <= 0;
 							mem_la_secondword <= 0;
 							if (COMPRESSED_ISA && !mem_do_rdata) begin
 								if (~&mem_rdata[1:0] || mem_la_secondword) begin
 									mem_16bit_buffer <= mem_rdata[31:16];
 									prefetched_high_word <= 1;
 								end else begin
 									prefetched_high_word <= 0;
 								end
 							end
 							mem_state <= mem_do_rinst || mem_do_rdata ? 0 : 3;
 						end
 					end
 				end
 				2: begin
 					//assert(mem_wstrb != 0);
 					//assert(mem_do_wdata);
 					if (mem_xfer) begin
 						mem_valid_i <= 0;
 						mem_state <= 0;
 					end
 				end
 				3: begin
 					//assert(mem_wstrb == 0);
 					//assert(mem_do_prefetch);
 					if (mem_do_rinst) begin
 						mem_state <= 0;
 					end
 				end
 			endcase
 		end
 
 		if (clear_prefetched_high_word)
 			prefetched_high_word <= 0;
 	end
 
 
 	// Instruction Decoder
 
 	reg instr_lui, instr_auipc, instr_jal, instr_jalr;
 	reg instr_beq, instr_bne, instr_blt, instr_bge, instr_bltu, instr_bgeu;
 	reg instr_lb, instr_lh, instr_lw, instr_lbu, instr_lhu, instr_sb, instr_sh, instr_sw;
 	reg instr_addi, instr_slti, instr_sltiu, instr_xori, instr_ori, instr_andi, instr_slli, instr_srli, instr_srai;
 	reg instr_add, instr_sub, instr_sll, instr_slt, instr_sltu, instr_xor, instr_srl, instr_sra, instr_or, instr_and;
 	reg instr_rdcycle, instr_rdcycleh, instr_rdinstr, instr_rdinstrh, instr_ecall_ebreak;
 	reg instr_getq, instr_setq, instr_retirq, instr_maskirq, instr_waitirq, instr_timer;
 	wire instr_trap;
 
 	reg [regindex_bits-1:0] decoded_rd, decoded_rs1, decoded_rs2;
 	reg [31:0] decoded_imm, decoded_imm_uj;
 	reg decoder_trigger;
 	reg decoder_trigger_q;
 	reg decoder_pseudo_trigger;
 	reg decoder_pseudo_trigger_q;
 	reg compressed_instr;
 
 	reg is_lui_auipc_jal;
 	reg is_lb_lh_lw_lbu_lhu;
 	reg is_slli_srli_srai;
 	reg is_jalr_addi_slti_sltiu_xori_ori_andi;
 	reg is_sb_sh_sw;
 	reg is_sll_srl_sra;
 	reg is_lui_auipc_jal_jalr_addi_add_sub;
 	reg is_slti_blt_slt;
 	reg is_sltiu_bltu_sltu;
 	reg is_beq_bne_blt_bge_bltu_bgeu;
 	reg is_lbu_lhu_lw;
 	reg is_alu_reg_imm;
 	reg is_alu_reg_reg;
 	reg is_compare;
 
 	assign instr_trap = (CATCH_ILLINSN || WITH_PCPI) && !{instr_lui, instr_auipc, instr_jal, instr_jalr,
 			instr_beq, instr_bne, instr_blt, instr_bge, instr_bltu, instr_bgeu,
 			instr_lb, instr_lh, instr_lw, instr_lbu, instr_lhu, instr_sb, instr_sh, instr_sw,
 			instr_addi, instr_slti, instr_sltiu, instr_xori, instr_ori, instr_andi, instr_slli, instr_srli, instr_srai,
 			instr_add, instr_sub, instr_sll, instr_slt, instr_sltu, instr_xor, instr_srl, instr_sra, instr_or, instr_and,
 			instr_rdcycle, instr_rdcycleh, instr_rdinstr, instr_rdinstrh,
 			instr_getq, instr_setq, instr_retirq, instr_maskirq, instr_waitirq, instr_timer};
 
 	wire is_rdcycle_rdcycleh_rdinstr_rdinstrh;
 	assign is_rdcycle_rdcycleh_rdinstr_rdinstrh = |{instr_rdcycle, instr_rdcycleh, instr_rdinstr, instr_rdinstrh};
 
 	reg [63:0] new_ascii_instr;
 	/*
 	FORMAL_KEEP reg [63:0] dbg_ascii_instr;
 	FORMAL_KEEP reg [31:0] dbg_insn_imm;
 	FORMAL_KEEP reg [4:0] dbg_insn_rs1;
 	FORMAL_KEEP reg [4:0] dbg_insn_rs2;
 	FORMAL_KEEP reg [4:0] dbg_insn_rd;
 	FORMAL_KEEP reg [31:0] dbg_rs1val;
 	FORMAL_KEEP reg [31:0] dbg_rs2val;
 	FORMAL_KEEP reg dbg_rs1val_valid;
 	FORMAL_KEEP reg dbg_rs2val_valid;*/
 
 	always @* begin
 		new_ascii_instr = "";
 
 		if (instr_lui)      new_ascii_instr = "lui";
 		if (instr_auipc)    new_ascii_instr = "auipc";
 		if (instr_jal)      new_ascii_instr = "jal";
 		if (instr_jalr)     new_ascii_instr = "jalr";
 
 		if (instr_beq)      new_ascii_instr = "beq";
 		if (instr_bne)      new_ascii_instr = "bne";
 		if (instr_blt)      new_ascii_instr = "blt";
 		if (instr_bge)      new_ascii_instr = "bge";
 		if (instr_bltu)     new_ascii_instr = "bltu";
 		if (instr_bgeu)     new_ascii_instr = "bgeu";
 
 		if (instr_lb)       new_ascii_instr = "lb";
 		if (instr_lh)       new_ascii_instr = "lh";
 		if (instr_lw)       new_ascii_instr = "lw";
 		if (instr_lbu)      new_ascii_instr = "lbu";
 		if (instr_lhu)      new_ascii_instr = "lhu";
 		if (instr_sb)       new_ascii_instr = "sb";
 		if (instr_sh)       new_ascii_instr = "sh";
 		if (instr_sw)       new_ascii_instr = "sw";
 
 		if (instr_addi)     new_ascii_instr = "addi";
 		if (instr_slti)     new_ascii_instr = "slti";
 		if (instr_sltiu)    new_ascii_instr = "sltiu";
 		if (instr_xori)     new_ascii_instr = "xori";
 		if (instr_ori)      new_ascii_instr = "ori";
 		if (instr_andi)     new_ascii_instr = "andi";
 		if (instr_slli)     new_ascii_instr = "slli";
 		if (instr_srli)     new_ascii_instr = "srli";
 		if (instr_srai)     new_ascii_instr = "srai";
 
 		if (instr_add)      new_ascii_instr = "add";
 		if (instr_sub)      new_ascii_instr = "sub";
 		if (instr_sll)      new_ascii_instr = "sll";
 		if (instr_slt)      new_ascii_instr = "slt";
 		if (instr_sltu)     new_ascii_instr = "sltu";
 		if (instr_xor)      new_ascii_instr = "xor";
 		if (instr_srl)      new_ascii_instr = "srl";
 		if (instr_sra)      new_ascii_instr = "sra";
 		if (instr_or)       new_ascii_instr = "or";
 		if (instr_and)      new_ascii_instr = "and";
 
 		if (instr_rdcycle)  new_ascii_instr = "rdcycle";
 		if (instr_rdcycleh) new_ascii_instr = "rdcycleh";
 		if (instr_rdinstr)  new_ascii_instr = "rdinstr";
 		if (instr_rdinstrh) new_ascii_instr = "rdinstrh";
 
 		if (instr_getq)     new_ascii_instr = "getq";
 		if (instr_setq)     new_ascii_instr = "setq";
 		if (instr_retirq)   new_ascii_instr = "retirq";
 		if (instr_maskirq)  new_ascii_instr = "maskirq";
 		if (instr_waitirq)  new_ascii_instr = "waitirq";
 		if (instr_timer)    new_ascii_instr = "timer";
 	end
 
 	reg [63:0] q_ascii_instr;
 	reg [31:0] q_insn_imm;
 	reg [31:0] q_insn_opcode;
 	reg [4:0] q_insn_rs1;
 	reg [4:0] q_insn_rs2;
 	reg [4:0] q_insn_rd;
 	reg dbg_next;
 
 	wire launch_next_insn;
 	reg dbg_valid_insn;
 
 	reg [63:0] cached_ascii_instr;
 	reg [31:0] cached_insn_imm;
 	reg [31:0] cached_insn_opcode;
 	reg [4:0] cached_insn_rs1;
 	reg [4:0] cached_insn_rs2;
 	reg [4:0] cached_insn_rd;
 
 	always @(posedge clk) begin
 		q_ascii_instr <= dbg_ascii_instr;
 		q_insn_imm <= dbg_insn_imm;
 		q_insn_opcode <= dbg_insn_opcode;
 		q_insn_rs1 <= dbg_insn_rs1;
 		q_insn_rs2 <= dbg_insn_rs2;
 		q_insn_rd <= dbg_insn_rd;
 		dbg_next <= launch_next_insn;
 
 		if (!resetn || trap)
 			dbg_valid_insn <= 0;
 		else if (launch_next_insn)
 			dbg_valid_insn <= 1;
 
 		if (decoder_trigger_q) begin
 			cached_ascii_instr <= new_ascii_instr;
 			cached_insn_imm <= decoded_imm;
 			if (&next_insn_opcode[1:0])
 				cached_insn_opcode <= next_insn_opcode;
 			else
 				cached_insn_opcode <= {16'b0, next_insn_opcode[15:0]};
 			cached_insn_rs1 <= decoded_rs1;
 			cached_insn_rs2 <= decoded_rs2;
 			cached_insn_rd <= decoded_rd;
 		end
 
 		if (launch_next_insn) begin
 			dbg_insn_addr <= next_pc;
 		end
 	end
 
 	always @* begin
 		dbg_ascii_instr = q_ascii_instr;
 		dbg_insn_imm = q_insn_imm;
 		dbg_insn_opcode = q_insn_opcode;
 		dbg_insn_rs1 = q_insn_rs1;
 		dbg_insn_rs2 = q_insn_rs2;
 		dbg_insn_rd = q_insn_rd;
 
 		if (dbg_next) begin
 			if (decoder_pseudo_trigger_q) begin
 				dbg_ascii_instr = cached_ascii_instr;
 				dbg_insn_imm = cached_insn_imm;
 				dbg_insn_opcode = cached_insn_opcode;
 				dbg_insn_rs1 = cached_insn_rs1;
 				dbg_insn_rs2 = cached_insn_rs2;
 				dbg_insn_rd = cached_insn_rd;
 			end else begin
 				dbg_ascii_instr = new_ascii_instr;
 				if (&next_insn_opcode[1:0])
 					dbg_insn_opcode = next_insn_opcode;
 				else
 					dbg_insn_opcode = {16'b0, next_insn_opcode[15:0]};
 				dbg_insn_imm = decoded_imm;
 				dbg_insn_rs1 = decoded_rs1;
 				dbg_insn_rs2 = decoded_rs2;
 				dbg_insn_rd = decoded_rd;
 			end
 		end
 	end
 
 ifdef DEBUGASM
 	always @(posedge clk) begin
 		if (dbg_next) begin
 			$display("debugasm %x %x %s", dbg_insn_addr, dbg_insn_opcode, dbg_ascii_instr ? dbg_ascii_instr : "*");
 		end
 	end
 endif
 
 ifdef DEBUG
 	always @(posedge clk) begin
 		if (dbg_next) begin
 			if (&dbg_insn_opcode[1:0])
 				$display("DECODE: 0x%08x 0x%08x %-0s", dbg_insn_addr, dbg_insn_opcode, dbg_ascii_instr ? dbg_ascii_instr : "UNKNOWN");
 			else
 				$display("DECODE: 0x%08x     0x%04x %-0s", dbg_insn_addr, dbg_insn_opcode[15:0], dbg_ascii_instr ? dbg_ascii_instr : "UNKNOWN");
 		end
 	end
 endif
 
 	always @(posedge clk) begin
 		is_lui_auipc_jal <= |{instr_lui, instr_auipc, instr_jal};
 		is_lui_auipc_jal_jalr_addi_add_sub <= |{instr_lui, instr_auipc, instr_jal, instr_jalr, instr_addi, instr_add, instr_sub};
 		is_slti_blt_slt <= |{instr_slti, instr_blt, instr_slt};
 		is_sltiu_bltu_sltu <= |{instr_sltiu, instr_bltu, instr_sltu};
 		is_lbu_lhu_lw <= |{instr_lbu, instr_lhu, instr_lw};
 		is_compare <= |{is_beq_bne_blt_bge_bltu_bgeu, instr_slti, instr_slt, instr_sltiu, instr_sltu};
 
 		if (mem_do_rinst && mem_done) begin
 			instr_lui     <= mem_rdata_latched[6:0] == 7'b0110111;
 			instr_auipc   <= mem_rdata_latched[6:0] == 7'b0010111;
 			instr_jal     <= mem_rdata_latched[6:0] == 7'b1101111;
 			instr_jalr    <= mem_rdata_latched[6:0] == 7'b1100111 && mem_rdata_latched[14:12] == 3'b000;
 			instr_retirq  <= mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000010 && ENABLE_IRQ;
 			instr_waitirq <= mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000100 && ENABLE_IRQ;
 
 			is_beq_bne_blt_bge_bltu_bgeu <= mem_rdata_latched[6:0] == 7'b1100011;
 			is_lb_lh_lw_lbu_lhu          <= mem_rdata_latched[6:0] == 7'b0000011;
 			is_sb_sh_sw                  <= mem_rdata_latched[6:0] == 7'b0100011;
 			is_alu_reg_imm               <= mem_rdata_latched[6:0] == 7'b0010011;
 			is_alu_reg_reg               <= mem_rdata_latched[6:0] == 7'b0110011;
 
 			{ decoded_imm_uj[31:20], decoded_imm_uj[10:1], decoded_imm_uj[11], decoded_imm_uj[19:12], decoded_imm_uj[0] } <= $signed({mem_rdata_latched[31:12], 1'b0});
 
 			decoded_rd <= mem_rdata_latched[11:7];
 			decoded_rs1 <= mem_rdata_latched[19:15];
 			decoded_rs2 <= mem_rdata_latched[24:20];
 
 			if (mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000000 && ENABLE_IRQ && ENABLE_IRQ_QREGS)
 				decoded_rs1[regindex_bits-1] <= 1; // instr_getq
 
 			if (mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000010 && ENABLE_IRQ)
 				decoded_rs1 <= ENABLE_IRQ_QREGS ? irqregs_offset : 3; // instr_retirq
 
 			compressed_instr <= 0;
 			if (COMPRESSED_ISA && mem_rdata_latched[1:0] != 2'b11) begin
 				compressed_instr <= 1;
 				decoded_rd <= 0;
 				decoded_rs1 <= 0;
 				decoded_rs2 <= 0;
 
 				{ decoded_imm_uj[31:11], decoded_imm_uj[4], decoded_imm_uj[9:8], decoded_imm_uj[10], decoded_imm_uj[6],
 				  decoded_imm_uj[7], decoded_imm_uj[3:1], decoded_imm_uj[5], decoded_imm_uj[0] } <= $signed({mem_rdata_latched[12:2], 1'b0});
 
 				case (mem_rdata_latched[1:0])
 					2'b00: begin // Quadrant 0
 						case (mem_rdata_latched[15:13])
 							3'b000: begin // C.ADDI4SPN
 								is_alu_reg_imm <= |mem_rdata_latched[12:5];
 								decoded_rs1 <= 2;
 								decoded_rd <= 8 + mem_rdata_latched[4:2];
 							end
 							3'b010: begin // C.LW
 								is_lb_lh_lw_lbu_lhu <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rd <= 8 + mem_rdata_latched[4:2];
 							end
 							3'b110: begin // C.SW
 								is_sb_sh_sw <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rs2 <= 8 + mem_rdata_latched[4:2];
 							end
 						endcase
 					end
 					2'b01: begin // Quadrant 1
 						case (mem_rdata_latched[15:13])
 							3'b000: begin // C.NOP / C.ADDI
 								is_alu_reg_imm <= 1;
 								decoded_rd <= mem_rdata_latched[11:7];
 								decoded_rs1 <= mem_rdata_latched[11:7];
 							end
 							3'b001: begin // C.JAL
 								instr_jal <= 1;
 								decoded_rd <= 1;
 							end
 							3'b 010: begin // C.LI
 								is_alu_reg_imm <= 1;
 								decoded_rd <= mem_rdata_latched[11:7];
 								decoded_rs1 <= 0;
 							end
 							3'b 011: begin
 								if (mem_rdata_latched[12] || mem_rdata_latched[6:2]) begin
 									if (mem_rdata_latched[11:7] == 2) begin // C.ADDI16SP
 										is_alu_reg_imm <= 1;
 										decoded_rd <= mem_rdata_latched[11:7];
 										decoded_rs1 <= mem_rdata_latched[11:7];
 									end else begin // C.LUI
 										instr_lui <= 1;
 										decoded_rd <= mem_rdata_latched[11:7];
 										decoded_rs1 <= 0;
 									end
 								end
 							end
 							3'b100: begin
 								if (!mem_rdata_latched[11] && !mem_rdata_latched[12]) begin // C.SRLI, C.SRAI
 									is_alu_reg_imm <= 1;
 									decoded_rd <= 8 + mem_rdata_latched[9:7];
 									decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 									decoded_rs2 <= {mem_rdata_latched[12], mem_rdata_latched[6:2]};
 								end
 								if (mem_rdata_latched[11:10] == 2'b10) begin // C.ANDI
 									is_alu_reg_imm <= 1;
 									decoded_rd <= 8 + mem_rdata_latched[9:7];
 									decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								end
 								if (mem_rdata_latched[12:10] == 3'b011) begin // C.SUB, C.XOR, C.OR, C.AND
 									is_alu_reg_reg <= 1;
 									decoded_rd <= 8 + mem_rdata_latched[9:7];
 									decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 									decoded_rs2 <= 8 + mem_rdata_latched[4:2];
 								end
 							end
 							3'b101: begin // C.J
 								instr_jal <= 1;
 							end
 							3'b110: begin // C.BEQZ
 								is_beq_bne_blt_bge_bltu_bgeu <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rs2 <= 0;
 							end
 							3'b111: begin // C.BNEZ
 								is_beq_bne_blt_bge_bltu_bgeu <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rs2 <= 0;
 							end
 						endcase
 					end
 					2'b10: begin // Quadrant 2
 						case (mem_rdata_latched[15:13])
 							3'b000: begin // C.SLLI
 								if (!mem_rdata_latched[12]) begin
 									is_alu_reg_imm <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= mem_rdata_latched[11:7];
 									decoded_rs2 <= {mem_rdata_latched[12], mem_rdata_latched[6:2]};
 								end
 							end
 							3'b010: begin // C.LWSP
 								if (mem_rdata_latched[11:7]) begin
 									is_lb_lh_lw_lbu_lhu <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= 2;
 								end
 							end
 							3'b100: begin
 								if (mem_rdata_latched[12] == 0 && mem_rdata_latched[11:7] != 0 && mem_rdata_latched[6:2] == 0) begin // C.JR
 									instr_jalr <= 1;
 									decoded_rd <= 0;
 									decoded_rs1 <= mem_rdata_latched[11:7];
 								end
 								if (mem_rdata_latched[12] == 0 && mem_rdata_latched[6:2] != 0) begin // C.MV
 									is_alu_reg_reg <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= 0;
 									decoded_rs2 <= mem_rdata_latched[6:2];
 								end
 								if (mem_rdata_latched[12] != 0 && mem_rdata_latched[11:7] != 0 && mem_rdata_latched[6:2] == 0) begin // C.JALR
 									instr_jalr <= 1;
 									decoded_rd <= 1;
 									decoded_rs1 <= mem_rdata_latched[11:7];
 								end
 								if (mem_rdata_latched[12] != 0 && mem_rdata_latched[6:2] != 0) begin // C.ADD
 									is_alu_reg_reg <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= mem_rdata_latched[11:7];
 									decoded_rs2 <= mem_rdata_latched[6:2];
 								end
 							end
 							3'b110: begin // C.SWSP
 								is_sb_sh_sw <= 1;
 								decoded_rs1 <= 2;
 								decoded_rs2 <= mem_rdata_latched[6:2];
 							end
 						endcase
 					end
 				endcase
 			end
 		end
 
 		if (decoder_trigger && !decoder_pseudo_trigger) begin
 			pcpi_insn_i <= WITH_PCPI ? mem_rdata_q : 'bx;
 
 			instr_beq   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b000;
 			instr_bne   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b001;
 			instr_blt   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b100;
 			instr_bge   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b101;
 			instr_bltu  <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b110;
 			instr_bgeu  <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b111;
 
 			instr_lb    <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b000;
 			instr_lh    <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b001;
 			instr_lw    <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b010;
 			instr_lbu   <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b100;
 			instr_lhu   <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b101;
 
 			instr_sb    <= is_sb_sh_sw && mem_rdata_q[14:12] == 3'b000;
 			instr_sh    <= is_sb_sh_sw && mem_rdata_q[14:12] == 3'b001;
 			instr_sw    <= is_sb_sh_sw && mem_rdata_q[14:12] == 3'b010;
 
 			instr_addi  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b000;
 			instr_slti  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b010;
 			instr_sltiu <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b011;
 			instr_xori  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b100;
 			instr_ori   <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b110;
 			instr_andi  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b111;
 
 			instr_slli  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_srli  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_srai  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000;
 
 			instr_add   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b000 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_sub   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b000 && mem_rdata_q[31:25] == 7'b0100000;
 			instr_sll   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_slt   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b010 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_sltu  <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b011 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_xor   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b100 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_srl   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_sra   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000;
 			instr_or    <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b110 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_and   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b111 && mem_rdata_q[31:25] == 7'b0000000;
 
 			instr_rdcycle  <= ((mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11000000000000000010) ||
 			                   (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11000000000100000010)) && ENABLE_COUNTERS;
 			instr_rdcycleh <= ((mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11001000000000000010) ||
 			                   (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11001000000100000010)) && ENABLE_COUNTERS && ENABLE_COUNTERS64;
 			instr_rdinstr  <=  (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11000000001000000010) && ENABLE_COUNTERS;
 			instr_rdinstrh <=  (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11001000001000000010) && ENABLE_COUNTERS && ENABLE_COUNTERS64;
 
 			instr_ecall_ebreak <= ((mem_rdata_q[6:0] == 7'b1110011 && !mem_rdata_q[31:21] && !mem_rdata_q[19:7]) ||
 					(COMPRESSED_ISA && mem_rdata_q[15:0] == 16'h9002));
 
 			instr_getq    <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000000 && ENABLE_IRQ && ENABLE_IRQ_QREGS;
 			instr_setq    <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000001 && ENABLE_IRQ && ENABLE_IRQ_QREGS;
 			instr_maskirq <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000011 && ENABLE_IRQ;
 			instr_timer   <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000101 && ENABLE_IRQ && ENABLE_IRQ_TIMER;
 
 			is_slli_srli_srai <= is_alu_reg_imm && |{
 				mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000
 			};
 
 			is_jalr_addi_slti_sltiu_xori_ori_andi <= instr_jalr || is_alu_reg_imm && |{
 				mem_rdata_q[14:12] == 3'b000,
 				mem_rdata_q[14:12] == 3'b010,
 				mem_rdata_q[14:12] == 3'b011,
 				mem_rdata_q[14:12] == 3'b100,
 				mem_rdata_q[14:12] == 3'b110,
 				mem_rdata_q[14:12] == 3'b111
 			};
 
 			is_sll_srl_sra <= is_alu_reg_reg && |{
 				mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000
 			};
 
 			is_lui_auipc_jal_jalr_addi_add_sub <= 0;
 			is_compare <= 0;
 
 			(* parallel_case *)
 			case (1'b1)
 				instr_jal:
 					decoded_imm <= decoded_imm_uj;
 				|{instr_lui, instr_auipc}:
 					decoded_imm <= mem_rdata_q[31:12] << 12;
 				|{instr_jalr, is_lb_lh_lw_lbu_lhu, is_alu_reg_imm}:
 					decoded_imm <= $signed(mem_rdata_q[31:20]);
 				is_beq_bne_blt_bge_bltu_bgeu:
 					decoded_imm <= $signed({mem_rdata_q[31], mem_rdata_q[7], mem_rdata_q[30:25], mem_rdata_q[11:8], 1'b0});
 				is_sb_sh_sw:
 					decoded_imm <= $signed({mem_rdata_q[31:25], mem_rdata_q[11:7]});
 				default:
 					decoded_imm <= 1'bx;
 			endcase
 		end
 
 		if (!resetn) begin
 			is_beq_bne_blt_bge_bltu_bgeu <= 0;
 			is_compare <= 0;
 
 			instr_beq   <= 0;
 			instr_bne   <= 0;
 			instr_blt   <= 0;
 			instr_bge   <= 0;
 			instr_bltu  <= 0;
 			instr_bgeu  <= 0;
 
 			instr_addi  <= 0;
 			instr_slti  <= 0;
 			instr_sltiu <= 0;
 			instr_xori  <= 0;
 			instr_ori   <= 0;
 			instr_andi  <= 0;
 
 			instr_add   <= 0;
 			instr_sub   <= 0;
 			instr_sll   <= 0;
 			instr_slt   <= 0;
 			instr_sltu  <= 0;
 			instr_xor   <= 0;
 			instr_srl   <= 0;
 			instr_sra   <= 0;
 			instr_or    <= 0;
 			instr_and   <= 0;
 		end
 	end
 
 
 	// Main State Machine
 
 	localparam cpu_state_trap   = 8'b10000000;
 	localparam cpu_state_fetch  = 8'b01000000;
 	localparam cpu_state_ld_rs1 = 8'b00100000;
 	localparam cpu_state_ld_rs2 = 8'b00010000;
 	localparam cpu_state_exec   = 8'b00001000;
 	localparam cpu_state_shift  = 8'b00000100;
 	localparam cpu_state_stmem  = 8'b00000010;
 	localparam cpu_state_ldmem  = 8'b00000001;
 
 	reg [7:0] cpu_state;
 	reg [1:0] irq_state;
 
 	//FORMAL_KEEP reg [127:0] dbg_ascii_state;
 
 	always @* begin
 		dbg_ascii_state = "";
 		if (cpu_state == cpu_state_trap)   dbg_ascii_state = "trap";
 		if (cpu_state == cpu_state_fetch)  dbg_ascii_state = "fetch";
 		if (cpu_state == cpu_state_ld_rs1) dbg_ascii_state = "ld_rs1";
 		if (cpu_state == cpu_state_ld_rs2) dbg_ascii_state = "ld_rs2";
 		if (cpu_state == cpu_state_exec)   dbg_ascii_state = "exec";
 		if (cpu_state == cpu_state_shift)  dbg_ascii_state = "shift";
 		if (cpu_state == cpu_state_stmem)  dbg_ascii_state = "stmem";
 		if (cpu_state == cpu_state_ldmem)  dbg_ascii_state = "ldmem";
 	end
 
 	reg set_mem_do_rinst;
 	reg set_mem_do_rdata;
 	reg set_mem_do_wdata;
 
 	reg latched_store;
 	reg latched_stalu;
 	reg latched_branch;
 	reg latched_compr;
 	reg latched_trace;
 	reg latched_is_lu;
 	reg latched_is_lh;
 	reg latched_is_lb;
 	reg [regindex_bits-1:0] latched_rd;
 
 	reg [31:0] current_pc;
 	assign next_pc = latched_store && latched_branch ? reg_out & ~1 : reg_next_pc;
 
 	reg [3:0] pcpi_timeout_counter;
 	reg pcpi_timeout;
 
 	reg [31:0] next_irq_pending;
 	reg do_waitirq;
 
 	reg [31:0] alu_out, alu_out_q;
 	reg alu_out_0, alu_out_0_q;
 	reg alu_wait, alu_wait_2;
 
 	reg [31:0] alu_add_sub;
 	reg [31:0] alu_shl, alu_shr;
 	reg alu_eq, alu_ltu, alu_lts;
 
 	generate if (TWO_CYCLE_ALU) begin
 		always @(posedge clk) begin
 			alu_add_sub <= instr_sub ? reg_op1 - reg_op2 : reg_op1 + reg_op2;
 			alu_eq <= reg_op1 == reg_op2;
 			alu_lts <= $signed(reg_op1) < $signed(reg_op2);
 			alu_ltu <= reg_op1 < reg_op2;
 			alu_shl <= reg_op1 << reg_op2[4:0];
 			alu_shr <= $signed({instr_sra || instr_srai ? reg_op1[31] : 1'b0, reg_op1}) >>> reg_op2[4:0];
 		end
 	end else begin
 		always @* begin
 			alu_add_sub = instr_sub ? reg_op1 - reg_op2 : reg_op1 + reg_op2;
 			alu_eq = reg_op1 == reg_op2;
 			alu_lts = $signed(reg_op1) < $signed(reg_op2);
 			alu_ltu = reg_op1 < reg_op2;
 			alu_shl = reg_op1 << reg_op2[4:0];
 			alu_shr = $signed({instr_sra || instr_srai ? reg_op1[31] : 1'b0, reg_op1}) >>> reg_op2[4:0];
 		end
 	end endgenerate
 
 	always @* begin
 		alu_out_0 = 'bx;
 		(* parallel_case, full_case *)
 		case (1'b1)
 			instr_beq:
 				alu_out_0 = alu_eq;
 			instr_bne:
 				alu_out_0 = !alu_eq;
 			instr_bge:
 				alu_out_0 = !alu_lts;
 			instr_bgeu:
 				alu_out_0 = !alu_ltu;
 			is_slti_blt_slt && (!TWO_CYCLE_COMPARE || !{instr_beq,instr_bne,instr_bge,instr_bgeu}):
 				alu_out_0 = alu_lts;
 			is_sltiu_bltu_sltu && (!TWO_CYCLE_COMPARE || !{instr_beq,instr_bne,instr_bge,instr_bgeu}):
 				alu_out_0 = alu_ltu;
 		endcase
 
 		alu_out = 'bx;
 		(* parallel_case, full_case *)
 		case (1'b1)
 			is_lui_auipc_jal_jalr_addi_add_sub:
 				alu_out = alu_add_sub;
 			is_compare:
 				alu_out = alu_out_0;
 			instr_xori || instr_xor:
 				alu_out = reg_op1 ^ reg_op2;
 			instr_ori || instr_or:
 				alu_out = reg_op1 | reg_op2;
 			instr_andi || instr_and:
 				alu_out = reg_op1 & reg_op2;
 			BARREL_SHIFTER && (instr_sll || instr_slli):
 				alu_out = alu_shl;
 			BARREL_SHIFTER && (instr_srl || instr_srli || instr_sra || instr_srai):
 				alu_out = alu_shr;
 		endcase
 
 ifdef RISCV_FORMAL_BLACKBOX_ALU
 		alu_out_0 = $anyseq;
 		alu_out = $anyseq;
 endif
 	end
 
 	reg clear_prefetched_high_word_q;
 	always @(posedge clk) clear_prefetched_high_word_q <= clear_prefetched_high_word;
 
 	always @* begin
 		clear_prefetched_high_word = clear_prefetched_high_word_q;
 		if (!prefetched_high_word)
 			clear_prefetched_high_word = 0;
 		if (latched_branch || irq_state || !resetn)
 			clear_prefetched_high_word = COMPRESSED_ISA;
 	end
 
 	reg cpuregs_write;
 	reg [31:0] cpuregs_wrdata_i;
     assign cpuregs_wrdata = cpuregs_wrdata_i;
 	reg [31:0] cpuregs_rs1;
 	reg [31:0] cpuregs_rs2;
 	reg [regindex_bits-1:0] decoded_rs;
 
 	always @* begin
 		cpuregs_write = 0;
 		cpuregs_wrdata_i = 'bx;
 
 		if (cpu_state == cpu_state_fetch) begin
 			(* parallel_case *)
 			case (1'b1)
 				latched_branch: begin
 					cpuregs_wrdata_i = reg_pc + (latched_compr ? 2 : 4);
 					cpuregs_write = 1;
 				end
 				latched_store && !latched_branch: begin
 					cpuregs_wrdata_i = latched_stalu ? alu_out_q : reg_out;
 					cpuregs_write = 1;
 				end
 				ENABLE_IRQ && irq_state[0]: begin
 					cpuregs_wrdata_i = reg_next_pc | latched_compr;
 					cpuregs_write = 1;
 				end
 				ENABLE_IRQ && irq_state[1]: begin
 					cpuregs_wrdata_i = irq_pending & ~irq_mask;
 					cpuregs_write = 1;
 				end
 			endcase
 		end
 	end
 
 ifndef PICORV32_REGS
 	always @(posedge clk) begin
 		if (resetn && cpuregs_write && latched_rd)
 			cpuregs[latched_rd] <= cpuregs_wrdata_i;
 	end
 
 	always @* begin
 		decoded_rs = 'bx;
 		if (ENABLE_REGS_DUALPORT) begin
 ifndef RISCV_FORMAL_BLACKBOX_REGS
 			cpuregs_rs1 = decoded_rs1 ? cpuregs[decoded_rs1] : 0;
 			cpuregs_rs2 = decoded_rs2 ? cpuregs[decoded_rs2] : 0;
 else
 			cpuregs_rs1 = decoded_rs1 ? $anyseq : 0;
 			cpuregs_rs2 = decoded_rs2 ? $anyseq : 0;
 endif
 		end else begin
 			decoded_rs = (cpu_state == cpu_state_ld_rs2) ? decoded_rs2 : decoded_rs1;
 ifndef RISCV_FORMAL_BLACKBOX_REGS
 			cpuregs_rs1 = decoded_rs ? cpuregs[decoded_rs] : 0;
 else
 			cpuregs_rs1 = decoded_rs ? $anyseq : 0;
 endif
 			cpuregs_rs2 = cpuregs_rs1;
 		end
 	end
 else
 
 	assign cpuregs_waddr = latched_rd;
 	assign cpuregs_raddr1 = ENABLE_REGS_DUALPORT ? decoded_rs1 : decoded_rs;
 	assign cpuregs_raddr2 = ENABLE_REGS_DUALPORT ? decoded_rs2 : 0;
 
 	always @* begin
 		decoded_rs = 'bx;
 		if (ENABLE_REGS_DUALPORT) begin
 			cpuregs_rs1 = decoded_rs1 ? cpuregs_rdata1 : 0;
 			cpuregs_rs2 = decoded_rs2 ? cpuregs_rdata2 : 0;
 		end else begin
 			decoded_rs = (cpu_state == cpu_state_ld_rs2) ? decoded_rs2 : decoded_rs1;
 			cpuregs_rs1 = decoded_rs ? cpuregs_rdata1 : 0;
 			cpuregs_rs2 = cpuregs_rs1;
 		end
 	end
 endif
 
 	assign launch_next_insn = cpu_state == cpu_state_fetch && decoder_trigger && (!ENABLE_IRQ || irq_delay || irq_active || !(irq_pending & ~irq_mask));
 
 	always @(posedge clk) begin
 		trap <= 0;
 		reg_sh <= 'bx;
 		reg_out <= 'bx;
 		set_mem_do_rinst = 0;
 		set_mem_do_rdata = 0;
 		set_mem_do_wdata = 0;
 
 		alu_out_0_q <= alu_out_0;
 		alu_out_q <= alu_out;
 
 		alu_wait <= 0;
 		alu_wait_2 <= 0;
 
 		if (launch_next_insn) begin
 			dbg_rs1val <= 'bx;
 			dbg_rs2val <= 'bx;
 			dbg_rs1val_valid <= 0;
 			dbg_rs2val_valid <= 0;
 		end
 
 		if (WITH_PCPI && CATCH_ILLINSN) begin
 			if (resetn && pcpi_valid_i && !pcpi_int_wait) begin
 				if (pcpi_timeout_counter)
 					pcpi_timeout_counter <= pcpi_timeout_counter - 1;
 			end else
 				pcpi_timeout_counter <= ~0;
 			pcpi_timeout <= !pcpi_timeout_counter;
 		end
 
 		if (ENABLE_COUNTERS) begin
 			count_cycle <= resetn ? count_cycle + 1 : 0;
 			if (!ENABLE_COUNTERS64) count_cycle[63:32] <= 0;
 		end else begin
 			count_cycle <= 'bx;
 			count_instr <= 'bx;
 		end
 
 		next_irq_pending = ENABLE_IRQ ? irq_pending & LATCHED_IRQ : 'bx;
 
 		if (ENABLE_IRQ && ENABLE_IRQ_TIMER && timer) begin
 			if (timer - 1 == 0)
 				next_irq_pending[irq_timer] = 1;
 			timer <= timer - 1;
 		end
 
 		if (ENABLE_IRQ) begin
 			next_irq_pending = next_irq_pending | irq;
 		end
 
 		decoder_trigger <= mem_do_rinst && mem_done;
 		decoder_trigger_q <= decoder_trigger;
 		decoder_pseudo_trigger <= 0;
 		decoder_pseudo_trigger_q <= decoder_pseudo_trigger;
 		do_waitirq <= 0;
 
 		trace_valid <= 0;
 
 		if (!ENABLE_TRACE)
 			trace_data <= 'bx;
 
 		if (!resetn) begin
 			reg_pc <= PROGADDR_RESET;
 			reg_next_pc <= PROGADDR_RESET;
 			if (ENABLE_COUNTERS)
 				count_instr <= 0;
 			latched_store <= 0;
 			latched_stalu <= 0;
 			latched_branch <= 0;
 			latched_trace <= 0;
 			latched_is_lu <= 0;
 			latched_is_lh <= 0;
 			latched_is_lb <= 0;
 			pcpi_valid_i <= 0;
 			pcpi_timeout <= 0;
 			irq_active <= 0;
 			irq_delay <= 0;
 			irq_mask <= ~0;
 			next_irq_pending = 0;
 			irq_state <= 0;
 			eoi <= 0;
 			timer <= 0;
 			if (~STACKADDR) begin
 				latched_store <= 1;
 				latched_rd <= 2;
 				reg_out <= STACKADDR;
 			end
 			cpu_state <= cpu_state_fetch;
 		end else
 		(* parallel_case, full_case *)
 		case (cpu_state)
 			cpu_state_trap: begin
 				trap <= 1;
 			end
 
 			cpu_state_fetch: begin
 				mem_do_rinst <= !decoder_trigger && !do_waitirq;
 				mem_wordsize <= 0;
 
 				current_pc = reg_next_pc;
 
 				(* parallel_case *)
 				case (1'b1)
 					latched_branch: begin
 						current_pc = latched_store ? (latched_stalu ? alu_out_q : reg_out) & ~1 : reg_next_pc;
 						//debug($display("ST_RD:  %2d 0x%08x, BRANCH 0x%08x", latched_rd, reg_pc + (latched_compr ? 2 : 4), current_pc);)
 					end
 					latched_store && !latched_branch: begin
 						//debug($display("ST_RD:  %2d 0x%08x", latched_rd, latched_stalu ? alu_out_q : reg_out);)
 					end
 					ENABLE_IRQ && irq_state[0]: begin
 						current_pc = PROGADDR_IRQ;
 						irq_active <= 1;
 						mem_do_rinst <= 1;
 					end
 					ENABLE_IRQ && irq_state[1]: begin
 						eoi <= irq_pending & ~irq_mask;
 						next_irq_pending = next_irq_pending & irq_mask;
 					end
 				endcase
 
 				if (ENABLE_TRACE && latched_trace) begin
 					latched_trace <= 0;
 					trace_valid <= 1;
 					if (latched_branch)
 						trace_data <= (irq_active ? TRACE_IRQ : 0) | TRACE_BRANCH | (current_pc & 32'hfffffffe);
 					else
 						trace_data <= (irq_active ? TRACE_IRQ : 0) | (latched_stalu ? alu_out_q : reg_out);
 				end
 
 				reg_pc <= current_pc;
 				reg_next_pc <= current_pc;
 
 				latched_store <= 0;
 				latched_stalu <= 0;
 				latched_branch <= 0;
 				latched_is_lu <= 0;
 				latched_is_lh <= 0;
 				latched_is_lb <= 0;
 				latched_rd <= decoded_rd;
 				latched_compr <= compressed_instr;
 
 				if (ENABLE_IRQ && ((decoder_trigger && !irq_active && !irq_delay && |(irq_pending & ~irq_mask)) || irq_state)) begin
 					irq_state <=
 						irq_state == 2'b00 ? 2'b01 :
 						irq_state == 2'b01 ? 2'b10 : 2'b00;
 					latched_compr <= latched_compr;
 					if (ENABLE_IRQ_QREGS)
 						latched_rd <= irqregs_offset | irq_state[0];
 					else
 						latched_rd <= irq_state[0] ? 4 : 3;
 				end else
 				if (ENABLE_IRQ && (decoder_trigger || do_waitirq) && instr_waitirq) begin
 					if (irq_pending) begin
 						latched_store <= 1;
 						reg_out <= irq_pending;
 						reg_next_pc <= current_pc + (compressed_instr ? 2 : 4);
 						mem_do_rinst <= 1;
 					end else
 						do_waitirq <= 1;
 				end else
 				if (decoder_trigger) begin
 					//debug($display("-- %-0t", $time);)
 					irq_delay <= irq_active;
 					reg_next_pc <= current_pc + (compressed_instr ? 2 : 4);
 					if (ENABLE_TRACE)
 						latched_trace <= 1;
 					if (ENABLE_COUNTERS) begin
 						count_instr <= count_instr + 1;
 						if (!ENABLE_COUNTERS64) count_instr[63:32] <= 0;
 					end
 					if (instr_jal) begin
 						mem_do_rinst <= 1;
 						reg_next_pc <= current_pc + decoded_imm_uj;
 						latched_branch <= 1;
 					end else begin
 						mem_do_rinst <= 0;
 						mem_do_prefetch <= !instr_jalr && !instr_retirq;
 						cpu_state <= cpu_state_ld_rs1;
 					end
 				end
 			end
 
 			cpu_state_ld_rs1: begin
 				reg_op1 <= 'bx;
 				reg_op2 <= 'bx;
 
 				(* parallel_case *)
 				case (1'b1)
 					(CATCH_ILLINSN || WITH_PCPI) && instr_trap: begin
 						if (WITH_PCPI) begin
 							//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 							reg_op1 <= cpuregs_rs1;
 							dbg_rs1val <= cpuregs_rs1;
 							dbg_rs1val_valid <= 1;
 							if (ENABLE_REGS_DUALPORT) begin
 								pcpi_valid_i <= 1;
 								//debug($display("LD_RS2: %2d 0x%08x", decoded_rs2, cpuregs_rs2);)
 								reg_sh <= cpuregs_rs2;
 								reg_op2 <= cpuregs_rs2;
 								dbg_rs2val <= cpuregs_rs2;
 								dbg_rs2val_valid <= 1;
 								if (pcpi_int_ready) begin
 									mem_do_rinst <= 1;
 									pcpi_valid_i <= 0;
 									reg_out <= pcpi_int_rd;
 									latched_store <= pcpi_int_wr;
 									cpu_state <= cpu_state_fetch;
 								end else
 								if (CATCH_ILLINSN && (pcpi_timeout || instr_ecall_ebreak)) begin
 									pcpi_valid_i <= 0;
 									//debug($display("EBREAK OR UNSUPPORTED INSN AT 0x%08x", reg_pc);)
 									if (ENABLE_IRQ && !irq_mask[irq_ebreak] && !irq_active) begin
 										next_irq_pending[irq_ebreak] = 1;
 										cpu_state <= cpu_state_fetch;
 									end else
 										cpu_state <= cpu_state_trap;
 								end
 							end else begin
 								cpu_state <= cpu_state_ld_rs2;
 							end
 						end else begin
 							//debug($display("EBREAK OR UNSUPPORTED INSN AT 0x%08x", reg_pc);)
 							if (ENABLE_IRQ && !irq_mask[irq_ebreak] && !irq_active) begin
 								next_irq_pending[irq_ebreak] = 1;
 								cpu_state <= cpu_state_fetch;
 							end else
 								cpu_state <= cpu_state_trap;
 						end
 					end
 					ENABLE_COUNTERS && is_rdcycle_rdcycleh_rdinstr_rdinstrh: begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							instr_rdcycle:
 								reg_out <= count_cycle[31:0];
 							instr_rdcycleh && ENABLE_COUNTERS64:
 								reg_out <= count_cycle[63:32];
 							instr_rdinstr:
 								reg_out <= count_instr[31:0];
 							instr_rdinstrh && ENABLE_COUNTERS64:
 								reg_out <= count_instr[63:32];
 						endcase
 						latched_store <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					is_lui_auipc_jal: begin
 						reg_op1 <= instr_lui ? 0 : reg_pc;
 						reg_op2 <= decoded_imm;
 						if (TWO_CYCLE_ALU)
 							alu_wait <= 1;
 						else
 							mem_do_rinst <= mem_do_prefetch;
 						cpu_state <= cpu_state_exec;
 					end
 					ENABLE_IRQ && ENABLE_IRQ_QREGS && instr_getq: begin
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_out <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						latched_store <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && ENABLE_IRQ_QREGS && instr_setq: begin
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_out <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						latched_rd <= latched_rd | irqregs_offset;
 						latched_store <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && instr_retirq: begin
 						//eoi <= 0;
 						irq_active <= 0;
 						latched_branch <= 1;
 						latched_store <= 1;
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_out <= CATCH_MISALIGN ? (cpuregs_rs1 & 32'h fffffffe) : cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && instr_maskirq: begin
 						latched_store <= 1;
 						reg_out <= irq_mask;
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						irq_mask <= cpuregs_rs1 | MASKED_IRQ;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && ENABLE_IRQ_TIMER && instr_timer: begin
 						latched_store <= 1;
 						reg_out <= timer;
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						timer <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					is_lb_lh_lw_lbu_lhu && !instr_trap: begin
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_ldmem;
 						mem_do_rinst <= 1;
 					end
 					is_slli_srli_srai && !BARREL_SHIFTER: begin
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						reg_sh <= decoded_rs2;
 						cpu_state <= cpu_state_shift;
 					end
 					is_jalr_addi_slti_sltiu_xori_ori_andi, is_slli_srli_srai && BARREL_SHIFTER: begin
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						reg_op2 <= is_slli_srli_srai && BARREL_SHIFTER ? decoded_rs2 : decoded_imm;
 						if (TWO_CYCLE_ALU)
 							alu_wait <= 1;
 						else
 							mem_do_rinst <= mem_do_prefetch;
 						cpu_state <= cpu_state_exec;
 					end
 					default: begin
 						//debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						if (ENABLE_REGS_DUALPORT) begin
 							//debug($display("LD_RS2: %2d 0x%08x", decoded_rs2, cpuregs_rs2);)
 							reg_sh <= cpuregs_rs2;
 							reg_op2 <= cpuregs_rs2;
 							dbg_rs2val <= cpuregs_rs2;
 							dbg_rs2val_valid <= 1;
 							(* parallel_case *)
 							case (1'b1)
 								is_sb_sh_sw: begin
 									cpu_state <= cpu_state_stmem;
 									mem_do_rinst <= 1;
 								end
 								is_sll_srl_sra && !BARREL_SHIFTER: begin
 									cpu_state <= cpu_state_shift;
 								end
 								default: begin
 									if (TWO_CYCLE_ALU || (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu)) begin
 										alu_wait_2 <= TWO_CYCLE_ALU && (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu);
 										alu_wait <= 1;
 									end else
 										mem_do_rinst <= mem_do_prefetch;
 									cpu_state <= cpu_state_exec;
 								end
 							endcase
 						end else
 							cpu_state <= cpu_state_ld_rs2;
 					end
 				endcase
 			end
 
 			cpu_state_ld_rs2: begin
 				//debug($display("LD_RS2: %2d 0x%08x", decoded_rs2, cpuregs_rs2);)
 				reg_sh <= cpuregs_rs2;
 				reg_op2 <= cpuregs_rs2;
 				dbg_rs2val <= cpuregs_rs2;
 				dbg_rs2val_valid <= 1;
 
 				(* parallel_case *)
 				case (1'b1)
 					WITH_PCPI && instr_trap: begin
 						pcpi_valid_i <= 1;
 						if (pcpi_int_ready) begin
 							mem_do_rinst <= 1;
 							pcpi_valid_i <= 0;
 							reg_out <= pcpi_int_rd;
 							latched_store <= pcpi_int_wr;
 							cpu_state <= cpu_state_fetch;
 						end else
 						if (CATCH_ILLINSN && (pcpi_timeout || instr_ecall_ebreak)) begin
 							pcpi_valid_i <= 0;
 							//debug($display("EBREAK OR UNSUPPORTED INSN AT 0x%08x", reg_pc);)
 							if (ENABLE_IRQ && !irq_mask[irq_ebreak] && !irq_active) begin
 								next_irq_pending[irq_ebreak] = 1;
 								cpu_state <= cpu_state_fetch;
 							end else
 								cpu_state <= cpu_state_trap;
 						end
 					end
 					is_sb_sh_sw: begin
 						cpu_state <= cpu_state_stmem;
 						mem_do_rinst <= 1;
 					end
 					is_sll_srl_sra && !BARREL_SHIFTER: begin
 						cpu_state <= cpu_state_shift;
 					end
 					default: begin
 						if (TWO_CYCLE_ALU || (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu)) begin
 							alu_wait_2 <= TWO_CYCLE_ALU && (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu);
 							alu_wait <= 1;
 						end else
 							mem_do_rinst <= mem_do_prefetch;
 						cpu_state <= cpu_state_exec;
 					end
 				endcase
 			end
 
 			cpu_state_exec: begin
 				reg_out <= reg_pc + decoded_imm;
 				if ((TWO_CYCLE_ALU || TWO_CYCLE_COMPARE) && (alu_wait || alu_wait_2)) begin
 					mem_do_rinst <= mem_do_prefetch && !alu_wait_2;
 					alu_wait <= alu_wait_2;
 				end else
 				if (is_beq_bne_blt_bge_bltu_bgeu) begin
 					latched_rd <= 0;
 					latched_store <= TWO_CYCLE_COMPARE ? alu_out_0_q : alu_out_0;
 					latched_branch <= TWO_CYCLE_COMPARE ? alu_out_0_q : alu_out_0;
 					if (mem_done)
 						cpu_state <= cpu_state_fetch;
 					if (TWO_CYCLE_COMPARE ? alu_out_0_q : alu_out_0) begin
 						decoder_trigger <= 0;
 						set_mem_do_rinst = 1;
 					end
 				end else begin
 					latched_branch <= instr_jalr;
 					latched_store <= 1;
 					latched_stalu <= 1;
 					cpu_state <= cpu_state_fetch;
 				end
 			end
 
 			cpu_state_shift: begin
 				latched_store <= 1;
 				if (reg_sh == 0) begin
 					reg_out <= reg_op1;
 					mem_do_rinst <= mem_do_prefetch;
 					cpu_state <= cpu_state_fetch;
 				end else if (TWO_STAGE_SHIFT && reg_sh >= 4) begin
 					(* parallel_case, full_case *)
 					case (1'b1)
 						instr_slli || instr_sll: reg_op1 <= reg_op1 << 4;
 						instr_srli || instr_srl: reg_op1 <= reg_op1 >> 4;
 						instr_srai || instr_sra: reg_op1 <= $signed(reg_op1) >>> 4;
 					endcase
 					reg_sh <= reg_sh - 4;
 				end else begin
 					(* parallel_case, full_case *)
 					case (1'b1)
 						instr_slli || instr_sll: reg_op1 <= reg_op1 << 1;
 						instr_srli || instr_srl: reg_op1 <= reg_op1 >> 1;
 						instr_srai || instr_sra: reg_op1 <= $signed(reg_op1) >>> 1;
 					endcase
 					reg_sh <= reg_sh - 1;
 				end
 			end
 
 			cpu_state_stmem: begin
 				if (ENABLE_TRACE)
 					reg_out <= reg_op2;
 				if (!mem_do_prefetch || mem_done) begin
 					if (!mem_do_wdata) begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							instr_sb: mem_wordsize <= 2;
 							instr_sh: mem_wordsize <= 1;
 							instr_sw: mem_wordsize <= 0;
 						endcase
 						if (ENABLE_TRACE) begin
 							trace_valid <= 1;
 							trace_data <= (irq_active ? TRACE_IRQ : 0) | TRACE_ADDR | ((reg_op1 + decoded_imm) & 32'hffffffff);
 						end
 						reg_op1 <= reg_op1 + decoded_imm;
 						set_mem_do_wdata = 1;
 					end
 					if (!mem_do_prefetch && mem_done) begin
 						cpu_state <= cpu_state_fetch;
 						decoder_trigger <= 1;
 						decoder_pseudo_trigger <= 1;
 					end
 				end
 			end
 
 			cpu_state_ldmem: begin
 				latched_store <= 1;
 				if (!mem_do_prefetch || mem_done) begin
 					if (!mem_do_rdata) begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							instr_lb || instr_lbu: mem_wordsize <= 2;
 							instr_lh || instr_lhu: mem_wordsize <= 1;
 							instr_lw: mem_wordsize <= 0;
 						endcase
 						latched_is_lu <= is_lbu_lhu_lw;
 						latched_is_lh <= instr_lh;
 						latched_is_lb <= instr_lb;
 						if (ENABLE_TRACE) begin
 							trace_valid <= 1;
 							trace_data <= (irq_active ? TRACE_IRQ : 0) | TRACE_ADDR | ((reg_op1 + decoded_imm) & 32'hffffffff);
 						end
 						reg_op1 <= reg_op1 + decoded_imm;
 						set_mem_do_rdata = 1;
 					end
 					if (!mem_do_prefetch && mem_done) begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							latched_is_lu: reg_out <= mem_rdata_word;
 							latched_is_lh: reg_out <= $signed(mem_rdata_word[15:0]);
 							latched_is_lb: reg_out <= $signed(mem_rdata_word[7:0]);
 						endcase
 						decoder_trigger <= 1;
 						decoder_pseudo_trigger <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 				end
 			end
 		endcase
 
 		if (CATCH_MISALIGN && resetn && (mem_do_rdata || mem_do_wdata)) begin
 			if (mem_wordsize == 0 && reg_op1[1:0] != 0) begin
 				//debug($display("MISALIGNED WORD: 0x%08x", reg_op1);)
 				if (ENABLE_IRQ && !irq_mask[irq_buserror] && !irq_active) begin
 					next_irq_pending[irq_buserror] = 1;
 				end else
 					cpu_state <= cpu_state_trap;
 			end
 			if (mem_wordsize == 1 && reg_op1[0] != 0) begin
 				//debug($display("MISALIGNED HALFWORD: 0x%08x", reg_op1);)
 				if (ENABLE_IRQ && !irq_mask[irq_buserror] && !irq_active) begin
 					next_irq_pending[irq_buserror] = 1;
 				end else
 					cpu_state <= cpu_state_trap;
 			end
 		end
 		if (CATCH_MISALIGN && resetn && mem_do_rinst && (COMPRESSED_ISA ? reg_pc[0] : |reg_pc[1:0])) begin
 			//debug($display("MISALIGNED INSTRUCTION: 0x%08x", reg_pc);)
 			if (ENABLE_IRQ && !irq_mask[irq_buserror] && !irq_active) begin
 				next_irq_pending[irq_buserror] = 1;
 			end else
 				cpu_state <= cpu_state_trap;
 		end
 		if (!CATCH_ILLINSN && decoder_trigger_q && !decoder_pseudo_trigger_q && instr_ecall_ebreak) begin
 			cpu_state <= cpu_state_trap;
 		end
 
 		if (!resetn || mem_done) begin
 			mem_do_prefetch <= 0;
 			mem_do_rinst <= 0;
 			mem_do_rdata <= 0;
 			mem_do_wdata <= 0;
 		end
 
 		if (set_mem_do_rinst)
 			mem_do_rinst <= 1;
 		if (set_mem_do_rdata)
 			mem_do_rdata <= 1;
 		if (set_mem_do_wdata)
 			mem_do_wdata <= 1;
 
 		irq_pending <= next_irq_pending & ~MASKED_IRQ;
 
 		if (!CATCH_MISALIGN) begin
 			if (COMPRESSED_ISA) begin
 				reg_pc[0] <= 0;
 				reg_next_pc[0] <= 0;
 			end else begin
 				reg_pc[1:0] <= 0;
 				reg_next_pc[1:0] <= 0;
 			end
 		end
 		current_pc = 'bx;
 	end
 
 ifdef RISCV_FORMAL
 	reg dbg_irq_call;
 	reg dbg_irq_enter;
 	reg [31:0] dbg_irq_ret;
 	always @(posedge clk) begin
 		rvfi_valid <= resetn && (launch_next_insn || trap) && dbg_valid_insn;
 		rvfi_order <= resetn ? rvfi_order + rvfi_valid : 0;
 
 		rvfi_insn <= dbg_insn_opcode;
 		rvfi_rs1_addr <= dbg_rs1val_valid ? dbg_insn_rs1 : 0;
 		rvfi_rs2_addr <= dbg_rs2val_valid ? dbg_insn_rs2 : 0;
 		rvfi_pc_rdata <= dbg_insn_addr;
 		rvfi_rs1_rdata <= dbg_rs1val_valid ? dbg_rs1val : 0;
 		rvfi_rs2_rdata <= dbg_rs2val_valid ? dbg_rs2val : 0;
 		rvfi_trap <= trap;
 		rvfi_halt <= trap;
 		rvfi_intr <= dbg_irq_enter;
 		rvfi_mode <= 3;
 
 		if (!resetn) begin
 			dbg_irq_call <= 0;
 			dbg_irq_enter <= 0;
 		end else
 		if (rvfi_valid) begin
 			dbg_irq_call <= 0;
 			dbg_irq_enter <= dbg_irq_call;
 		end else
 		if (irq_state == 1) begin
 			dbg_irq_call <= 1;
 			dbg_irq_ret <= next_pc;
 		end
 
 		if (!resetn) begin
 			rvfi_rd_addr <= 0;
 			rvfi_rd_wdata <= 0;
 		end else
 		if (cpuregs_write && !irq_state) begin
 			rvfi_rd_addr <= latched_rd;
 			rvfi_rd_wdata <= latched_rd ? cpuregs_wrdata_i : 0;
 		end else
 		if (rvfi_valid) begin
 			rvfi_rd_addr <= 0;
 			rvfi_rd_wdata <= 0;
 		end
 
 		casez (dbg_insn_opcode)
 			32'b 0000000_?????_000??_???_?????_0001011: begin // getq
 				rvfi_rs1_addr <= 0;
 				rvfi_rs1_rdata <= 0;
 			end
 			32'b 0000001_?????_?????_???_000??_0001011: begin // setq
 				rvfi_rd_addr <= 0;
 				rvfi_rd_wdata <= 0;
 			end
 			32'b 0000010_?????_00000_???_00000_0001011: begin // retirq
 				rvfi_rs1_addr <= 0;
 				rvfi_rs1_rdata <= 0;
 			end
 		endcase
 
 		if (!dbg_irq_call) begin
 			if (dbg_mem_instr) begin
 				rvfi_mem_addr <= 0;
 				rvfi_mem_rmask <= 0;
 				rvfi_mem_wmask <= 0;
 				rvfi_mem_rdata <= 0;
 				rvfi_mem_wdata <= 0;
 			end else
 			if (dbg_mem_valid && dbg_mem_ready) begin
 				rvfi_mem_addr <= dbg_mem_addr;
 				rvfi_mem_rmask <= dbg_mem_wstrb ? 0 : ~0;
 				rvfi_mem_wmask <= dbg_mem_wstrb;
 				rvfi_mem_rdata <= dbg_mem_rdata;
 				rvfi_mem_wdata <= dbg_mem_wdata;
 			end
 		end
 	end
 
 	always @* begin
 		rvfi_pc_wdata = dbg_irq_call ? dbg_irq_ret : dbg_insn_addr;
 	end
 endif
 
 	// Formal Verification
 ifdef FORMAL
 	reg [3:0] last_mem_nowait;
 	always @(posedge clk)
 		last_mem_nowait <= {last_mem_nowait, mem_ready || !mem_valid_i};
 
 	// stall the memory interface for max 4 cycles
 	restrict property (|last_mem_nowait || mem_ready || !mem_valid_i);
 
 	// resetn low in first cycle, after that resetn high
 	restrict property (resetn != $initstate);
 
 	// this just makes it much easier to read traces. uncomment as needed.
 	// assume property (mem_valid || !mem_ready);
 
 	reg ok;
 	always @* begin
 		if (resetn) begin
 			// instruction fetches are read-only
 			if (mem_valid_i && mem_instr_i)
 				assert (mem_wstrb_i == 0);
 
 			// cpu_state must be valid
 			ok = 0;
 			if (cpu_state == cpu_state_trap)   ok = 1;
 			if (cpu_state == cpu_state_fetch)  ok = 1;
 			if (cpu_state == cpu_state_ld_rs1) ok = 1;
 			if (cpu_state == cpu_state_ld_rs2) ok = !ENABLE_REGS_DUALPORT;
 			if (cpu_state == cpu_state_exec)   ok = 1;
 			if (cpu_state == cpu_state_shift)  ok = 1;
 			if (cpu_state == cpu_state_stmem)  ok = 1;
 			if (cpu_state == cpu_state_ldmem)  ok = 1;
 			assert (ok);
 		end
 	end
 
 	reg last_mem_la_read = 0;
 	reg last_mem_la_write = 0;
 	reg [31:0] last_mem_la_addr;
 	reg [31:0] last_mem_la_wdata;
 	reg [3:0] last_mem_la_wstrb = 0;
 
 	always @(posedge clk) begin
 		last_mem_la_read <= mem_la_read;
 		last_mem_la_write <= mem_la_write;
 		last_mem_la_addr <= mem_la_addr;
 		last_mem_la_wdata <= mem_la_wdata;
 		last_mem_la_wstrb <= mem_la_wstrb;
 
 		if (last_mem_la_read) begin
 			assert(mem_valid_i);
 			assert(mem_addr_i == last_mem_la_addr);
 			assert(mem_wstrb_i == 0);
 		end
 		if (last_mem_la_write) begin
 			assert(mem_valid_i);
 			assert(mem_addr_i == last_mem_la_addr);
 			assert(mem_wdata_i == last_mem_la_wdata);
 			assert(mem_wstrb_i == last_mem_la_wstrb);
 		end
 		if (mem_la_read || mem_la_write) begin
 			assert(!mem_valid_i || mem_ready);
 		end
 	end
 endif
 
endmodule
//---- Top entity
module v5242e2 (
 input [31:0] v917e97,
 input [31:0] v5664d9,
 input [31:0] v918400,
 input [31:0] vae8a69,
 input vec88a9,
 input v76f74e,
 input ve3469f,
 input v58d02d,
 output [31:0] v493538
);
 wire [0:1] w0;
 wire w1;
 wire [0:31] w2;
 wire [0:31] w3;
 wire [0:31] w4;
 wire [0:31] w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:31] w10;
 wire [0:31] w11;
 wire [0:31] w12;
 assign w2 = v917e97;
 assign w3 = v5664d9;
 assign w4 = v918400;
 assign w5 = vae8a69;
 assign w6 = vec88a9;
 assign w7 = v76f74e;
 assign w8 = v58d02d;
 assign w9 = ve3469f;
 assign v493538 = w10;
 v6835fc ve38aa0 (
  .ved33bc(w0),
  .v2828a2(w2),
  .v86e1b9(w3),
  .v010aaa(w4),
  .v930664(w5),
  .v242732(w11)
 );
 veecece vfd598f (
  .vfd29cc(w0),
  .v5a4b06(w1),
  .v78af34(w6),
  .v78ff37(w7),
  .v44b9b7(w8),
  .v259301(w9)
 );
 vad96c0 v4b1d09 (
  .ve50a7b(w1),
  .v9960f4(w10),
  .v231daa(w11),
  .v95bea5(w12)
 );
 v2c97f6 vde5edd (
  .v7c9bd8(w12)
 );
endmodule

//---------------------------------------------------
//-- Bus-4
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bus de 32 bits de 4 canales
//---------------------------------------------------
//---- Top entity
module v6835fc (
 input [31:0] v2828a2,
 input [31:0] v86e1b9,
 input [31:0] v010aaa,
 input [31:0] v930664,
 input [1:0] ved33bc,
 output [31:0] v242732
);
 wire [0:31] w0;
 wire [0:31] w1;
 wire [0:31] w2;
 wire [0:31] w3;
 wire [0:31] w4;
 wire [0:1] w5;
 assign w0 = v2828a2;
 assign w1 = v86e1b9;
 assign w2 = v010aaa;
 assign w3 = v930664;
 assign v242732 = w4;
 assign w5 = ved33bc;
 v6835fc_ve4e0df ve4e0df (
  .i3(w0),
  .i2(w1),
  .i1(w2),
  .i0(w3),
  .o(w4),
  .s(w5)
 );
endmodule

//---------------------------------------------------
//-- Mux-4-1-32bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Multiplexor de 4 a 1 de 32 bits
//---------------------------------------------------

module v6835fc_ve4e0df (
 input [31:0] i3,
 input [31:0] i2,
 input [31:0] i1,
 input [31:0] i0,
 input [1:0] s,
 output [31:0] o
);
 //-- Multiplexor de 4 a 1, 
 //-- de 32 bits
 
 assign o = (s == 3'h0) ? i0 :
            (s == 3'h1) ? i1 :
            (s == 3'h2) ? i2 : 
            (s == 3'h3) ? i3 :
            32'h0;
            
 
 
endmodule
//---- Top entity
module veecece (
 input v78af34,
 input v78ff37,
 input v259301,
 input v44b9b7,
 output [1:0] vfd29cc,
 output v5a4b06
);
 wire [0:1] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign vfd29cc = w0;
 assign v5a4b06 = w1;
 assign w2 = v78af34;
 assign w3 = v78ff37;
 assign w4 = v259301;
 assign w5 = v44b9b7;
 veecece_v4407ca v4407ca (
  .y(w0),
  .zero(w1),
  .i3(w2),
  .i2(w3),
  .i1(w4),
  .i0(w5)
 );
endmodule

//---------------------------------------------------
//-- Codificador-4-2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Codificador de 4 a 2, con prioridad. La salida zero se activa cuando ninguna entrada est√° activad
//---------------------------------------------------

module veecece_v4407ca (
 input i3,
 input i2,
 input i1,
 input i0,
 output [1:0] y,
 output zero
);
 //-- Codificador de 4 a 1
 
 //-- Se√±alizar que todos son ceros
 assign zero = ({i3,i2,i1,i0}==4'b00);
 
 
 assign y = (i3 == 1) ? 2'h3 :
            (i2 == 1) ? 2'h2 :
            (i1 == 1) ? 2'h1 : 0;
           
 
endmodule
//---- Top entity
module vad96c0 (
 input [31:0] v95bea5,
 input [31:0] v231daa,
 input ve50a7b,
 output [31:0] v9960f4
);
 wire w0;
 wire [0:31] w1;
 wire [0:31] w2;
 wire [0:31] w3;
 assign w0 = ve50a7b;
 assign v9960f4 = w1;
 assign w2 = v231daa;
 assign w3 = v95bea5;
 vad96c0_v4d0636 v4d0636 (
  .sel(w0),
  .o(w1),
  .i0(w2),
  .i1(w3)
 );
endmodule

//---------------------------------------------------
//-- 32-bits-Mux-2-1-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 2-to-1 Multplexer (32-bit channels). Verilog implementation
//---------------------------------------------------

module vad96c0_v4d0636 (
 input [31:0] i1,
 input [31:0] i0,
 input sel,
 output [31:0] o
);
 //-- 2-to-1 Multiplexer 
 
 assign o = sel ? i1 : i0;
endmodule
//---- Top entity
module v2c97f6 #(
 parameter vfffc23 = 0
) (
 output [31:0] v7c9bd8
);
 localparam p0 = vfffc23;
 wire [0:31] w1;
 assign v7c9bd8 = w1;
 v959751 #(
  .vc5c8ea(p0)
 ) v9f49e7 (
  .vbc97e4(w1)
 );
endmodule

//---------------------------------------------------
//-- 32bits-Value_0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 32bits constant value: 0
//---------------------------------------------------
//---- Top entity
module v959751 #(
 parameter vc5c8ea = 0
) (
 output [31:0] vbc97e4
);
 localparam p0 = vc5c8ea;
 wire [0:31] w1;
 assign vbc97e4 = w1;
 v959751_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- 32-bits-gen-constant
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Generic: 32-bits generic constant
//---------------------------------------------------

module v959751_v465065 #(
 parameter VALUE = 0
) (
 output [31:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module v2b4233 #(
 parameter v55b764 = 1
) (
 input v4c8225,
 output v6d0651
);
 localparam p1 = v55b764;
 wire w0;
 wire w2;
 wire [0:5] w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 assign v6d0651 = w5;
 assign w7 = v4c8225;
 assign w8 = v4c8225;
 assign w9 = v4c8225;
 assign w6 = w2;
 assign w8 = w7;
 assign w9 = w7;
 assign w9 = w8;
 v21cfcc v3023dc (
  .v9fb85f(w4)
 );
 v2814a1 vf701ed (
  .vc7a3dc(w2),
  .v1c1141(w3)
 );
 vef2764 #(
  .v573b2a(p1)
 ) v9d4f65 (
  .v4642b6(w0),
  .v27dec4(w4),
  .v92a149(w6),
  .v6dda25(w8)
 );
 v192520 v2efe33 (
  .v65c173(w0),
  .v15fb32(w3),
  .vdd729a(w9)
 );
 vae13be vb7abdc (
  .ve78ab8(w2),
  .v3487af(w5),
  .ved8395(w7)
 );
endmodule

//---------------------------------------------------
//-- Init-tic
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Emitir un tic inicial al arrancar, y nunca m√°s. Se esperan 32 tics antes de emitir el tic de inicializaci√≥n
//---------------------------------------------------
//---- Top entity
module v21cfcc (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v21cfcc_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

//---------------------------------------------------
//-- 0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Un bit constante a 0
//---------------------------------------------------

module v21cfcc_vb2eccd (
 output q
);
 //-- Bit constante a 0
 assign q = 1'b0;
 
 
endmodule
//---- Top entity
module v2814a1 (
 input [5:0] v1c1141,
 output vc7a3dc,
 output [4:0] vaa52cb
);
 wire [0:5] w0;
 wire [0:4] w1;
 wire w2;
 assign w0 = v1c1141;
 assign vaa52cb = w1;
 assign vc7a3dc = w2;
 v2814a1_v9a2a06 v9a2a06 (
  .i(w0),
  .o0(w1),
  .o1(w2)
 );
endmodule

//---------------------------------------------------
//-- Separador-bus-1-5
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 6-bits en 1 bit y bus de 5 bits
//---------------------------------------------------

module v2814a1_v9a2a06 (
 input [5:0] i,
 output o1,
 output [4:0] o0
);
 assign o1 = i[5];
 assign o0 = i[4:0];
 
endmodule
//---- Top entity
module vef2764 #(
 parameter v573b2a = 0
) (
 input v6dda25,
 input v27dec4,
 input v92a149,
 output v4642b6
);
 localparam p3 = v573b2a;
 wire w0;
 wire w1;
 wire w2;
 wire w4;
 assign w0 = v27dec4;
 assign w1 = v92a149;
 assign w2 = v6dda25;
 assign v4642b6 = w4;
 vef2764_v56c60e #(
  .INI(p3)
 ) v56c60e (
  .set(w0),
  .reset(w1),
  .clk(w2),
  .q(w4)
 );
endmodule

//---------------------------------------------------
//-- RS-FF-set-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- RS-FF-set-verilog. RS Flip-flop with priority set. Implementation in verilog
//---------------------------------------------------

module vef2764_v56c60e #(
 parameter INI = 0
) (
 input clk,
 input set,
 input reset,
 output q
);
 //-- Initial value
 reg qi = INI;
 
 always @(posedge clk)
 begin
 
   //-- Priority on set
   //-- It is first checked
   if (set == 1'b1) 
     qi <= 1'b1;
     
   //-- Second: check reset
   else if (reset == 1'b1)
     qi <= 1'b0;
     
   //-- In any other case the FF
   //-- remains in its current 
   //-- state (no change)
 end
 
 //-- Connect the register with the
 //-- output
 assign q = qi;
 
endmodule
//---- Top entity
module v192520 (
 input vdd729a,
 input v65c173,
 output [5:0] v15fb32
);
 wire w0;
 wire [0:5] w1;
 wire w2;
 assign w0 = vdd729a;
 assign v15fb32 = w1;
 assign w2 = v65c173;
 v192520_ve444b7 ve444b7 (
  .clk(w0),
  .q(w1),
  .ena(w2)
 );
endmodule

//---------------------------------------------------
//-- Contador-6bits-up-system-ena
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Contador del sistema, ascendente, de 6 bits, con enable 
//---------------------------------------------------

module v192520_ve444b7 (
 input clk,
 input ena,
 output [5:0] q
);
 reg [5:0] q_i;
 assign q = q_i;
 
 always @(posedge clk)
 begin
   if (ena)
     q_i <= q_i + 1;
 end
endmodule
//---- Top entity
module vae13be (
 input ved8395,
 input ve78ab8,
 output v1c9ba2,
 output v3487af
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign w0 = ve78ab8;
 assign w1 = ved8395;
 assign w4 = ve78ab8;
 assign v3487af = w5;
 assign w4 = w0;
 v3676a0 v9d4cda (
  .v0e28cb(w2),
  .vcbab45(w3)
 );
 vba518e v57aa83 (
  .v0e28cb(w3),
  .v3ca442(w4),
  .vcbab45(w5)
 );
 v58ed2b v4953b3 (
  .vf54559(w0),
  .va4102a(w1),
  .ve8318d(w2)
 );
endmodule

//---------------------------------------------------
//-- Rising-edge-detector
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Rising-edge detector. It generates a 1-period pulse (tic) when a rising edge is detected on the input. Block implementation
//---------------------------------------------------
//---- Top entity
module v3676a0 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v3676a0_vd54ca1 vd54ca1 (
  .a(w0),
  .q(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- NOT gate (Verilog implementation)
//---------------------------------------------------

module v3676a0_vd54ca1 (
 input a,
 output q
);
 //-- NOT Gate
 assign q = ~a;
 
 
endmodule
//---- Top entity
module vba518e (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vba518e_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Two bits input And gate
//---------------------------------------------------

module vba518e_vf4938a (
 input a,
 input b,
 output c
);
 //-- AND gate
 //-- Verilog implementation
 
 assign c = a & b;
 
endmodule
//---- Top entity
module v58ed2b #(
 parameter v71e305 = 0
) (
 input va4102a,
 input vf54559,
 output va58c5b,
 output ve8318d
);
 localparam p2 = v71e305;
 wire w0;
 wire w1;
 wire w3;
 assign w0 = va4102a;
 assign ve8318d = w1;
 assign w3 = vf54559;
 v58ed2b_vb8adf8 #(
  .INI(p2)
 ) vb8adf8 (
  .clk(w0),
  .q(w1),
  .d(w3)
 );
endmodule

//---------------------------------------------------
//-- sys-DFF-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- System - D Flip-flop. Capture data every system clock cycle. Verilog implementation
//---------------------------------------------------

module v58ed2b_vb8adf8 #(
 parameter INI = 0
) (
 input clk,
 input d,
 output q
);
 //-- Initial value
 reg qi = INI;
 
 //-- Capture the input data  
 //-- on the rising edge of  
 //-- the system clock
 always @(posedge clk)
   qi <= d;
   
 //-- Connect the register with the
 //-- output
 assign q = qi;
endmodule
//---- Top entity
module v0c6f7c #(
 parameter vec4673 = 'h0400_0000,
 parameter v8eaf13 = 'h0400_0001,
 parameter v9c4340 = 100000
) (
 input v87186f,
 input v4dc0ee,
 input [31:0] v867561,
 input v8859f4,
 input [31:0] v23504b,
 output v9127c2,
 output vfe2384,
 output [31:0] v504d16,
 output vf73703,
 output va77527,
 output v34d6ed,
 output v5a58e0,
 output [7:0] vaac567,
 output [6:0] vc02bbb,
 inout v80923c
);
 localparam p0 = v9c4340;
 localparam p1 = v8eaf13;
 localparam p6 = vec4673;
 wire w2;
 wire [0:6] w3;
 wire w4;
 wire [0:7] w5;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire [0:31] w11;
 wire [0:31] w12;
 wire [0:31] w13;
 wire [0:31] w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire [0:31] w28;
 wire [0:31] w29;
 wire [0:3] w30;
 wire w31;
 wire w32;
 wire w33;
 wire [0:6] w34;
 wire [0:6] w35;
 wire [0:31] w36;
 wire [0:7] w37;
 wire [0:2] w38;
 assign vc02bbb = w3;
 assign vaac567 = w5;
 assign v9127c2 = w7;
 assign vfe2384 = w10;
 assign w11 = v867561;
 assign w12 = v867561;
 assign w13 = v867561;
 assign v504d16 = w14;
 assign w15 = v87186f;
 assign w16 = v87186f;
 assign w17 = v87186f;
 assign vf73703 = w18;
 assign w19 = v8859f4;
 assign w20 = v8859f4;
 assign w21 = v4dc0ee;
 assign w22 = v4dc0ee;
 assign w23 = v4dc0ee;
 assign va77527 = w24;
 assign w25 = v80923c;
 assign v5a58e0 = w25;
 assign w26 = v80923c;
 assign v34d6ed = w27;
 assign w28 = v23504b;
 assign w29 = v23504b;
 assign w9 = w8;
 assign w12 = w11;
 assign w13 = w11;
 assign w13 = w12;
 assign w16 = w15;
 assign w17 = w15;
 assign w17 = w16;
 assign w20 = w19;
 assign w22 = w21;
 assign w23 = w21;
 assign w23 = w22;
 assign w24 = w18;
 assign w26 = w25;
 assign w29 = w28;
 assign w35 = w34;
 v0e64bc #(
  .v207e0d(p0)
 ) v9f9653 (
  .v8337bc(w4),
  .v531e20(w15)
 );
 vf9bdaf #(
  .v6b316b(p1)
 ) v3156fe (
  .v18e78c(w2),
  .ve1f562(w13)
 );
 v0c6f7c_vb9f55b vb9f55b (
  .b(w2),
  .slave__out(w3),
  .a(w9),
  .clk(w17),
  .rst_n(w23),
  .z(w27),
  .c(w29),
  .slave_out(w35)
 );
 v0c6f7c_v626e75 v626e75 (
  .clk(w4),
  .I2C_SCL(w7),
  .rstn(w21),
  .I2C_SDA(w26),
  .state_out(w30),
  .enable(w31),
  .rw(w32),
  .busy_out(w33),
  .slv_addr(w34),
  .data_in(w36),
  .data_out(w37),
  .n_paquetes(w38)
 );
 v0c6f7c_vadbda8 #(
  .Addr(p6)
 ) vadbda8 (
  .i2c_cs(w8),
  .addr_in(w11),
  .bit_valid(w19)
 );
 v0c6f7c_vecfcb9 vecfcb9 (
  .check(w5),
  .serdat_cs(w8),
  .bus_data_enable(w10),
  .Bus_addr(w12),
  .bus_data_out(w14),
  .clk(w16),
  .data_ready(w18),
  .valid(w20),
  .rstn(w22),
  .Bus_data(w28),
  .I2C_State(w30),
  .enable_start(w31),
  .rw(w32),
  .I2C_Busy(w33),
  .slv_addr(w34),
  .data_write(w36),
  .data_out(w37),
  .n_paquetes(w38)
 );
endmodule

//---------------------------------------------------
//-- I2C_soc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Perif√©rico encargado de la comunicaci√≥n a trav√©s del bus I2C.
//---------------------------------------------------

module v0c6f7c_vb9f55b (
 input clk,
 input rst_n,
 input a,
 input b,
 input [31:0] c,
 input [6:0] slave_out,
 input rw_out,
 output x,
 output y,
 output z,
 output [6:0] slave__out
);
 reg         reg_x = 0;    // ahora es reg
 reg         reg_y = 0;    // ahora es reg
 reg         reg_z = 0;     // ahora es reg
 
 reg [6:0] slave_addr = 7'd0;   
 
 assign x = reg_x;
 assign y = reg_y;
 assign z = reg_z;
 assign slave__out = slave_addr;
 always @(posedge clk or negedge rst_n) begin
 
     
     if (!rst_n) begin
         // Reset: vuelven a 0
         reg_x <= 1'b0;
         reg_y <= 1'b0;
         reg_z <= 1'b0;
         slave_addr <= 8'd0;   
         
     end else begin
         // Al primer 1 en 'a', si a√∫n no lo hab√≠amos detectado
         if (a && !reg_x)
             reg_x <= 1'b1;
 
         // Al primer 1 en 'b'
         if (b && !reg_y)
             reg_y <= 1'b1;
 
         // Al primer 1 en cualquier bit de 'c' (reducci√≥n OR)
         if (c && !reg_z)
             reg_z <= 1'b1;
         
         if(slave_out && !slave_addr)
             slave_addr <= slave_out;
     end
 end
 
endmodule

module v0c6f7c_v626e75 (
 input clk,
 input rstn,
 input enable,
 input rw,
 input [6:0] slv_addr,
 input [31:0] data_in,
 input [2:0] n_paquetes,
 input I2C_SDA,
 output [3:0] state_out,
 output busy_out,
 output [7:0] data_out,
 output I2C_SCL
);
 // Definir los estados de la m√°quina de estados
 localparam READY       = 4'd0;
 localparam START       = 4'd1;
 localparam COMMAND     = 4'd2;
 localparam SLV_OBJ_ACK = 4'd3;
 localparam WRITE_DATA  = 4'd4;
 localparam WRITE_ACK   = 4'd5;
 localparam READ_DATA   = 4'd6;
 localparam READ_ACK    = 4'd7;
 localparam STOP        = 4'd8;
 
 // Bit m√°s significativos
 localparam max_slv_Addr = 7;
 localparam max_data_wr = 31;
 
 // Registros internos
 reg [3:0] state = READY;            // Estado actual
 reg [2:0] counter = 3'd0;           // Contador local. Cuenta hasta 8 bits de un env√≠o
 reg [2:0] num_paquetes = 3'd0;      // Contador de paquetes a enviar.
 reg [7:0] slave_addr = 8'd0;        // Direcci√≥n del esclavo
 reg read_write = 1'd0;              // Lectura o escritura
 reg [31:0] wt_buffer = 32'b0;       // Buffer de escritura. Mensaje a enviar
 reg [7:0] rd_buffer = 8'd0;         // Buffer de lectura. Mensaje recibido
 reg sda_out = 1'd0;                 // Salida de SDA
 reg write_enable = 1'd0;            // Habilitaci√≥n de SDA
 reg enable_reg = 1'd0;
 reg clk_enable;
 reg busy = 1'd0;                    // Flag de bus ocupado
 reg reg_data_ready = 1'b0;
 
 // Asignaciones
 assign busy_out = busy;
 assign data_out = rd_buffer;
 assign I2C_SCL = clk_enable ? clk : 1'b1;       // Pin de SCL
 assign I2C_SDA = write_enable ? 1'b0 : 1'bz;    // Pin de SDA
 
 //always @(posedge enable) begin
 //    enable_reg <= 1'b1;
 //end
 
 // M√°quina de estados I2C
 always @(posedge clk or negedge rstn) begin
     if (!rstn) begin
         state <= READY;        
         counter <= 3'd0;
         num_paquetes <= 2'd0;  
         sda_out <= 1'b1;
         slave_addr <= 8'd0;       
         read_write <= 1'd0;
         wt_buffer <= 24'b0;       
         rd_buffer <= 8'd0;                
         write_enable <= 1'd0;           
         busy <= 1'd0;
         reg_data_ready <= 1'b0;
         enable_reg <= 1'b0;
     end else begin
         case (state)
             READY: begin
                 reg_data_ready <= 1'b0;
                 write_enable <= 1'b0;
                 busy <= enable;
                 if (enable && !enable_reg) begin
                     enable_reg <= 1'b1;
                 end
                 if (enable_reg) begin
                     num_paquetes <= n_paquetes;
                     read_write <= rw;
                     slave_addr <= {slv_addr, rw};
                     wt_buffer <= data_in;
                     enable_reg <= 1'b0;
                     state <= START;
                 end
             end
             START: begin
                 busy <= 1'b1;
                 write_enable <= 1'b1;
                 counter <= 3'd7;
                 sda_out <= slave_addr[max_slv_Addr];               
                 state <= COMMAND;  
             end
             COMMAND: begin
                 if (counter == 3'd0) begin
                     //write_enable <= 1'b0;
                     sda_out <= 1'b0;  // Finaliza el env√≠o de la direcci√≥n
                     state <= SLV_OBJ_ACK;
                 end else begin
                     counter <= counter - 1;
                     slave_addr <= slave_addr << 1; // Desplaza la direcci√≥n del esclavo
                     sda_out <= slave_addr[max_slv_Addr];
                 end
             end
             SLV_OBJ_ACK: begin
                 // Chequear ACK del esclavo. No est√° en el verilog
                 if (I2C_SDA == 1'b1) begin  // Write
                     counter <= 3'd7;
                     write_enable <= 1'b1;
                     sda_out <= wt_buffer[max_data_wr];
                     state <= WRITE_DATA;
                 end else begin               // Read
                     counter <= 3'd7;
                     write_enable <= 1'b0;
                     state <= READ_DATA;
                 end
             end
             WRITE_DATA: begin
                 busy <= 1'b1;
                 if (counter == 3'd0) begin
                     write_enable <= 1'b0;
                     num_paquetes <= num_paquetes - 1'b1;
                     sda_out <= 1'b0;
                     state <= WRITE_ACK;
                 end else begin
                     counter <= counter - 1;
                     wt_buffer <= wt_buffer << 1;
                     sda_out <= wt_buffer[max_data_wr];
                 end
             end
             READ_DATA: begin
                 rd_buffer[counter] <= I2C_SDA;
                 if (counter == 3'd0) begin
                     state <= READ_ACK;
                 end else begin 
                     counter <= counter - 1;
                 end
             end
             WRITE_ACK: begin
                 if (enable == 1'b1) begin
                     if (num_paquetes > 2'b0) begin
                         counter <= 3'd7;
                         write_enable <= 1'b1;
                         sda_out <= wt_buffer[max_data_wr];
                         state <= WRITE_DATA;
                     end else begin
                         state <= STOP;
                     end
                 end else begin 
                     state <= STOP;
                 end
             end
             READ_ACK: begin
                 busy <= 1'b0;
                 write_enable <= 1'b1;
                 sda_out <= 1'b0;
                 reg_data_ready <= 1'b1;
                 state <= STOP;
             end
             STOP: begin
                 write_enable <= 1'b1;
                 sda_out <= 1'b1;
                 busy <= 1'b0;
                 state <= READY;
             end
         endcase
     end
 end
 
 // Control s√≠ncrono de SCL enable
 always @(posedge clk) begin
     if (!rstn)
         clk_enable <= 1'b0;
     else
         clk_enable <= (state != READY) && (state != START) && (state != STOP);
 end
endmodule

module v0c6f7c_vadbda8 #(
 parameter Addr = 0
) (
 input [31:0] addr_in,
 input bit_valid,
 output i2c_cs
);
 assign i2c_cs = (addr_in[31:6] == Addr[31:6]) & bit_valid;
endmodule

module v0c6f7c_vecfcb9 (
 input clk,
 input rstn,
 input valid,
 input [31:0] Bus_addr,
 input [31:0] Bus_data,
 input serdat_cs,
 input [3:0] I2C_State,
 input I2C_Busy,
 input [7:0] data_out,
 output enable_start,
 output rw,
 output [6:0] slv_addr,
 output [31:0] data_write,
 output [2:0] n_paquetes,
 output bus_data_enable,
 output [31:0] bus_data_out,
 output [7:0] check,
 output data_ready
);
 parameter W_SLV_ADDR        = 3'b000;  // 0x04000000
 parameter W_RW              = 3'b001;  // 0x04000004
 parameter W_N_PQTS          = 3'b010;  // 0x04000008
 parameter R_STATE           = 3'b011;  // 0x0400000C
 parameter R_BUSY            = 3'b100;  // 0x04000010
 parameter R_DATA_OUT        = 3'b101;  // 0x04000014
 parameter S_ENABLE          = 3'b110;  // 0x04000018
 parameter W_DATA_WRITE      = 3'b111;  // 0x0400001C
 
 // √çndice en el array de registros
 parameter slv_addr_register         = 0;
 parameter rw_register               = 1;
 parameter num_pqts_register         = 2;
 parameter state_register            = 3;
 parameter busy_register             = 4;
 parameter data_out_register         = 5;
 parameter enable_register           = 6;
 parameter bus_data_enable_register  = 7;
 
 
 //Entrada desde bus de datos
 reg [7:0] dataArray [7:0];
 reg [31:0] buffer_data_out;
 reg [31:0] data_wr = 32'b0;
 
 reg ack_r;          // pulso a CLK del bus
 assign bus_data_enable = ack_r;
 assign data_ready = ack_r;
 
 
 assign slv_addr[6:0] = dataArray[slv_addr_register][6:0];      
 assign rw = dataArray[rw_register][0];                   
 assign n_paquetes[2:0] = dataArray[num_pqts_register][2:0];    
 
 assign enable_start = dataArray[enable_register][0];                                    
 assign bus_data_enable = dataArray[bus_data_enable_register][0];      
 
 assign data_write = data_wr;             
 assign bus_data_out = buffer_data_out;     
 assign check = dataArray[W_N_PQTS];
 
 wire serdat_write = Bus_addr[5];
 
 always @(posedge clk or negedge rstn) begin
     if (!rstn) begin
         // Reset completo de los registros
         dataArray[0] <= 8'b0;
         dataArray[1] <= 8'b0;
         dataArray[2] <= 8'b0;
         dataArray[3] <= 8'b0;
         dataArray[4] <= 8'b0;
         dataArray[5] <= 8'b0;
         dataArray[6] <= 8'b0;
         dataArray[7] <= 8'b0;
         buffer_data_out <= 32'b0;
         data_wr <= 32'b0;
 
     end else begin
         // Registros actualizados por hardware (FSM)
         dataArray[state_register]    <= {4'b0, I2C_State};
         dataArray[busy_register]     <= {7'b0, I2C_Busy};
         dataArray[data_out_register] <= data_out;
         
 
         // Interfaz externa desde CPU
         if (serdat_cs) begin
         ack_r <= 1'b1;
             if (serdat_write) begin
                 // ----------- ESCRITURA -----------
                 if (Bus_addr[4:2] == W_DATA_WRITE) begin
                     data_wr <= Bus_data;
                 end else begin
                     dataArray[Bus_addr[4:2]] <= Bus_data[7:0];
                 end
             end else begin
                 // ----------- LECTURA -----------
                 buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
                 //dataArray[bus_data_enable_register] <= 8'b00000001;
             end 
         end else begin
             ack_r <= 1'b0;       // al siguiente ciclo vuelve a 0
         end
 
         // Limpieza de registros de un solo ciclo
         dataArray[enable_register] <= 8'b0;
     end
 end
 
endmodule
//---- Top entity
module v0e64bc #(
 parameter v207e0d = 1
) (
 input v531e20,
 output v8337bc
);
 localparam p2 = v207e0d;
 wire w0;
 wire w1;
 assign v8337bc = w0;
 assign w1 = v531e20;
 v0e64bc_v94c6d7 #(
  .HZ(p2)
 ) v94c6d7 (
  .clk_o(w0),
  .clk(w1)
 );
endmodule

//---------------------------------------------------
//-- Corazon_Hz
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Corazon gen√©rico para bombear bits a la frecuencia fijada en Hz (por defecto 1Hz)
//---------------------------------------------------

module v0e64bc_v94c6d7 #(
 parameter HZ = 0
) (
 input clk,
 output clk_o
);
 
 //parameter HZ=1;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000/HZ;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- REgistro con el valor del reloj
 reg clk_out = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_out <= ~clk_out;
 
 
 assign clk_o = clk_out;  
 
endmodule
//---- Top entity
module vf9bdaf #(
 parameter v6b316b = 0
) (
 input [31:0] ve1f562,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = ve1f562;
 vf9bdaf_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 32 bits. Se compara si el operando es igual al par√°metro
//---------------------------------------------------

module vf9bdaf_vd75681 #(
 parameter K = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a == K);
endmodule

module main_v3541f5 (
 input rst,
 input a,
 output x
);
 reg salida = 0;
 
 assign x = salida;
 
 always @(posedge a or negedge rst) begin
         if (!rst)
             salida <= 0;
         else
             if (!salida)
                 salida <= 1'b1;
     end
endmodule



Actualmente, el dise√±o est√° as√≠. Qu√© m√°s faltar√≠a por hacer? A√∫n se atasca. He puesto un led pinchado a la se√±al ack_r pero no veo actividad aqu√≠ incluso escribiendo en los registros. Tampoco veo que lo que escriba en los registros se guarde
ChatGPT said:

Aqu√≠ es donde siguen los atascos y c√≥mo arreglarlos.
S√≠ntoma	Causa en el fichero v0c6f7c_vecfcb9	Arreglo
El LED atado a ack_r nunca parpadea
(y la CPU se queda esperando)	Declaras dos drivers para la misma red:```verilog	
assign bus_data_enable = ack_r; // ‚ù∂		
‚Ä¶		
assign bus_data_enable = dataArray[bus_data_enable_register][0]; // ‚ù∑ (l√≠nea duplicada)		
```
En s√≠ntesis eso produce una ‚Äúred con m√∫ltiples manejadores‚Äù ‚áí se fuerza a X, as√≠ la CPU nunca ve tu ACK y se bloquea.	Elimina la segunda asignaci√≥n (‚ù∑) y, si ya no la necesitas, borra el registro bus_data_enable_register.	
Nada se guarda en los registros	El detector de escritura est√° mal: ```verilog	
wire serdat_write = Bus_addr[5]; // ¬°siempre 0 para 0x0400_00xx!```	Usa la se√±al real de ‚Äúwrite enable‚Äù que entra por el bus:
```verilog	
wire serdat_write = serdat_cs & valid; // 'valid' es v8859f4 (mem_wstrb‚â†0)		

| `ack_r` nunca se levanta| Se pone a `1`‚Ä¶ pero **nunca lo llevas al pin** porque lo machacas con la l√≠nea duplicada de arriba.| Al corregir la colisi√≥n de asignaciones el pulso llegar√° a la salida y al LED.|

---

### Parche m√≠nimo (solo la interfaz)

```verilog
// ‚Ä¶ dentro de v0c6f7c_vecfcb9 ‚Ä¶

// ------------ se√±ales de salida -----------------
reg  ack_r;                 // pulso de 1 ciclo
assign bus_data_enable = ack_r;   // <- √öNICA asignaci√≥n
assign data_ready      = ack_r;   // si lo quieres tambi√©n al exterior

// ------------ l√≥gica de acceso ------------------
wire serdat_write = serdat_cs & valid;   // WE real

always @(posedge clk or negedge rstn) begin
    if (!rstn) begin
        integer i;
        for (i = 0; i < 8; i = i+1) dataArray[i] <= 8'b0;
        data_wr         <= 32'b0;
        buffer_data_out <= 32'b0;
        ack_r           <= 1'b0;
    end else begin
        // registros que actualiza la FSM I¬≤C
        dataArray[state_register]    <= {4'b0, I2C_State};
        dataArray[busy_register]     <= {7'b0, I2C_Busy};
        dataArray[data_out_register] <= data_out;

        // acceso desde la CPU
        if (serdat_cs) begin
            ack_r <= 1'b1;          // pulso de reconocimiento
            if (serdat_write) begin
                if (Bus_addr[4:2] == W_DATA_WRITE)
                    data_wr <= Bus_data;
                else
                    dataArray[Bus_addr[4:2]] <= Bus_data[7:0];
            end else begin
                buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
            end
        end else begin
            ack_r <= 1'b0;          // vuelve a 0 autom√°ticamente
        end

        // flags ‚Äúun-shot‚Äù
        dataArray[enable_register] <= 8'b0;
    end
end

Cambios clave:

    Una sola l√≠nea assign bus_data_enable = ack_r;
    (borra la que usaba dataArray[bus_data_enable_register]).

    serdat_write = serdat_cs & valid.

    Pulso ack_r generado siempre que serdat_cs est√© activo; vuelve a 0 al siguiente reloj.

Con esto:

    El LED en ack_r parpadear√° cada vez que el RISC-V haga un acceso al bloque I¬≤C.

    La CPU recibir√° el ‚ÄúACK‚Äù en el mismo ciclo y nunca se colgar√°.

    Las escrituras (W_SLV_ADDR, W_RW, ‚Ä¶) se almacenar√°n correctamente y podr√°s leerlas en software.

Verificar r√°pido

    Reconecta tu LED al pin que lleva bus_data_enable (ahora = ack_r).

    Vuelve a sintetizar y programar la placa.

    Desde el programa en C, haz algo tan simple como:

*(volatile uint8_t*)0x04000000 = 0x55;   // W_SLV_ADDR

Deber√≠as ver un solo destello del LED y, si lees de nuevo la misma direcci√≥n, recibir 0x55.

Cuando esto funcione podemos seguir depurando la FSM I¬≤C, pero sin el hand-shake correcto la placa siempre se quedar√° en ‚Äúbusy-wait‚Äù.
You said:
Comprueba la interfaz. Qu√© m√°s cambios hay que hacer?
ChatGPT said:

Estos son los √∫ltimos flecos que hay que rematar para que la interfaz-bus quede s√≥lida y el procesador no se cuelgue nunca m√°s.
Bloque	Problema que a√∫n queda	Qu√© hay que tocar exactamente
1. Se√±al write enable (serdat_write)	Seguimos usando Bus_addr[5] como ‚Äúflag de escritura‚Äù, y eso vale cero para todas las direcciones 0x0400 0000‚Ä¶1C ‚áí nunca grabamos nada.	
1.1 A√±ade una nueva entrada al m√≥dulo v0c6f7c_vecfcb9:
input [3:0] mem_wstrb, // cualquier bit‚â†0 ‚Üí ciclo de escritura
1.2 En el top (v0c6f7c) con√©ctalo a la se√±al que sale del n√∫cleo PicoRV32 (v83dbbe, 4 bits).
1.3 Dentro de vecfcb9 sustituye:
wire serdat_write = Bus_addr[5];
por:
`wire serdat_write = serdat_cs &
2. Dos ‚Äúdrivers‚Äù para la misma red (bus_data_enable)	Ya quitaste la l√≠nea duplicada, pero el registro bus_data_enable_register sigue sin funci√≥n y ocupa LUTs.	Borra todo lo relativo a bus_data_enable_register (par√°metro, √≠ndice y la l√≠nea que lo limpia). ack_r es ahora tu √∫nico ack hacia el bus.
3. Pulso ack_r demasiado corto	El RISC-V mantiene mem_valid a ‚Äò1‚Äô hasta que mem_ready se le ponga a ‚Äò1‚Äô. Con un pulso de 1 ciclo a veces acierta, a veces no (depende de la fase).	Pon ack_r alto mientras dure la transacci√≥n:
```verilog
if (serdat_cs && !ack_r) ack_r <= 1'b1; // lev√°ntalo		
else if (!serdat_cs) ack_r <= 1'b0; // b√°jalo		

| **4.  Lecturas de palabra completa** (registro `W_DATA_WRITE`) | Si lees 0x0400 001C solo devuelves byte 0; el software querr√° ver los 32 bits que acaba de escribir. | En la rama de lectura:<br>```verilog
if (Bus_addr[4:2] == W_DATA_WRITE)
    buffer_data_out <= data_wr;
else
    buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
``` |
| **5.  Tristado de la l√≠nea SDA** | `I2C_SDA` siempre sale a ‚Äò0‚Äô cuando `write_enable=1`, ignores `sda_out`. | Sustituye<br>`assign I2C_SDA = write_enable ? 1'b0 : 1'bz;`<br>por<br>`assign I2C_SDA = write_enable ? sda_out : 1'bz;` |
| **6.  _Chip-select_ solo para escrituras** (`v0c6f7c_vadbda8`) | `bit_valid` = `mem_valid`, perfecto. Si en alg√∫n momento cambiaste esto, aseg√∫rate de **no** usar `mem_wstrb`; las lecturas necesitan el CS tanto como las escrituras. | (Nada que tocar si ya usas `mem_valid`). |
| **7.  Se√±al `data_ready`** | En la FSM I¬≤C levantas `reg_data_ready`, pero nunca la exportas a la interfaz. | Conecta `data_ready` a `reg_data_ready` (igual que haces con `busy`). Eso permite al firmware saber cu√°ndo hay byte recibido. |

---

### Resumen de cambios en el m√≥dulo **`v0c6f7c_vecfcb9`**

```verilog
module v0c6f7c_vecfcb9 (
    input  clk,
    input  rstn,
    input  serdat_cs,
    input  [3:0]  mem_wstrb,      // <- nuevo
    input  [31:0] Bus_addr,
    input  [31:0] Bus_data,
    ...
    output bus_data_enable,
    output data_ready,
    ...
);

//------------------------------------------------------------------
// 1.  handshake con el bus
//------------------------------------------------------------------
reg ack_r;
assign bus_data_enable = ack_r;   // mem_ready
assign data_ready      = reg_data_ready;  // aviso byte recibido

wire serdat_write = serdat_cs & |mem_wstrb;   // ‚Üê write real

//------------------------------------------------------------------
// 2.  l√≥gica de acceso
//------------------------------------------------------------------
always @(posedge clk or negedge rstn) begin
    if (!rstn) begin
        integer i;
        for (i=0;i<8;i=i+1) dataArray[i] <= 8'd0;
        data_wr         <= 32'd0;
        buffer_data_out <= 32'd0;
        ack_r           <= 1'b0;
    end else begin
        // registros que actualiza la FSM I2C
        dataArray[state_register]    <= {4'b0, I2C_State};
        dataArray[busy_register]     <= {7'b0, I2C_Busy};
        dataArray[data_out_register] <= data_out;

        //----------------------------------------------------------
        // acceso desde la CPU
        //----------------------------------------------------------
        if (serdat_cs) begin
            ack_r <= 1'b1;                       // mantiene READY
            if (serdat_write) begin              // --------------- WRITE
                if (Bus_addr[4:2] == W_DATA_WRITE)
                    data_wr <= Bus_data;
                else
                    dataArray[Bus_addr[4:2]] <= Bus_data[7:0];
            end else begin                       // ---------------- READ
                if (Bus_addr[4:2] == W_DATA_WRITE)
                    buffer_data_out <= data_wr;
                else
                    buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
            end
        end else begin
            ack_r <= 1'b0;                       // baja cuando termina
        end

        // flags de un solo ciclo
        dataArray[enable_register] <= 8'b0;
    end
end

Conexiones nuevas en el top (v0c6f7c)

.v0c6f7c_vecfcb9(
    ...
    .mem_wstrb (w10),   // w10 = v83dbbe  (mem_wstrb desde el core)
    ...
)

(Verifica el nombre exacto de la se√±al w10 en tu sintesis; es la de 4 bits que ya sale del PicoRV32.)
Prueba r√°pida

volatile uint32_t * const I2C_BASE = (uint32_t*)0x04000000;

I2C_BASE[W_SLV_ADDR]   = 0x4A;        // escritura
uint32_t leido         = I2C_BASE[W_SLV_ADDR];  // lectura

if (leido != 0x4A) while(1);          // debe coincidir

    El LED (conectado a ack_r) debe parpadear dos veces: una al escribir y otra al leer.

    El programa nunca debe quedarse bloqueado esperando al bus.

Una vez confirmes que esto funciona, lo siguiente es depurar la FSM I¬≤C (ACKs reales del esclavo, stretching del reloj, etc.), pero la ruta cr√≠tica de la interfaz con el procesador quedar√° saneada.
You said:
parameter W_SLV_ADDR        = 3'b000;  // 0x04000000
parameter W_RW              = 3'b001;  // 0x04000004
parameter W_N_PQTS          = 3'b010;  // 0x04000008
parameter R_STATE           = 3'b011;  // 0x0400000C
parameter R_BUSY            = 3'b100;  // 0x04000010
parameter R_DATA_OUT        = 3'b101;  // 0x04000014
parameter S_ENABLE          = 3'b110;  // 0x04000018
parameter W_DATA_WRITE      = 3'b111;  // 0x0400001C

// √çndice en el array de registros
parameter slv_addr_register         = 0;
parameter rw_register               = 1;
parameter num_pqts_register         = 2;
parameter state_register            = 3;
parameter busy_register             = 4;
parameter data_out_register         = 5;
parameter enable_register           = 6;


//Entrada desde bus de datos
reg [7:0] dataArray [7:0];
reg [31:0] buffer_data_out;
reg [31:0] data_wr = 32'b0;

reg ack_r;          // pulso a CLK del bus
assign bus_data_enable = ack_r;


assign slv_addr[6:0] = dataArray[slv_addr_register][6:0];      
assign rw = dataArray[rw_register][0];                   
assign n_paquetes[2:0] = dataArray[num_pqts_register][2:0];    

assign enable_start = dataArray[enable_register][0];                 

assign data_write = data_wr;             
assign bus_data_out = buffer_data_out;     
assign check = dataArray[W_N_PQTS];

wire serdat_write = Bus_addr[5];

always @(posedge clk or negedge rstn) begin
    if (serdat_cs && !ack_r)   // sube UNA vez cuando valid est√° alto
        ack_r <= 1'b1;
    else begin
        ack_r <= 1'b0;  
    end
    if (!rstn) begin
        // Reset completo de los registros
        dataArray[0] <= 8'b0;
        dataArray[1] <= 8'b0;
        dataArray[2] <= 8'b0;
        dataArray[3] <= 8'b0;
        dataArray[4] <= 8'b0;
        dataArray[5] <= 8'b0;
        dataArray[6] <= 8'b0;
        dataArray[7] <= 8'b0;
        buffer_data_out <= 32'b0;
        data_wr <= 32'b0;
        ack_r <= 1'b0;

    end else begin
        // Registros actualizados por hardware (FSM)
        dataArray[state_register]    <= {4'b0, I2C_State};
        dataArray[busy_register]     <= {7'b0, I2C_Busy};
        dataArray[data_out_register] <= data_out;
        

        // Interfaz externa desde CPU
        if (serdat_cs) begin
        ack_r <= 1'b1;
            if (serdat_write) begin
                // ----------- ESCRITURA -----------
                if (Bus_addr[4:2] == W_DATA_WRITE) begin
                    data_wr <= Bus_data;
                end else begin
                    dataArray[Bus_addr[4:2]] <= Bus_data[7:0];
                end
            end else begin
                // ----------- LECTURA -----------
                buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
            end 
        end else begin
            ack_r <= 1'b0;       // al siguiente ciclo vuelve a 0
        end

        // Limpieza de registros de un solo ciclo
        dataArray[enable_register] <= 8'b0;
    end

end

As√≠ es correcto?¬ø?¬ø
ChatGPT said:

Todav√≠a hay tres puntos (clave) que hay que retocar; el resto del m√≥dulo est√° bien.
#	Qu√© ocurre con el c√≥digo que has pegado	C√≥mo arreglarlo
1	ack_r se asigna 4 veces en el mismo always.
En Verilog eso genera un √∫nico registro cuyo valor es el de la √∫ltima asignaci√≥n que encuentre el simulador/s√≠ntesis; las otras quedan anuladas ‚Üí comportamientos raros.	Deja una sola asignaci√≥n secuencial a ack_r.
```verilog
always @(posedge clk or negedge rstn) begin		

if (!rstn)
    ack_r <= 1'b0;
else
    ack_r <= serdat_cs;   // alto mientras dure la transacci√≥n

end

| **2** | `serdat_write` sigue siendo `Bus_addr[5]`.  Ese bit vale ‚Äò0‚Äô en **todas** las direcciones 0x0400 0000-1C, por eso nunca escribes nada. | 1. Declara la se√±al de ‚Äústrobe de escritura‚Äù que ya tienes en el SoC (salida `mem_wstrb` del PicoRV32).  <br>2. A√±√°dela como entrada al m√≥dulo:  <br>`input  [3:0] mem_wstrb,`  <br>3. Usa:<br>`wire serdat_write = serdat_cs & |mem_wstrb;` |
| **3** | Cuando la CPU lee 0x0400 001C solo devuelves el byte [7:0]; el firmware espera los **32 bits** que acaba de poner. | En la rama de lectura:<br>```verilog
if (Bus_addr[4:2] == W_DATA_WRITE)
    buffer_data_out <= data_wr;
else
    buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
``` |

---

### Versi√≥n depurada (extracto)

```verilog
module v0c6f7c_vecfcb9 (
    input  clk,
    input  rstn,
    // handshake con el bus
    input  serdat_cs,
    input  [3:0] mem_wstrb,         // <- NUEVO
    input  [31:0] Bus_addr,
    input  [31:0] Bus_data,
    ...
    output bus_data_enable,
    ...
);

reg ack_r;
assign bus_data_enable = ack_r;

// ------------------------- write / read flag --------------------
wire serdat_write = serdat_cs & |mem_wstrb;     // ‚Üê correcto

// ------------------------- registro ACK -------------------------
always @(posedge clk or negedge rstn) begin
    if (!rstn)
        ack_r <= 1'b0;
    else
        ack_r <= serdat_cs;        // alto mientras dure la transacci√≥n
end

// ------------------------- l√≥gica principal ---------------------
always @(posedge clk or negedge rstn) begin
    if (!rstn) begin
        integer i;
        for (i=0;i<7;i=i+1) dataArray[i] <= 8'd0;
        data_wr         <= 32'd0;
        buffer_data_out <= 32'd0;
    end else begin
        // registros que actualiza la FSM I2C
        dataArray[state_register]    <= {4'b0, I2C_State};
        dataArray[busy_register]     <= {7'b0, I2C_Busy};
        dataArray[data_out_register] <= data_out;

        // ---------------- acceso CPU -----------------
        if (serdat_cs) begin
            if (serdat_write) begin             // ------------ WRITE
                if (Bus_addr[4:2] == W_DATA_WRITE)
                    data_wr <= Bus_data;
                else
                    dataArray[Bus_addr[4:2]] <= Bus_data[7:0];
            end else begin                      // ------------- READ
                if (Bus_addr[4:2] == W_DATA_WRITE)
                    buffer_data_out <= data_wr;
                else
                    buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
            end
        end

        // pulso √∫nico
        dataArray[enable_register] <= 8'b0;
    end
end

En el top (v0c6f7c) conecta la nueva entrada:

.v0c6f7c_vecfcb9(
    ...
    .mem_wstrb (v83dbbe),   // los 4 bits que salen del n√∫cleo
    ...
)

Con estos tres cambios:

    se elimina la colisi√≥n de asignaciones a ack_r,

    la interfaz reconoce correctamente lecturas y escrituras, y

    el software puede leer de vuelta los 32 bits completos.

Prueba:

*(volatile uint32_t*)0x0400001C = 0xBEBAFACE;
if (*(volatile uint32_t*)0x0400001C != 0xBEBAFACE) while(1);

El LED unido a ack_r deber√° permanecer alto todo el ciclo que dura cada acceso, y ver√°s la palabra completa al leer.


ChatGPT can make mistakes. Check important info. See Cookie Preferences.

