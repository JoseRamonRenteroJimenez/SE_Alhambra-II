// Code generated by Icestudio 0.12
// Thu, 01 May 2025 13:38:45 GMT

`default_nettype none

//---- Top entity
module main #(
 parameter v269dbc = 'h0400_0000,
 parameter v9c4340 = 100000
) (
 input v87186f,
 input v4dc0ee,
 input [31:0] v867561,
 input v8859f4,
 input [31:0] v23504b,
 output v9127c2,
 output vfe2384,
 output [31:0] v504d16,
 output vf73703,
 output va77527,
 output v34d6ed,
 output [0:7] vinit,
 inout v80923c
);
 localparam p0 = v269dbc;
 localparam p2 = v9c4340;
 wire w1;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire [0:31] w7;
 wire [0:31] w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire [0:31] w16;
 wire [0:31] w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire [0:31] w24;
 wire w25;
 wire [0:3] w26;
 wire w27;
 wire w28;
 wire [0:6] w29;
 wire [0:23] w30;
 wire [0:7] w31;
 wire [0:1] w32;
 assign v9127c2 = w4;
 assign vfe2384 = w5;
 assign v504d16 = w7;
 assign w9 = v87186f;
 assign w10 = v87186f;
 assign w11 = v87186f;
 assign vf73703 = w12;
 assign w13 = v4dc0ee;
 assign w14 = v4dc0ee;
 assign w15 = v4dc0ee;
 assign w16 = v867561;
 assign w17 = v867561;
 assign va77527 = w18;
 assign w21 = v80923c;
 assign v34d6ed = w22;
 assign w23 = v8859f4;
 assign w24 = v23504b;
 assign w6 = w5;
 assign w8 = w7;
 assign w10 = w9;
 assign w11 = w9;
 assign w11 = w10;
 assign w14 = w13;
 assign w15 = w13;
 assign w15 = w14;
 assign w17 = w16;
 assign w20 = w19;
 vf9bdaf #(
  .v6b316b(p0)
 ) v72f060 (
  .v18e78c(w1),
  .ve1f562(w16)
 );
 vb2090f vef47e6 (
  .v0e28cb(w1),
  .vcbab45(w19),
  .v3ca442(w23)
 );
 v0e64bc #(
  .v207e0d(p2)
 ) v9f9653 (
  .v8337bc(w3),
  .v531e20(w9)
 );
 main_vb9f55b vb9f55b (
  .b(w6),
  .c(w8),
  .clk(w11),
  .x(w12),
  .rst_n(w15),
  .y(w18),
  .a(w20),
  .z(w22)
 );
 main_v9294e6 v9294e6 (
  .clk(w3),
  .I2C_SCL(w4),
  .rstn(w13),
  .I2C_SDA(w21),
  .enable(w25),
  .state_out(w26),
  .rw(w27),
  .busy_out(w28),
  .slv_addr(w29),
  .data_in(w30),
  .data_out(w31),
  .n_paquetes(w32)
 );
 main_vecfcb9 vecfcb9 (
  .bus_data_enable(w5),
  .bus_data_out(w7),
  .clk(w10),
  .rstn(w14),
  .Bus_addr(w17),
  .serdat_cs(w19),
  .Bus_data(w24),
  .enable_start(w25),
  .I2C_State(w26),
  .rw(w27),
  .I2C_Busy(w28),
  .slv_addr(w29),
  .data_write(w30),
  .data_out(w31),
  .n_paquetes(w32)
 );
 assign vinit = 8'b00000000;
endmodule

//---------------------------------------------------
//-- I2C_soc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Periférico encargado de la comunicación a través del bus I2C.
//---------------------------------------------------
//---- Top entity
module vf9bdaf #(
 parameter v6b316b = 0
) (
 input [31:0] ve1f562,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = ve1f562;
 vf9bdaf_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 32 bits. Se compara si el operando es igual al parámetro
//---------------------------------------------------

module vf9bdaf_vd75681 #(
 parameter K = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a[23:8] == K[23:8]);
endmodule
//---- Top entity
module vb2090f (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vb2090f_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND
//---------------------------------------------------

module vb2090f_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta AND
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a & b;
 
 //-- endmodule
endmodule
//---- Top entity
module v0e64bc #(
 parameter v207e0d = 1
) (
 input v531e20,
 output v8337bc
);
 localparam p2 = v207e0d;
 wire w0;
 wire w1;
 assign v8337bc = w0;
 assign w1 = v531e20;
 v0e64bc_v94c6d7 #(
  .HZ(p2)
 ) v94c6d7 (
  .clk_o(w0),
  .clk(w1)
 );
endmodule

//---------------------------------------------------
//-- Corazon_Hz
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Corazon genérico para bombear bits a la frecuencia fijada en Hz (por defecto 1Hz)
//---------------------------------------------------

module v0e64bc_v94c6d7 #(
 parameter HZ = 0
) (
 input clk,
 output clk_o
);
 
 //parameter HZ=1;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000/HZ;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- REgistro con el valor del reloj
 reg clk_out = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_out <= ~clk_out;
 
 
 assign clk_o = clk_out;  
 
endmodule

module main_vb9f55b (
 input clk,
 input rst_n,
 input a,
 input b,
 input [31:0] c,
 output x,
 output y,
 output z
);
 reg         reg_x = 0;    // ahora es reg
 reg         reg_y = 0;    // ahora es reg
 reg         reg_z = 0;     // ahora es reg
 
 assign x = reg_x;
 assign y = reg_y;
 assign z = reg_z;
 always @(posedge clk or negedge rst_n) begin
 
     
     if (!rst_n) begin
         // Reset: vuelven a 0
         reg_x <= 1'b0;
         reg_y <= 1'b0;
         reg_z <= 1'b0;
     end else begin
         // Al primer 1 en 'a', si aún no lo habíamos detectado
         if (a && !reg_x)
             reg_x <= 1'b1;
 
         // Al primer 1 en 'b'
         if (b && !reg_y)
             reg_y <= 1'b1;
 
         // Al primer 1 en cualquier bit de 'c' (reducción OR)
         if (|c && !reg_z)
             reg_z <= 1'b1;
     end
 end
 
endmodule

module main_v9294e6 (
 input clk,
 input rstn,
 input enable,
 input rw,
 input [6:0] slv_addr,
 input [23:0] data_in,
 input [1:0] n_paquetes,
 output [3:0] state_out,
 output busy_out,
 output [7:0] data_out,
 output I2C_SCL,
 inout I2C_SDA
);
 // Definir los estados de la máquina de estados
 localparam READY       = 4'd0;
 localparam START       = 4'd1;
 localparam COMMAND     = 4'd2;
 localparam SLV_OBJ_ACK = 4'd3;
 localparam WRITE_DATA  = 4'd4;
 localparam WRITE_ACK   = 4'd5;
 localparam READ_DATA   = 4'd6;
 localparam READ_ACK    = 4'd7;
 localparam STOP        = 4'd8;
     
 reg [3:0] state = READY;        // Estado actual
 reg [2:0] counter = 3'd0;          // Contador local. Cuenta hasta 8 bits de un envío
                                 // No tiene en cuenta el mensaje completo, solo el paquete actual
 reg [1:0] num_paquetes = 2'd0;      // Contador de paquetes a enviar.
                                     // Tiene en cuenta el mensaje completo
 reg [7:0] slave_addr = 8'd0;       // Dirección del esclavo
 reg read_write = 1'd0;              // Lectura o escritura
 reg [23:0] wt_buffer = 24'b0;       // Buffer de escritura. Mensaje a enviar
 reg [7:0] rd_buffer = 8'd0;        // Buffer de lectura. Mensaje recibido
 reg sda_out = 1'd0;                // Salida de SDA
 reg write_enable = 1'd0;           // Habilitación de SDA
 
 reg clk_enable;
 reg busy = 1'd0;               // Flag de bus ocupado
 reg reg_data_ready = 1'b0;
     
 assign busy_out = busy;
 assign data_out = rd_buffer;
     
 assign I2C_SCL = clk_enable ? clk : 1'b1;       // Pin de SCL
 assign I2C_SDA = write_enable ? sda_out : 1'bz;  // Pin de SDA
 
 // Máquina de estados I2C
 always @(posedge clk) begin
     if (!rstn) begin
         state <= READY;        
         counter <= 3'd0; //Contador a 0 (cuenta hasta 7, número de 3 bits: 3'd0 representa 0 decimal en formato de 3 bits)
         num_paquetes <= 2'd0;  
         sda_out <= 1'b1;
         slave_addr <= 8'd0;       
         read_write <= 1'd0;
         wt_buffer <= 24'b0;       
         rd_buffer <= 8'd0;                
         write_enable <= 1'd0;           
         busy <= 1'd0;
         reg_data_ready <= 1'b0;
 
     end else begin
         case (state)
             READY: begin
                 reg_data_ready <= 1'b0;
                 write_enable <= 1'b0;
                 busy <= enable;
                 if (enable) begin
                     num_paquetes <= n_paquetes;
                     read_write <= rw;
                     slave_addr <= {slv_addr, rw};
                     wt_buffer <= data_in;
                     state <= START;
                 end
             end
             START: begin
                 busy <= 1'b1;
                 write_enable <= 1'b1;
                 counter <= 3'd7;
                 sda_out <= slave_addr[counter];               
                 state <= COMMAND;  
             end
             COMMAND: begin
                 if (counter == 3'd0) begin
                     //write_enable <= 1'b0;
                     sda_out <= 1'b1;  // Finaliza el envío de la dirección
                     state <= SLV_OBJ_ACK;
                 end else begin
                     counter <= counter - 1;
                     sda_out <= slave_addr[counter];
                 end
             end
             SLV_OBJ_ACK: begin
                 // Chequear ACK del esclavo. No está en el verilog
                 if (I2C_SDA == 1'b0) begin  // Write
                     if(num_paquetes == 2'd0) begin
                         counter <= 3'd0;
                     end else begin
                         counter <= 3'd7;
                         write_enable <= 1'b1;
                         sda_out <= wt_buffer[8*(num_paquetes-1) + counter];
                     end 
                     state <= WRITE_DATA;
                 end else begin               // Read
                     counter <= 3'd7;
                     write_enable <= 1'b0;
                     state <= READ_DATA;
                 end
                 
             end
             WRITE_DATA: begin
                 busy <= 1'b1;
                 if (counter == 3'd0) begin
                     write_enable <= 1'b0;
                     num_paquetes <= num_paquetes - 1'b1;
                     state <= WRITE_ACK;
                 end else begin
                     counter <= counter - 1;
                     sda_out <= wt_buffer[8*(num_paquetes-1) + counter];
                 end
             end
             READ_DATA: begin
                 rd_buffer[counter] <= I2C_SDA;
                 if (counter == 3'd0) begin
                     state <= READ_ACK;
                 end else begin 
                     counter <= counter - 1;
                 end
             end
             WRITE_ACK: begin
                 if (enable == 1'b1) begin
                     if (num_paquetes > 1'b0) begin
                         counter <= 3'd7;
                         write_enable <= 1'b1;
                         sda_out <= wt_buffer[8*(num_paquetes-1) + counter];
                         state <= WRITE_DATA;
                     end else begin
                         state <= STOP;
                     end
                 end else begin 
                     state <= STOP;
                 end
             end
             READ_ACK: begin
                 busy <= 1'b0;
                 write_enable <= 1'b1;
                 sda_out <= 1'b0;
                 reg_data_ready <= 1'b1;
                 state <= STOP;
             end
             STOP: begin
                 write_enable <= 1'b1;
                 sda_out <= 1'b1;
                 busy <= 1'b0;
                 state <= READY;
             end
         endcase
     end
 end
 
 // Control síncrono de SCL enable
 always @(posedge clk) begin
     if (!rstn)
         clk_enable <= 1'b0;
     else
         clk_enable <= (state != READY) && (state != START) && (state != STOP);
 end
endmodule

module main_vecfcb9 (
 input clk,
 input rstn,
 input [31:0] Bus_addr,
 input [31:0] Bus_data,
 input serdat_cs,
 input [3:0] I2C_State,
 input I2C_Busy,
 input [7:0] data_out,
 output enable_start,
 output rw,
 output [6:0] slv_addr,
 output [23:0] data_write,
 output [1:0] n_paquetes,
 output bus_data_enable,
 output [31:0] bus_data_out
);
 
 parameter W_SLV_ADDR = 4'b0000;   
 parameter W_RW = 4'b0001;   
 parameter W_N_PQTS = 4'b0010;   
 parameter R_STATE = 4'b0011;   
 parameter R_BUSY = 4'b0100;   
 parameter R_DATA_OUT = 4'b0101;   
 parameter S_ENABLE_START = 4'b0110; 
 parameter S_ENABLE_OUT = 4'b0111;   
 parameter W_DATA_WRITE = 4'b1000;   
 
 //Entrada desde bus de datos
 reg [7:0] dataArray [0:7];
 reg [31:0] buffer_data_out;      
 reg [31:0] zero = 32'b0;
 reg [23:0] data_wr = 24'b0;
 
 assign slv_addr[6:0] = dataArray[0][6:0];       //7 bits                            //0x0400 0000 // 0000
 assign rw = dataArray[1][0];                    //1 bit                             //0x0400 0001 // 0001
 assign n_paquetes[1:0] = dataArray[2][1:0];     //4 bits                            //0x0400 0002 // 0010
 assign I2C_State[3:0] = dataArray[3][3:0];                                          //0x0400 0003 // 0011                               
 assign I2C_Busy = dataArray[4][0];                                                  //0x0400 0004 // 0100
 assign data_out[7:0] = dataArray[5][7:0];                                           //0x0400 0005 // 0101
 assign enable_start = dataArray[6][0];         //1 bit                             //0x0400 0006 // 0110                           
 assign bus_data_enable = dataArray[7][0];         // Datos para la salida del bus      //0x0400 0007 // 0111
 
 assign data_write[23:0] = data_wr;              //24 bits                           //0x0400 0003 // 1000
 assign bus_data_out = buffer_data_out;          // Datos para la salida del bus
 
 always @(posedge clk) begin
     dataArray[6] <= 8'b0;
     dataArray[7] <= 8'b0;
     
     if (!rstn) begin
         // No existen los for exactamente
         // Esto creará estructuras de reinicio tantas veces como se diga
         // No va a iterar x veces
         dataArray[0] <= 8'b0;
         dataArray[1] <= 8'b0;
         dataArray[2] <= 8'b0;
         dataArray[3] <= 8'b0;
         dataArray[4] <= 8'b0;
         dataArray[5] <= 8'b0;
         dataArray[6] <= 8'b0;
         dataArray[7] <= 8'b0;
         // Se reinician los registros
         buffer_data_out <= 32'b0;
         data_wr <= 24'b0;
         zero <= 32'b0;
         
     end else if (serdat_cs) begin
         // Caso en el que se introduce información
         if(Bus_data[3:0] == W_SLV_ADDR || Bus_data[3:0] == W_RW|| Bus_data[3:0] == W_N_PQTS)begin
             dataArray[Bus_addr[2:0]] <= Bus_data[7:0];
 
             if(Bus_addr[7:0] == 8'd0) begin
                 dataArray[6][0] <= 1'b1;
             end
             // Caso en el que se lee información
         end else if(Bus_data[2:0] == R_STATE || Bus_data[2:0] == R_BUSY || Bus_data[2:0] == R_DATA_OUT)begin
             dataArray[7][0] <= 1'b1;
             buffer_data_out <= {zero[31:8], dataArray[Bus_addr[2:0]]};
             
         end else if(Bus_data[2:0] == W_DATA_WRITE)begin
             buffer_data_out <= {zero[31:24], Bus_data[23:0]};
         end else begin
             dataArray[7][0] <= 1'b0;
         end
     end else begin
         // Si no se está escribiendo en el bus, se pone a 0
         dataArray[7][0] <= 1'b0;
     end
 end
 
endmodule
