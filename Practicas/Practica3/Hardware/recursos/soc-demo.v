// Code generated by Icestudio 0.12
// Sat, 29 Mar 2025 14:10:25 GMT

`default_nettype none

//---- Top entity
module main #(
 parameter v31c48c = 'h0210_0000
) (
 input v537510,
 input v6f1ced,
 input [31:0] v775e34,
 input v87d16b,
 input [31:0] v976ab6,
 output vc51198,
 output [31:0] v235119,
 output vc84d54,
 output [0:7] vinit,
 inout va7280c,
 inout vd14cf6
);
 localparam p0 = v31c48c;
 wire w1;
 wire [0:7] w2;
 wire w3;
 wire [0:6] w4;
 wire [0:7] w5;
 wire [0:7] w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire [0:31] w12;
 wire [0:31] w13;
 wire w14;
 assign vc51198 = w7;
 assign w8 = v537510;
 assign w9 = v6f1ced;
 assign w11 = vd14cf6;
 assign w12 = v976ab6;
 assign w13 = v775e34;
 assign w14 = v87d16b;
 vf9bdaf #(
  .v6b316b(p0)
 ) v9b369f (
  .v18e78c(w1),
  .ve1f562(w13)
 );
 vb2090f v2b8390 (
  .v0e28cb(w1),
  .vcbab45(w10),
  .v3ca442(w14)
 );
 main_v020df3 v020df3 (
  .adc_data_write(w2),
  .adc_rw(w3),
  .adc_addr(w4),
  .adc_reg(w6),
  .Bus_data(w12)
 );
 main_vffb17e vffb17e (
  .data_rd(w5)
 );
 main_v7f5352 v7f5352 (
  .data_rw(w2),
  .rw(w3),
  .addr(w4),
  .data_rd(w5),
  .reg_obj(w6),
  .ADC_SCL(w7),
  .clk(w8),
  .resetn(w9),
  .ena(w10),
  .ADC_SDA(w11)
 );
 assign vinit = 8'b00000000;
endmodule

//---- Top entity
module vf9bdaf #(
 parameter v6b316b = 0
) (
 input [31:0] ve1f562,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = ve1f562;
 vf9bdaf_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 32 bits. Se compara si el operando es igual al par치metro
//---------------------------------------------------

module vf9bdaf_vd75681 #(
 parameter K = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a == K);
endmodule
//---- Top entity
module vb2090f (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vb2090f_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND
//---------------------------------------------------

module vb2090f_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta AND
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a & b;
 
 //-- endmodule
endmodule

module main_v020df3 (
 input [31:0] Bus_data,
 output [6:0] adc_addr,
 output adc_rw,
 output [15:8] adc_reg,
 output [23:16] adc_data_write
);
 // Asignaci칩n
 assign adc_addr = Bus_data[6:0];
 assign adc_rw   = Bus_data[7];
 assign adc_reg  = Bus_data[15:8];
 assign adc_data_write = Bus_data[23:16];
 
endmodule

module main_vffb17e (
 input [7:0] data_rd,
 output [31:0] adcData,
 output adcReady
);

endmodule

module main_v7f5352 (
 input clk,
 input resetn,
 input ena,
 input [6:0] addr,
 input rw,
 input [7:0] reg_obj,
 input [7:0] data_rw,
 output busy,
 output [7:0] data_rd,
 output ADC_SCL,
 inout ADC_SDA
);
 // ADC I2C Master para Alhambra II compatible con IceStudio
 
 
 // Par치metros
 parameter INPUT_CLK = 12_000_000;
 parameter BUS_CLK   = 100_000;
 
 // Clock divider
 localparam DIVIDER = (INPUT_CLK / BUS_CLK) / 4;
 localparam NDIV = 8; // log2(375) ~= 8.5, usar 8 por seguridad
 
 // Se침ales internas
 reg [NDIV-1:0] clk_div = 0;
 reg clk_bit = 0;
 always @(posedge clk) begin
     clk_div <= (clk_div == DIVIDER - 1) ? 0 : clk_div + 1;
     if (clk_div == 0) clk_bit <= ~clk_bit;
 end
 
 // Estados
 localparam READY   = 4'd0;
 localparam START   = 4'd1;
 localparam COMMAND = 4'd2;
 localparam ACK1    = 4'd3;
 localparam WR      = 4'd4;
 localparam RD      = 4'd5;
 localparam ACK2    = 4'd6;
 localparam MACK    = 4'd7;
 localparam STOP    = 4'd8;
 
 reg [3:0] state = READY;
 reg scl_en = 0;
 reg sda_int = 1;
 reg [7:0] addr_rw, data_tx, data_rx;
 reg [2:0] bit_cnt = 3'd7;
 reg ack_error = 0;
 
 assign data_rd = data_rx;
 assign busy = (state != READY);
 
 // SDA como salida Open Drain
 assign ADC_SDA = (sda_int == 0) ? 1'b0 : 1'bz;
 assign ADC_SCL = (scl_en == 1) ? clk_bit : 1'bz;
 
 always @(posedge clk_bit or negedge resetn) begin
     if (!resetn) begin
         state <= READY;
         sda_int <= 1;
         scl_en <= 0;
         bit_cnt <= 7;
     end else begin
         case (state)
             READY: begin
                 if (ena) begin
                     addr_rw <= {addr, rw};
                     data_tx <= data_rw;
                     scl_en <= 1;
                     sda_int <= 0;
                     state <= START;
                 end
             end
             START: begin
                 sda_int <= addr_rw[bit_cnt];
                 state <= COMMAND;
             end
             COMMAND: begin
                 if (bit_cnt == 0) begin
                     sda_int <= 1;
                     bit_cnt <= 7;
                     state <= ACK1;
                 end else begin
                     bit_cnt <= bit_cnt - 1;
                     sda_int <= addr_rw[bit_cnt - 1];
                 end
             end
             ACK1: begin
                 if (rw == 0) begin
                     sda_int <= data_tx[bit_cnt];
                     state <= WR;
                 end else begin
                     sda_int <= 1;
                     state <= RD;
                 end
             end
             WR: begin
                 if (bit_cnt == 0) begin
                     sda_int <= 1;
                     bit_cnt <= 7;
                     state <= ACK2;
                 end else begin
                     bit_cnt <= bit_cnt - 1;
                     sda_int <= data_tx[bit_cnt - 1];
                 end
             end
             RD: begin
                 if (bit_cnt == 0) begin
                     bit_cnt <= 7;
                     sda_int <= 1;
                     state <= MACK;
                 end else begin
                     bit_cnt <= bit_cnt - 1;
                     data_rx[bit_cnt] <= ADC_SDA;
                 end
             end
             ACK2: begin
                 scl_en <= 0;
                 sda_int <= 1;
                 state <= STOP;
             end
             MACK: begin
                 scl_en <= 0;
                 state <= STOP;
             end
             STOP: begin
                 sda_int <= 1;
                 state <= READY;
             end
             default: state <= READY;
         endcase
     end
 end
endmodule
