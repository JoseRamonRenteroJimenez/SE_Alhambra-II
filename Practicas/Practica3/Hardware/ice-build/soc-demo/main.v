// Code generated by Icestudio 0.12

`default_nettype none

//---- Top entity
module main #(
 parameter vafbbea = 1024,
 parameter v8c97ba = 'h0200_0000,
 parameter v9217e8 = 1024,
 parameter v9de176 = 'h0200_0008,
 parameter v051dbb = 'h03000000
) (
 input v4922c7,
 input v013906,
 input vclk,
 output [7:0] v1e554b,
 output vc267e1,
 output v7abb98,
 output vda2c07,
 output v55f1ca,
 output v97f0aa,
 output v5ec250,
 output v5100fa
);
 localparam p6 = vafbbea;
 localparam p7 = v8c97ba;
 localparam p8 = v9217e8;
 localparam p10 = v051dbb;
 localparam p11 = v9de176;
 wire [0:31] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire [0:7] w9;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire [0:7] w18;
 wire [0:3] w19;
 wire [0:3] w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 wire w33;
 wire w34;
 wire w35;
 wire w36;
 wire w37;
 wire [0:31] w38;
 wire [0:31] w39;
 wire [0:31] w40;
 wire [0:31] w41;
 wire [0:31] w42;
 wire w43;
 wire w44;
 wire [0:3] w45;
 wire [0:3] w46;
 wire [0:3] w47;
 wire [0:3] w48;
 wire w49;
 wire [0:31] w50;
 wire [0:31] w51;
 wire [0:31] w52;
 wire [0:31] w53;
 wire w54;
 wire w55;
 wire [0:31] w56;
 wire [0:31] w57;
 wire [0:31] w58;
 wire [0:31] w59;
 wire [0:31] w60;
 wire w61;
 wire w62;
 wire w63;
 wire w64;
 wire w65;
 wire w66;
 assign w2 = v013906;
 assign v5100fa = w3;
 assign v5ec250 = w4;
 assign v97f0aa = w5;
 assign v1e554b = w9;
 assign w12 = v4922c7;
 assign v55f1ca = w13;
 assign vda2c07 = w14;
 assign v7abb98 = w15;
 assign vc267e1 = w16;
 assign w21 = vclk;
 assign w22 = vclk;
 assign w23 = vclk;
 assign w24 = vclk;
 assign w25 = vclk;
 assign w26 = vclk;
 assign w27 = vclk;
 assign w28 = vclk;
 assign w18 = w9;
 assign w22 = w21;
 assign w23 = w21;
 assign w23 = w22;
 assign w24 = w21;
 assign w24 = w22;
 assign w24 = w23;
 assign w25 = w21;
 assign w25 = w22;
 assign w25 = w23;
 assign w25 = w24;
 assign w26 = w21;
 assign w26 = w22;
 assign w26 = w23;
 assign w26 = w24;
 assign w26 = w25;
 assign w27 = w21;
 assign w27 = w22;
 assign w27 = w23;
 assign w27 = w24;
 assign w27 = w25;
 assign w27 = w26;
 assign w28 = w21;
 assign w28 = w22;
 assign w28 = w23;
 assign w28 = w24;
 assign w28 = w25;
 assign w28 = w26;
 assign w28 = w27;
 assign w30 = w29;
 assign w31 = w29;
 assign w31 = w30;
 assign w32 = w29;
 assign w32 = w30;
 assign w32 = w31;
 assign w34 = w33;
 assign w35 = w33;
 assign w35 = w34;
 assign w36 = w33;
 assign w36 = w34;
 assign w36 = w35;
 assign w37 = w33;
 assign w37 = w34;
 assign w37 = w35;
 assign w37 = w36;
 assign w39 = w38;
 assign w40 = w38;
 assign w40 = w39;
 assign w41 = w38;
 assign w41 = w39;
 assign w41 = w40;
 assign w42 = w38;
 assign w42 = w39;
 assign w42 = w40;
 assign w42 = w41;
 assign w44 = w43;
 assign w46 = w45;
 assign w47 = w45;
 assign w47 = w46;
 assign w48 = w45;
 assign w48 = w46;
 assign w48 = w47;
 assign w51 = w50;
 assign w52 = w50;
 assign w52 = w51;
 assign w53 = w50;
 assign w53 = w51;
 assign w53 = w52;
 assign w55 = w54;
 assign w62 = w61;
 assign w65 = w64;
 v35f267 vc8f159 (
  .v0e28cb(w1),
  .vcbab45(w29)
 );
 v725d0b vcd95a5 (
  .v9b328c(w0)
 );
 v87abc9 v7eb25a (
  .vcbab45(w43),
  .v814e6e(w49),
  .v3ca442(w54),
  .v0e28cb(w61),
  .v132c67(w63),
  .vc379b0(w65)
 );
 v604573 #(
  .v4fde05(p11)
 ) v72b9aa (
  .vb6935e(w12),
  .v2ab975(w13),
  .v34e785(w21),
  .v866d25(w30),
  .vad40e9(w36),
  .v9f8bfb(w41),
  .vd996e9(w48),
  .v0fa3a4(w53),
  .v62ea55(w60),
  .vdc4800(w63),
  .vf3ed26(w66)
 );
 vdccd52 vb4539a (
 
 );
 v73403c vbe815f (
  .v595263(w18),
  .v85accc(w19),
  .vf9119c(w20)
 );
 vaad680 v62d839 (
  .v29fe33(w0),
  .vba7c72(w22),
  .v5d0f7b(w29),
  .v006d37(w33),
  .vd67338(w38),
  .v9b0ff0(w43),
  .v83dbbe(w45),
  .ve61aa7(w50),
  .v8fd87d(w56)
 );
 v55b120 v7b9433 (
  .v47023d(w14),
  .v7aeba1(w15),
  .v92ad22(w16),
  .v1cd63b(w17),
  .v9119d0(w19),
  .v3d0cdd(w20),
  .v379e9e(w23)
 );
 v6c0c4a #(
  .vf2d743(p10)
 ) v6500fa (
  .v9d3deb(w9),
  .v980561(w17),
  .v1002e2(w24),
  .v8fadcd(w33),
  .vd5de6b(w38),
  .va57c44(w46),
  .vb21f3c(w49),
  .v6d05a9(w50)
 );
 v5242e2 v447d62 (
  .ve3469f(w55),
  .v493538(w56),
  .v918400(w57),
  .v917e97(w58),
  .v5664d9(w59),
  .vae8a69(w60),
  .v76f74e(w62),
  .vec88a9(w64),
  .v58d02d(w66)
 );
 vaba674 #(
  .v6478b6(p8)
 ) v2bbe2d (
  .v04ad7a(w25),
  .vd7d395(w34),
  .v387cca(w39),
  .v22c516(w44),
  .vd728f0(w45),
  .v8d6432(w51),
  .v69f1ab(w54),
  .v13ce3e(w57)
 );
 v2b4233 v1314aa (
  .v6d0651(w1),
  .v4c8225(w26)
 );
 v372366 #(
  .vbce3f7(p6),
  .v386fc7(p7)
 ) v0e0ee1 (
  .v78b064(w2),
  .v40049a(w3),
  .v0da91a(w4),
  .v9b4033(w5),
  .v84763f(w27),
  .v17983a(w32),
  .vba8655(w37),
  .vbee9aa(w42),
  .v202123(w59),
  .vbe14dd(w61)
 );
 v9e3734 vcb4c49 (
  .v537510(w28),
  .v6f1ced(w31),
  .v87d16b(w35),
  .v775e34(w40),
  .v516c98(w47),
  .v976ab6(w52),
  .v235119(w58),
  .vc84d54(w64)
 );
endmodule

//---- Top entity
module v35f267 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v35f267_vd54ca1 vd54ca1 (
  .a(w0),
  .c(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta NOT
//---------------------------------------------------

module v35f267_vd54ca1 (
 input a,
 output c
);
 //-- Puerta NOT
 
 //-- module (input wire a, output wire c);
 
 
 assign c = ~a;
 
 
 //-- endmodule
 
endmodule
//---- Top entity
module v725d0b #(
 parameter vc5c8ea = 0
) (
 output [31:0] v9b328c
);
 localparam p0 = vc5c8ea;
 wire [0:31] w1;
 assign v9b328c = w1;
 v70cd06 #(
  .vc5c8ea(p0)
 ) v38acc0 (
  .v751a1b(w1)
 );
endmodule

//---------------------------------------------------
//-- Valor_00_32bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor constante 0, de 32 bits
//---------------------------------------------------
//---- Top entity
module v70cd06 #(
 parameter vc5c8ea = 0
) (
 output [31:0] v751a1b
);
 localparam p0 = vc5c8ea;
 wire [0:31] w1;
 assign v751a1b = w1;
 v70cd06_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- Constante-32bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor genérico constante, de 32 bits. Su valor se introduce como parámetro. Por defecto vale 0
//---------------------------------------------------

module v70cd06_v465065 #(
 parameter VALUE = 0
) (
 output [31:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module v87abc9 (
 input v0e28cb,
 input v3ca442,
 input v132c67,
 input v814e6e,
 input vc379b0,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 assign w3 = v132c67;
 assign w4 = v814e6e;
 assign w5 = vc379b0;
 v87abc9_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .o(w2),
  .c(w3),
  .d(w4),
  .e(w5)
 );
endmodule

//---------------------------------------------------
//-- OR-4
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta OR de 4 entradas
//---------------------------------------------------

module v87abc9_vf4938a (
 input a,
 input b,
 input c,
 input d,
 input e,
 output o
);
 //-- Puerta OR
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign o = a | b | c | d | e;
 
 //-- endmodule
endmodule
//---- Top entity
module v604573 #(
 parameter v4fde05 = 'h0200_0008
) (
 input v34e785,
 input v866d25,
 input vb6935e,
 input [31:0] v9f8bfb,
 input vad40e9,
 input [31:0] v0fa3a4,
 input [3:0] vd996e9,
 output v2ab975,
 output [31:0] v62ea55,
 output vdc4800,
 output vf3ed26
);
 localparam p3 = v4fde05;
 wire w0;
 wire w1;
 wire w2;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire [0:31] w8;
 wire w9;
 wire [0:3] w10;
 wire [0:31] w11;
 wire [0:3] w12;
 wire w13;
 wire w14;
 wire w15;
 wire [0:31] w16;
 wire w17;
 wire [0:31] w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 assign v2ab975 = w1;
 assign v62ea55 = w8;
 assign vdc4800 = w9;
 assign w10 = vd996e9;
 assign w13 = v34e785;
 assign w14 = v866d25;
 assign w15 = vb6935e;
 assign w16 = v9f8bfb;
 assign w17 = vad40e9;
 assign w18 = v0fa3a4;
 assign vf3ed26 = w24;
 assign w20 = w19;
 assign w22 = w21;
 assign w23 = w21;
 assign w23 = w22;
 assign w24 = w21;
 assign w24 = w22;
 assign w24 = w23;
 v35f267 v793e13 (
  .vcbab45(w0),
  .v0e28cb(w2)
 );
 vb2090f v8b2549 (
  .v0e28cb(w0),
  .vcbab45(w9),
  .v3ca442(w23)
 );
 ve4ece1 vb9eeab (
  .va76a47(w1),
  .v3c7d9a(w2),
  .v10961b(w5),
  .vfeadd9(w7),
  .vb7609f(w8),
  .v20a2cd(w11),
  .v8e9021(w12),
  .v0dfcfa(w13),
  .v19f118(w14),
  .v13457e(w15),
  .v3674d3(w18)
 );
 vf9bdaf #(
  .v6b316b(p3)
 ) va6e100 (
  .v18e78c(w4),
  .ve1f562(w16)
 );
 vb2090f vc4db0b (
  .v0e28cb(w4),
  .v3ca442(w17),
  .vcbab45(w21)
 );
 vb2090f v43be95 (
  .vcbab45(w5),
  .v3ca442(w6),
  .v0e28cb(w21)
 );
 v35f267 v2e543c (
  .vcbab45(w6),
  .v0e28cb(w20)
 );
 vb2090f v7253fb (
  .vcbab45(w7),
  .v0e28cb(w19),
  .v3ca442(w22)
 );
 v45c913 v5623aa (
  .v930b03(w10),
  .v593f43(w19)
 );
 v2c97f6 v70047a (
  .v7c9bd8(w11)
 );
 v6a0d89 vf00bfe (
  .v919d0f(w12)
 );
endmodule

//---------------------------------------------------
//-- UART-soc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- UART con la lógica de mapeo
//---------------------------------------------------
//---- Top entity
module vb2090f (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vb2090f_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND
//---------------------------------------------------

module vb2090f_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta AND
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a & b;
 
 //-- endmodule
endmodule
//---- Top entity
module ve4ece1 (
 input v0dfcfa,
 input v19f118,
 input v13457e,
 input [3:0] v8e9021,
 input vfeadd9,
 input v10961b,
 input [31:0] v3674d3,
 input [31:0] v20a2cd,
 output va76a47,
 output [31:0] vc35967,
 output [31:0] vb7609f,
 output v3c7d9a
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:3] w4;
 wire w5;
 wire w6;
 wire [0:31] w7;
 wire [0:31] w8;
 wire [0:31] w9;
 wire [0:31] w10;
 wire w11;
 assign va76a47 = w0;
 assign w1 = v13457e;
 assign w2 = v0dfcfa;
 assign w3 = v19f118;
 assign w4 = v8e9021;
 assign w5 = vfeadd9;
 assign w6 = v10961b;
 assign w7 = v3674d3;
 assign w8 = v20a2cd;
 assign vc35967 = w9;
 assign vb7609f = w10;
 assign v3c7d9a = w11;
 ve4ece1_v7323f5 v7323f5 (
  .ser_tx(w0),
  .ser_rx(w1),
  .clk(w2),
  .resetn(w3),
  .reg_div_we(w4),
  .reg_dat_we(w5),
  .reg_dat_re(w6),
  .reg_dat_di(w7),
  .reg_div_di(w8),
  .reg_div_do(w9),
  .reg_dat_do(w10),
  .reg_dat_wait(w11)
 );
endmodule

//---------------------------------------------------
//-- UART
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Uart para comunicaciones serie con el pico-riscv
//---------------------------------------------------

module ve4ece1_v7323f5 (
 input clk,
 input resetn,
 input ser_rx,
 input [3:0] reg_div_we,
 input reg_dat_we,
 input reg_dat_re,
 input [31:0] reg_dat_di,
 input [31:0] reg_div_di,
 output ser_tx,
 output [31:0] reg_div_do,
 output [31:0] reg_dat_do,
 output reg_dat_wait
);
 reg [31:0] cfg_divider=104;
 
 	reg [3:0] recv_state;
 	reg [31:0] recv_divcnt;
 	reg [7:0] recv_pattern;
 	reg [7:0] recv_buf_data;
 	reg recv_buf_valid;
 
 	reg [9:0] send_pattern;
 	reg [3:0] send_bitcnt;
 	reg [31:0] send_divcnt;
 	reg send_dummy;
 
 	assign reg_div_do = cfg_divider;
 
 	assign reg_dat_wait = reg_dat_we && (send_bitcnt || send_dummy);
 	assign reg_dat_do = recv_buf_valid ? recv_buf_data : ~0;
 /*
 	always @(posedge clk) begin
 		if (!resetn) begin
 			cfg_divider <= 1;
 		end else begin
 			if (reg_div_we[0]) cfg_divider[ 7: 0] <= reg_div_di[ 7: 0];
 			if (reg_div_we[1]) cfg_divider[15: 8] <= reg_div_di[15: 8];
 			if (reg_div_we[2]) cfg_divider[23:16] <= reg_div_di[23:16];
 			if (reg_div_we[3]) cfg_divider[31:24] <= reg_div_di[31:24];
 		end
 	end
 */
 	always @(posedge clk) begin
 		if (!resetn) begin
 			recv_state <= 0;
 			recv_divcnt <= 0;
 			recv_pattern <= 0;
 			recv_buf_data <= 0;
 			recv_buf_valid <= 0;
 		end else begin
 			recv_divcnt <= recv_divcnt + 1;
 			if (reg_dat_re)
 				recv_buf_valid <= 0;
 			case (recv_state)
 				0: begin
 					if (!ser_rx)
 						recv_state <= 1;
 					recv_divcnt <= 0;
 				end
 				1: begin
 					if (2*recv_divcnt > cfg_divider) begin
 						recv_state <= 2;
 						recv_divcnt <= 0;
 					end
 				end
 				10: begin
 					if (recv_divcnt > cfg_divider) begin
 						recv_buf_data <= recv_pattern;
 						recv_buf_valid <= 1;
 						recv_state <= 0;
 					end
 				end
 				default: begin
 					if (recv_divcnt > cfg_divider) begin
 						recv_pattern <= {ser_rx, recv_pattern[7:1]};
 						recv_state <= recv_state + 1;
 						recv_divcnt <= 0;
 					end
 				end
 			endcase
 		end
 	end
 
 	assign ser_tx = send_pattern[0];
 
 	always @(posedge clk) begin
 		if (reg_div_we)
 			send_dummy <= 1;
 		send_divcnt <= send_divcnt + 1;
 		if (!resetn) begin
 			send_pattern <= ~0;
 			send_bitcnt <= 0;
 			send_divcnt <= 0;
 			send_dummy <= 1;
 		end else begin
 			if (send_dummy && !send_bitcnt) begin
 				send_pattern <= ~0;
 				send_bitcnt <= 15;
 				send_divcnt <= 0;
 				send_dummy <= 0;
 			end else
 			if (reg_dat_we && !send_bitcnt) begin
 				send_pattern <= {1'b1, reg_dat_di[7:0], 1'b0};
 				send_bitcnt <= 10;
 				send_divcnt <= 0;
 			end else
 			if (send_divcnt > cfg_divider && send_bitcnt) begin
 				send_pattern <= {1'b1, send_pattern[9:1]};
 				send_bitcnt <= send_bitcnt - 1;
 				send_divcnt <= 0;
 			end
 		end
 	end
endmodule
//---- Top entity
module vf9bdaf #(
 parameter v6b316b = 0
) (
 input [31:0] ve1f562,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = ve1f562;
 vf9bdaf_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 32 bits. Se compara si el operando es igual al parámetro
//---------------------------------------------------

module vf9bdaf_vd75681 #(
 parameter K = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a == K);
endmodule
//---- Top entity
module v45c913 (
 input [3:0] v930b03,
 output v5b73e8,
 output vc90115,
 output v2812a7,
 output v593f43
);
 wire [0:3] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign w0 = v930b03;
 assign v2812a7 = w1;
 assign v593f43 = w2;
 assign vc90115 = w3;
 assign v5b73e8 = w4;
 v45c913_v9a2a06 v9a2a06 (
  .i(w0),
  .o1(w1),
  .o0(w2),
  .o2(w3),
  .o3(w4)
 );
endmodule

//---------------------------------------------------
//-- Separador-bus
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 4-bits en 4 cables
//---------------------------------------------------

module v45c913_v9a2a06 (
 input [3:0] i,
 output o3,
 output o2,
 output o1,
 output o0
);
 assign o3 = i[3];
 assign o2 = i[2];
 assign o1 = i[1];
 assign o0 = i[0];
endmodule
//---- Top entity
module v2c97f6 #(
 parameter vfffc23 = 0
) (
 output [31:0] v7c9bd8
);
 localparam p0 = vfffc23;
 wire [0:31] w1;
 assign v7c9bd8 = w1;
 v959751 #(
  .vc5c8ea(p0)
 ) v9f49e7 (
  .vbc97e4(w1)
 );
endmodule

//---------------------------------------------------
//-- 32bits-Value_0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 32bits constant value: 0
//---------------------------------------------------
//---- Top entity
module v959751 #(
 parameter vc5c8ea = 0
) (
 output [31:0] vbc97e4
);
 localparam p0 = vc5c8ea;
 wire [0:31] w1;
 assign vbc97e4 = w1;
 v959751_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- 32-bits-gen-constant
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Generic: 32-bits generic constant
//---------------------------------------------------

module v959751_v465065 #(
 parameter VALUE = 0
) (
 output [31:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module v6a0d89 #(
 parameter vfffc23 = 0
) (
 output [3:0] v919d0f
);
 localparam p0 = vfffc23;
 wire [0:3] w1;
 assign v919d0f = w1;
 v9b9118 #(
  .vc5c8ea(p0)
 ) v76a485 (
  .v1ef182(w1)
 );
endmodule

//---------------------------------------------------
//-- 4bits-Value_0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 4bits constant value: 0
//---------------------------------------------------
//---- Top entity
module v9b9118 #(
 parameter vc5c8ea = 0
) (
 output [3:0] v1ef182
);
 localparam p0 = vc5c8ea;
 wire [0:3] w1;
 assign v1ef182 = w1;
 v9b9118_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- 4-bits-gen-constant
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Generic: 4-bits generic constant (0-15)
//---------------------------------------------------

module v9b9118_v465065 #(
 parameter VALUE = 0
) (
 output [3:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module vdccd52
;

endmodule

//---------------------------------------------------
//-- Smiley
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Stickers de Smiley
//---------------------------------------------------
//---- Top entity
module v73403c (
 input [7:0] v595263,
 output [3:0] vf9119c,
 output [3:0] v85accc
);
 wire [0:3] w0;
 wire [0:3] w1;
 wire [0:7] w2;
 assign vf9119c = w0;
 assign v85accc = w1;
 assign w2 = v595263;
 v73403c_v9a2a06 v9a2a06 (
  .o1(w0),
  .o0(w1),
  .i(w2)
 );
endmodule

//---------------------------------------------------
//-- Separador-bus
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 8-bits en buses de 4 bits
//---------------------------------------------------

module v73403c_v9a2a06 (
 input [7:0] i,
 output [3:0] o1,
 output [3:0] o0
);
 assign o1 = i[7:4];
 assign o0 = i[3:0];
endmodule
//---- Top entity
module vaad680 (
 input vba7c72,
 input v5d0f7b,
 input v9b0ff0,
 input [31:0] v8fd87d,
 input [31:0] v29fe33,
 output v006d37,
 output v88e319,
 output [31:0] vd67338,
 output [31:0] ve61aa7,
 output [3:0] v83dbbe
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire [0:31] w6;
 wire [0:31] w7;
 wire [0:31] w8;
 wire [0:31] w9;
 wire [0:3] w10;
 wire [0:31] w11;
 wire w12;
 wire [0:31] w13;
 wire [0:5] w14;
 wire [0:5] w15;
 wire [0:5] w16;
 wire [0:31] w17;
 assign w0 = vba7c72;
 assign w1 = vba7c72;
 assign v006d37 = w2;
 assign w3 = v5d0f7b;
 assign v88e319 = w4;
 assign w5 = v9b0ff0;
 assign vd67338 = w6;
 assign w7 = v8fd87d;
 assign ve61aa7 = w8;
 assign w9 = v29fe33;
 assign v83dbbe = w10;
 assign w1 = w0;
 vaad680_v3fb302 v3fb302 (
  .clk(w1),
  .rdata1(w11),
  .wen(w12),
  .rdata2(w13),
  .waddr(w14),
  .raddr1(w15),
  .raddr2(w16),
  .wdata(w17)
 );
 vaad680_vf1da6e vf1da6e (
  .clk(w0),
  .mem_valid(w2),
  .resetn(w3),
  .mem_instr(w4),
  .mem_ready(w5),
  .mem_addr(w6),
  .mem_rdata(w7),
  .mem_wdata(w8),
  .irq(w9),
  .mem_wstrb(w10),
  .cpuregs_rdata1(w11),
  .cpuregs_wen(w12),
  .cpuregs_rdata2(w13),
  .cpuregs_waddr(w14),
  .cpuregs_raddr1(w15),
  .cpuregs_raddr2(w16),
  .cpuregs_wrdata(w17)
 );
endmodule

//---------------------------------------------------
//-- RV32i
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Risc-v de 32Bits. Numeros enteros
//---------------------------------------------------

module vaad680_v3fb302 (
 input clk,
 input wen,
 input [5:0] waddr,
 input [5:0] raddr1,
 input [5:0] raddr2,
 input [31:0] wdata,
 output [31:0] rdata1,
 output [31:0] rdata2
);
 reg [31:0] regs [0:31];
 
 always @(posedge clk)
 	if (wen) regs[waddr[4:0]] <= wdata;
 
 assign rdata1 = regs[raddr1[4:0]];
 assign rdata2 = regs[raddr2[4:0]];
endmodule

module vaad680_vf1da6e (
 input clk,
 input resetn,
 input mem_ready,
 input [31:0] mem_rdata,
 input [31:0] irq,
 input [31:0] cpuregs_rdata1,
 input [31:0] cpuregs_rdata2,
 input pcpi_mul_wr,
 input [31:0] pcpi_mul_rd,
 input pcpi_mul_wait,
 input pcpi_mul_ready,
 input pcpi_div_wr,
 input [31:0] pcpi_div_rd,
 input pcpi_div_wait,
 input pcpi_div_ready,
 output mem_valid,
 output mem_instr,
 output [31:0] mem_addr,
 output [31:0] mem_wdata,
 output [3:0] mem_wstrb,
 output cpuregs_wen,
 output [5:0] cpuregs_waddr,
 output [5:0] cpuregs_raddr1,
 output [5:0] cpuregs_raddr2,
 output [31:0] cpuregs_wrdata,
 output pcpi_valid,
 output [31:0] pcpi_insn,
 output [31:0] pcpi_rs1,
 output [31:0] pcpi_rs2
);
 `define PICORV32_REGS picosoc_regs
 
 
 parameter integer MEM_WORDS = 256;
 
 `define PICORV32_V
 
 parameter [ 0:0] ENABLE_COUNTERS = 1;
 parameter [ 0:0] ENABLE_COUNTERS64 = 1;
 parameter [ 0:0] ENABLE_REGS_16_31 = 1;
 parameter [ 0:0] ENABLE_REGS_DUALPORT = 1;
 parameter [ 0:0] LATCHED_MEM_RDATA = 0;
 parameter [ 0:0] TWO_STAGE_SHIFT = 1;
 parameter [ 0:0] BARREL_SHIFTER = 1;
 parameter [ 0:0] TWO_CYCLE_COMPARE = 0;
 parameter [ 0:0] TWO_CYCLE_ALU = 0;
 parameter [ 0:0] COMPRESSED_ISA = 0;
 parameter [ 0:0] CATCH_MISALIGN = 1;
 parameter [ 0:0] CATCH_ILLINSN = 1;
 parameter [ 0:0] ENABLE_PCPI = 0;
 parameter [ 0:0] ENABLE_MUL = 0;
 parameter [ 0:0] ENABLE_FAST_MUL = 0;
 parameter [ 0:0] ENABLE_DIV = 0;
 parameter [ 0:0] ENABLE_IRQ = 1;
 parameter [ 0:0] ENABLE_IRQ_QREGS = 0;
 parameter [ 0:0] ENABLE_IRQ_TIMER = 1;
 parameter [ 0:0] ENABLE_TRACE = 0;
 parameter [ 0:0] REGS_INIT_ZERO = 0;
 parameter [31:0] MASKED_IRQ = 32'h 0000_0000;
 parameter [31:0] LATCHED_IRQ = 32'h ffff_ffff;
 parameter [31:0] PROGADDR_RESET = 32'h 0010_0000; // 1 MB into flash,
 parameter [31:0] PROGADDR_IRQ = 32'h 0000_0000;
 parameter [31:0] STACKADDR = (4*MEM_WORDS);       // end of memory
 
 
 reg mem_valid_i;
 assign mem_valid = mem_valid_i;
 reg mem_instr_i;
 assign mem_instr = mem_instr_i;
 reg [31:0] mem_addr_i;
 assign mem_addr = mem_addr_i;
 reg [31:0] mem_wdata_i;
 assign mem_wdata = mem_wdata_i;
 reg [ 3:0] mem_wstrb_i;
 assign mem_wstrb = mem_wstrb_i;
 reg [31:0] eoi;
 
 reg trap;
 
 
 // Pico Co-Processor Interface (PCPI)
 reg        pcpi_valid_i;
 assign pcpi_valid = pcpi_valid_i;
 reg [31:0] pcpi_insn_i;
 assign pcpi_insn = pcpi_insn_i;
 wire     pcpi_wr;
 wire [31:0] pcpi_rd;
 wire pcpi_wait;
 wire pcpi_ready;
 
 
 // Look-Ahead Interface
 wire            mem_la_read;
 wire            mem_la_write;
 wire     [31:0] mem_la_addr;
 reg [31:0] mem_la_wdata;
 reg [ 3:0] mem_la_wstrb;
 
 // Trace Interface
 reg        trace_valid;
 reg [35:0] trace_data;
 
 	localparam integer irq_timer = 0;
 	localparam integer irq_ebreak = 1;
 	localparam integer irq_buserror = 2;
 
 	localparam integer irqregs_offset = ENABLE_REGS_16_31 ? 32 : 16;
 	localparam integer regfile_size = (ENABLE_REGS_16_31 ? 32 : 16) + 4*ENABLE_IRQ*ENABLE_IRQ_QREGS;
 	localparam integer regindex_bits = (ENABLE_REGS_16_31 ? 5 : 4) + ENABLE_IRQ*ENABLE_IRQ_QREGS;
 
 	localparam WITH_PCPI = ENABLE_PCPI || ENABLE_MUL || ENABLE_FAST_MUL || ENABLE_DIV;
 
 	localparam [35:0] TRACE_BRANCH = {4'b 0001, 32'b 0};
 	localparam [35:0] TRACE_ADDR   = {4'b 0010, 32'b 0};
 	localparam [35:0] TRACE_IRQ    = {4'b 1000, 32'b 0};
 
 //-- Añadido para instanciar los registros
 assign cpuregs_wen = resetn && cpuregs_write && latched_rd;
 
 //FORMAL_KEEP:
 reg [63:0] dbg_ascii_instr;
 reg [31:0] dbg_insn_imm;
 reg [4:0] dbg_insn_rs1;
 reg [4:0] dbg_insn_rs2;
 reg [4:0] dbg_insn_rd;
 reg [31:0] dbg_rs1val;
 reg [31:0] dbg_rs2val;
 reg dbg_rs1val_valid;
 reg dbg_rs2val_valid;
 reg [127:0] dbg_ascii_state;
 
 	reg [63:0] count_cycle, count_instr;
 	reg [31:0] reg_pc, reg_next_pc, reg_op1, reg_op2, reg_out;
 	reg [4:0] reg_sh;
 
 	reg [31:0] next_insn_opcode;
 	reg [31:0] dbg_insn_opcode;
 	reg [31:0] dbg_insn_addr;
 
 	wire dbg_mem_valid = mem_valid_i;
 	wire dbg_mem_instr = mem_instr_i;
 	wire dbg_mem_ready = mem_ready;
 	wire [31:0] dbg_mem_addr  = mem_addr_i;
 	wire [31:0] dbg_mem_wdata = mem_wdata_i;
 	wire [ 3:0] dbg_mem_wstrb = mem_wstrb_i;
 	wire [31:0] dbg_mem_rdata = mem_rdata;
 
 	assign pcpi_rs1 = reg_op1;
 	assign pcpi_rs2 = reg_op2;
 
 	wire [31:0] next_pc;
 
 	reg irq_delay;
 	reg irq_active;
 	reg [31:0] irq_mask;
 	reg [31:0] irq_pending;
 	reg [31:0] timer;
 
 `ifndef PICORV32_REGS
 	reg [31:0] cpuregs [0:regfile_size-1];
 
 	integer i;
 	initial begin
 		if (REGS_INIT_ZERO) begin
 			for (i = 0; i < regfile_size; i = i+1)
 				cpuregs[i] = 0;
 		end
 	end
 `endif
 
 	task empty_statement;
 		// This task is used by the `assert directive in non-formal mode to
 		// avoid empty statement (which are unsupported by plain Verilog syntax).
 		begin end
 	endtask
 
 `ifdef DEBUGREGS
 	wire [31:0] dbg_reg_x0  = 0;
 	wire [31:0] dbg_reg_x1  = cpuregs[1];
 	wire [31:0] dbg_reg_x2  = cpuregs[2];
 	wire [31:0] dbg_reg_x3  = cpuregs[3];
 	wire [31:0] dbg_reg_x4  = cpuregs[4];
 	wire [31:0] dbg_reg_x5  = cpuregs[5];
 	wire [31:0] dbg_reg_x6  = cpuregs[6];
 	wire [31:0] dbg_reg_x7  = cpuregs[7];
 	wire [31:0] dbg_reg_x8  = cpuregs[8];
 	wire [31:0] dbg_reg_x9  = cpuregs[9];
 	wire [31:0] dbg_reg_x10 = cpuregs[10];
 	wire [31:0] dbg_reg_x11 = cpuregs[11];
 	wire [31:0] dbg_reg_x12 = cpuregs[12];
 	wire [31:0] dbg_reg_x13 = cpuregs[13];
 	wire [31:0] dbg_reg_x14 = cpuregs[14];
 	wire [31:0] dbg_reg_x15 = cpuregs[15];
 	wire [31:0] dbg_reg_x16 = cpuregs[16];
 	wire [31:0] dbg_reg_x17 = cpuregs[17];
 	wire [31:0] dbg_reg_x18 = cpuregs[18];
 	wire [31:0] dbg_reg_x19 = cpuregs[19];
 	wire [31:0] dbg_reg_x20 = cpuregs[20];
 	wire [31:0] dbg_reg_x21 = cpuregs[21];
 	wire [31:0] dbg_reg_x22 = cpuregs[22];
 	wire [31:0] dbg_reg_x23 = cpuregs[23];
 	wire [31:0] dbg_reg_x24 = cpuregs[24];
 	wire [31:0] dbg_reg_x25 = cpuregs[25];
 	wire [31:0] dbg_reg_x26 = cpuregs[26];
 	wire [31:0] dbg_reg_x27 = cpuregs[27];
 	wire [31:0] dbg_reg_x28 = cpuregs[28];
 	wire [31:0] dbg_reg_x29 = cpuregs[29];
 	wire [31:0] dbg_reg_x30 = cpuregs[30];
 	wire [31:0] dbg_reg_x31 = cpuregs[31];
 `endif
 
 	// Internal PCPI Cores
 
 	reg        pcpi_int_wr;
 	reg [31:0] pcpi_int_rd;
 	reg        pcpi_int_wait;
 	reg        pcpi_int_ready;
 
 	generate if (ENABLE_FAST_MUL) begin
 		picorv32_pcpi_fast_mul pcpi_mul (
 			.clk       (clk            ),
 			.resetn    (resetn         ),
 			.pcpi_valid(pcpi_valid_i     ),
 			.pcpi_insn (pcpi_insn_i      ),
 			.pcpi_rs1  (pcpi_rs1       ),
 			.pcpi_rs2  (pcpi_rs2       ),
 			.pcpi_wr   (pcpi_mul_wr    ),
 			.pcpi_rd   (pcpi_mul_rd    ),
 			.pcpi_wait (pcpi_mul_wait  ),
 			.pcpi_ready(pcpi_mul_ready )
 		);
 	end else if (ENABLE_MUL) begin
 		
 	end else begin
 		assign pcpi_mul_wr = 0;
 		assign pcpi_mul_rd = 32'bx;
 		assign pcpi_mul_wait = 0;
 		assign pcpi_mul_ready = 0;
 	end endgenerate
 
 	generate if (ENABLE_DIV) begin
 		
 	end else begin
 		assign pcpi_div_wr = 0;
 		assign pcpi_div_rd = 32'bx;
 		assign pcpi_div_wait = 0;
 		assign pcpi_div_ready = 0;
 	end endgenerate
 
 	always @* begin
 		pcpi_int_wr = 0;
 		pcpi_int_rd = 32'bx;
 		pcpi_int_wait  = |{ENABLE_PCPI && pcpi_wait,  (ENABLE_MUL || ENABLE_FAST_MUL) && pcpi_mul_wait,  ENABLE_DIV && pcpi_div_wait};
 		pcpi_int_ready = |{ENABLE_PCPI && pcpi_ready, (ENABLE_MUL || ENABLE_FAST_MUL) && pcpi_mul_ready, ENABLE_DIV && pcpi_div_ready};
 
 		(* parallel_case *)
 		case (1'b1)
 			ENABLE_PCPI && pcpi_ready: begin
 				pcpi_int_wr = ENABLE_PCPI ? pcpi_wr : 0;
 				pcpi_int_rd = ENABLE_PCPI ? pcpi_rd : 0;
 			end
 			(ENABLE_MUL || ENABLE_FAST_MUL) && pcpi_mul_ready: begin
 				pcpi_int_wr = pcpi_mul_wr;
 				pcpi_int_rd = pcpi_mul_rd;
 			end
 			ENABLE_DIV && pcpi_div_ready: begin
 				pcpi_int_wr = pcpi_div_wr;
 				pcpi_int_rd = pcpi_div_rd;
 			end
 		endcase
 	end
 
 
 	// Memory Interface
 
 	reg [1:0] mem_state;
 	reg [1:0] mem_wordsize;
 	reg [31:0] mem_rdata_word;
 	reg [31:0] mem_rdata_q;
 	reg mem_do_prefetch;
 	reg mem_do_rinst;
 	reg mem_do_rdata;
 	reg mem_do_wdata;
 
 	wire mem_xfer;
 	reg mem_la_secondword, mem_la_firstword_reg, last_mem_valid;
 	wire mem_la_firstword = COMPRESSED_ISA && (mem_do_prefetch || mem_do_rinst) && next_pc[1] && !mem_la_secondword;
 	wire mem_la_firstword_xfer = COMPRESSED_ISA && mem_xfer && (!last_mem_valid ? mem_la_firstword : mem_la_firstword_reg);
 
 	reg prefetched_high_word;
 	reg clear_prefetched_high_word;
 	reg [15:0] mem_16bit_buffer;
 
 	wire [31:0] mem_rdata_latched_noshuffle;
 	wire [31:0] mem_rdata_latched;
 
 	wire mem_la_use_prefetched_high_word = COMPRESSED_ISA && mem_la_firstword && prefetched_high_word && !clear_prefetched_high_word;
 	assign mem_xfer = (mem_valid_i && mem_ready) || (mem_la_use_prefetched_high_word && mem_do_rinst);
 
 	wire mem_busy = |{mem_do_prefetch, mem_do_rinst, mem_do_rdata, mem_do_wdata};
 	wire mem_done = resetn && ((mem_xfer && |mem_state && (mem_do_rinst || mem_do_rdata || mem_do_wdata)) || (&mem_state && mem_do_rinst)) &&
 			(!mem_la_firstword || (~&mem_rdata_latched[1:0] && mem_xfer));
 
 	assign mem_la_write = resetn && !mem_state && mem_do_wdata;
 	assign mem_la_read = resetn && ((!mem_la_use_prefetched_high_word && !mem_state && (mem_do_rinst || mem_do_prefetch || mem_do_rdata)) ||
 			(COMPRESSED_ISA && mem_xfer && (!last_mem_valid ? mem_la_firstword : mem_la_firstword_reg) && !mem_la_secondword && &mem_rdata_latched[1:0]));
 	assign mem_la_addr = (mem_do_prefetch || mem_do_rinst) ? {next_pc[31:2] + mem_la_firstword_xfer, 2'b00} : {reg_op1[31:2], 2'b00};
 
 	assign mem_rdata_latched_noshuffle = (mem_xfer || LATCHED_MEM_RDATA) ? mem_rdata : mem_rdata_q;
 
 	assign mem_rdata_latched = COMPRESSED_ISA && mem_la_use_prefetched_high_word ? {16'bx, mem_16bit_buffer} :
 			COMPRESSED_ISA && mem_la_secondword ? {mem_rdata_latched_noshuffle[15:0], mem_16bit_buffer} :
 			COMPRESSED_ISA && mem_la_firstword ? {16'bx, mem_rdata_latched_noshuffle[31:16]} : mem_rdata_latched_noshuffle;
 
 	always @(posedge clk) begin
 		if (!resetn) begin
 			mem_la_firstword_reg <= 0;
 			last_mem_valid <= 0;
 		end else begin
 			if (!last_mem_valid)
 				mem_la_firstword_reg <= mem_la_firstword;
 			last_mem_valid <= mem_valid_i && !mem_ready;
 		end
 	end
 
 	always @* begin
 		(* full_case *)
 		case (mem_wordsize)
 			0: begin
 				mem_la_wdata = reg_op2;
 				mem_la_wstrb = 4'b1111;
 				mem_rdata_word = mem_rdata;
 			end
 			1: begin
 				mem_la_wdata = {2{reg_op2[15:0]}};
 				mem_la_wstrb = reg_op1[1] ? 4'b1100 : 4'b0011;
 				case (reg_op1[1])
 					1'b0: mem_rdata_word = {16'b0, mem_rdata[15: 0]};
 					1'b1: mem_rdata_word = {16'b0, mem_rdata[31:16]};
 				endcase
 			end
 			2: begin
 				mem_la_wdata = {4{reg_op2[7:0]}};
 				mem_la_wstrb = 4'b0001 << reg_op1[1:0];
 				case (reg_op1[1:0])
 					2'b00: mem_rdata_word = {24'b0, mem_rdata[ 7: 0]};
 					2'b01: mem_rdata_word = {24'b0, mem_rdata[15: 8]};
 					2'b10: mem_rdata_word = {24'b0, mem_rdata[23:16]};
 					2'b11: mem_rdata_word = {24'b0, mem_rdata[31:24]};
 				endcase
 			end
 		endcase
 	end
 
 	always @(posedge clk) begin
 		if (mem_xfer) begin
 			mem_rdata_q <= COMPRESSED_ISA ? mem_rdata_latched : mem_rdata;
 			next_insn_opcode <= COMPRESSED_ISA ? mem_rdata_latched : mem_rdata;
 		end
 
 		if (COMPRESSED_ISA && mem_done && (mem_do_prefetch || mem_do_rinst)) begin
 			case (mem_rdata_latched[1:0])
 				2'b00: begin // Quadrant 0
 					case (mem_rdata_latched[15:13])
 						3'b000: begin // C.ADDI4SPN
 							mem_rdata_q[14:12] <= 3'b000;
 							mem_rdata_q[31:20] <= {2'b0, mem_rdata_latched[10:7], mem_rdata_latched[12:11], mem_rdata_latched[5], mem_rdata_latched[6], 2'b00};
 						end
 						3'b010: begin // C.LW
 							mem_rdata_q[31:20] <= {5'b0, mem_rdata_latched[5], mem_rdata_latched[12:10], mem_rdata_latched[6], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 						3'b 110: begin // C.SW
 							{mem_rdata_q[31:25], mem_rdata_q[11:7]} <= {5'b0, mem_rdata_latched[5], mem_rdata_latched[12:10], mem_rdata_latched[6], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 					endcase
 				end
 				2'b01: begin // Quadrant 1
 					case (mem_rdata_latched[15:13])
 						3'b 000: begin // C.ADDI
 							mem_rdata_q[14:12] <= 3'b000;
 							mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 						end
 						3'b 010: begin // C.LI
 							mem_rdata_q[14:12] <= 3'b000;
 							mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 						end
 						3'b 011: begin
 							if (mem_rdata_latched[11:7] == 2) begin // C.ADDI16SP
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[4:3],
 										mem_rdata_latched[5], mem_rdata_latched[2], mem_rdata_latched[6], 4'b 0000});
 							end else begin // C.LUI
 								mem_rdata_q[31:12] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 							end
 						end
 						3'b100: begin
 							if (mem_rdata_latched[11:10] == 2'b00) begin // C.SRLI
 								mem_rdata_q[31:25] <= 7'b0000000;
 								mem_rdata_q[14:12] <= 3'b 101;
 							end
 							if (mem_rdata_latched[11:10] == 2'b01) begin // C.SRAI
 								mem_rdata_q[31:25] <= 7'b0100000;
 								mem_rdata_q[14:12] <= 3'b 101;
 							end
 							if (mem_rdata_latched[11:10] == 2'b10) begin // C.ANDI
 								mem_rdata_q[14:12] <= 3'b111;
 								mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 							end
 							if (mem_rdata_latched[12:10] == 3'b011) begin // C.SUB, C.XOR, C.OR, C.AND
 								if (mem_rdata_latched[6:5] == 2'b00) mem_rdata_q[14:12] <= 3'b000;
 								if (mem_rdata_latched[6:5] == 2'b01) mem_rdata_q[14:12] <= 3'b100;
 								if (mem_rdata_latched[6:5] == 2'b10) mem_rdata_q[14:12] <= 3'b110;
 								if (mem_rdata_latched[6:5] == 2'b11) mem_rdata_q[14:12] <= 3'b111;
 								mem_rdata_q[31:25] <= mem_rdata_latched[6:5] == 2'b00 ? 7'b0100000 : 7'b0000000;
 							end
 						end
 						3'b 110: begin // C.BEQZ
 							mem_rdata_q[14:12] <= 3'b000;
 							{ mem_rdata_q[31], mem_rdata_q[7], mem_rdata_q[30:25], mem_rdata_q[11:8] } <=
 									$signed({mem_rdata_latched[12], mem_rdata_latched[6:5], mem_rdata_latched[2],
 											mem_rdata_latched[11:10], mem_rdata_latched[4:3]});
 						end
 						3'b 111: begin // C.BNEZ
 							mem_rdata_q[14:12] <= 3'b001;
 							{ mem_rdata_q[31], mem_rdata_q[7], mem_rdata_q[30:25], mem_rdata_q[11:8] } <=
 									$signed({mem_rdata_latched[12], mem_rdata_latched[6:5], mem_rdata_latched[2],
 											mem_rdata_latched[11:10], mem_rdata_latched[4:3]});
 						end
 					endcase
 				end
 				2'b10: begin // Quadrant 2
 					case (mem_rdata_latched[15:13])
 						3'b000: begin // C.SLLI
 							mem_rdata_q[31:25] <= 7'b0000000;
 							mem_rdata_q[14:12] <= 3'b 001;
 						end
 						3'b010: begin // C.LWSP
 							mem_rdata_q[31:20] <= {4'b0, mem_rdata_latched[3:2], mem_rdata_latched[12], mem_rdata_latched[6:4], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 						3'b100: begin
 							if (mem_rdata_latched[12] == 0 && mem_rdata_latched[6:2] == 0) begin // C.JR
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:20] <= 12'b0;
 							end
 							if (mem_rdata_latched[12] == 0 && mem_rdata_latched[6:2] != 0) begin // C.MV
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:25] <= 7'b0000000;
 							end
 							if (mem_rdata_latched[12] != 0 && mem_rdata_latched[11:7] != 0 && mem_rdata_latched[6:2] == 0) begin // C.JALR
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:20] <= 12'b0;
 							end
 							if (mem_rdata_latched[12] != 0 && mem_rdata_latched[6:2] != 0) begin // C.ADD
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:25] <= 7'b0000000;
 							end
 						end
 						3'b110: begin // C.SWSP
 							{mem_rdata_q[31:25], mem_rdata_q[11:7]} <= {4'b0, mem_rdata_latched[8:7], mem_rdata_latched[12:9], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 					endcase
 				end
 			endcase
 		end
 	end
 /*
 	always @(posedge clk) begin
 		if (resetn && !trap) begin
 			if (mem_do_prefetch || mem_do_rinst || mem_do_rdata)
 				//`assert(!mem_do_wdata);
 
 			if (mem_do_prefetch || mem_do_rinst)
 				//`assert(!mem_do_rdata);
 
 			if (mem_do_rdata)
 				//`assert(!mem_do_prefetch && !mem_do_rinst);
 
 			if (mem_do_wdata)
 				//`assert(!(mem_do_prefetch || mem_do_rinst || mem_do_rdata));
 
 			if (mem_state == 2 || mem_state == 3)
 				//`assert(mem_valid || mem_do_prefetch);
 		end
 	end*/
 
 	always @(posedge clk) begin
 		if (!resetn || trap) begin
 			if (!resetn)
 				mem_state <= 0;
 			if (!resetn || mem_ready)
 				mem_valid_i <= 0;
 			mem_la_secondword <= 0;
 			prefetched_high_word <= 0;
 		end else begin
 			if (mem_la_read || mem_la_write) begin
 				mem_addr_i <= mem_la_addr;
 				mem_wstrb_i <= mem_la_wstrb & {4{mem_la_write}};
 			end
 			if (mem_la_write) begin
 				mem_wdata_i <= mem_la_wdata;
 			end
 			case (mem_state)
 				0: begin
 					if (mem_do_prefetch || mem_do_rinst || mem_do_rdata) begin
 						mem_valid_i <= !mem_la_use_prefetched_high_word;
 						mem_instr_i <= mem_do_prefetch || mem_do_rinst;
 						mem_wstrb_i <= 0;
 						mem_state <= 1;
 					end
 					if (mem_do_wdata) begin
 						mem_valid_i <= 1;
 						mem_instr_i <= 0;
 						mem_state <= 2;
 					end
 				end
 				1: begin
 					//`assert(mem_wstrb == 0);
 					//`assert(mem_do_prefetch || mem_do_rinst || mem_do_rdata);
 					//`assert(mem_valid == !mem_la_use_prefetched_high_word);
 					//`assert(mem_instr == (mem_do_prefetch || mem_do_rinst));
 					if (mem_xfer) begin
 						if (COMPRESSED_ISA && mem_la_read) begin
 							mem_valid_i <= 1;
 							mem_la_secondword <= 1;
 							if (!mem_la_use_prefetched_high_word)
 								mem_16bit_buffer <= mem_rdata[31:16];
 						end else begin
 							mem_valid_i <= 0;
 							mem_la_secondword <= 0;
 							if (COMPRESSED_ISA && !mem_do_rdata) begin
 								if (~&mem_rdata[1:0] || mem_la_secondword) begin
 									mem_16bit_buffer <= mem_rdata[31:16];
 									prefetched_high_word <= 1;
 								end else begin
 									prefetched_high_word <= 0;
 								end
 							end
 							mem_state <= mem_do_rinst || mem_do_rdata ? 0 : 3;
 						end
 					end
 				end
 				2: begin
 					//`assert(mem_wstrb != 0);
 					//`assert(mem_do_wdata);
 					if (mem_xfer) begin
 						mem_valid_i <= 0;
 						mem_state <= 0;
 					end
 				end
 				3: begin
 					//`assert(mem_wstrb == 0);
 					//`assert(mem_do_prefetch);
 					if (mem_do_rinst) begin
 						mem_state <= 0;
 					end
 				end
 			endcase
 		end
 
 		if (clear_prefetched_high_word)
 			prefetched_high_word <= 0;
 	end
 
 
 	// Instruction Decoder
 
 	reg instr_lui, instr_auipc, instr_jal, instr_jalr;
 	reg instr_beq, instr_bne, instr_blt, instr_bge, instr_bltu, instr_bgeu;
 	reg instr_lb, instr_lh, instr_lw, instr_lbu, instr_lhu, instr_sb, instr_sh, instr_sw;
 	reg instr_addi, instr_slti, instr_sltiu, instr_xori, instr_ori, instr_andi, instr_slli, instr_srli, instr_srai;
 	reg instr_add, instr_sub, instr_sll, instr_slt, instr_sltu, instr_xor, instr_srl, instr_sra, instr_or, instr_and;
 	reg instr_rdcycle, instr_rdcycleh, instr_rdinstr, instr_rdinstrh, instr_ecall_ebreak;
 	reg instr_getq, instr_setq, instr_retirq, instr_maskirq, instr_waitirq, instr_timer;
 	wire instr_trap;
 
 	reg [regindex_bits-1:0] decoded_rd, decoded_rs1, decoded_rs2;
 	reg [31:0] decoded_imm, decoded_imm_uj;
 	reg decoder_trigger;
 	reg decoder_trigger_q;
 	reg decoder_pseudo_trigger;
 	reg decoder_pseudo_trigger_q;
 	reg compressed_instr;
 
 	reg is_lui_auipc_jal;
 	reg is_lb_lh_lw_lbu_lhu;
 	reg is_slli_srli_srai;
 	reg is_jalr_addi_slti_sltiu_xori_ori_andi;
 	reg is_sb_sh_sw;
 	reg is_sll_srl_sra;
 	reg is_lui_auipc_jal_jalr_addi_add_sub;
 	reg is_slti_blt_slt;
 	reg is_sltiu_bltu_sltu;
 	reg is_beq_bne_blt_bge_bltu_bgeu;
 	reg is_lbu_lhu_lw;
 	reg is_alu_reg_imm;
 	reg is_alu_reg_reg;
 	reg is_compare;
 
 	assign instr_trap = (CATCH_ILLINSN || WITH_PCPI) && !{instr_lui, instr_auipc, instr_jal, instr_jalr,
 			instr_beq, instr_bne, instr_blt, instr_bge, instr_bltu, instr_bgeu,
 			instr_lb, instr_lh, instr_lw, instr_lbu, instr_lhu, instr_sb, instr_sh, instr_sw,
 			instr_addi, instr_slti, instr_sltiu, instr_xori, instr_ori, instr_andi, instr_slli, instr_srli, instr_srai,
 			instr_add, instr_sub, instr_sll, instr_slt, instr_sltu, instr_xor, instr_srl, instr_sra, instr_or, instr_and,
 			instr_rdcycle, instr_rdcycleh, instr_rdinstr, instr_rdinstrh,
 			instr_getq, instr_setq, instr_retirq, instr_maskirq, instr_waitirq, instr_timer};
 
 	wire is_rdcycle_rdcycleh_rdinstr_rdinstrh;
 	assign is_rdcycle_rdcycleh_rdinstr_rdinstrh = |{instr_rdcycle, instr_rdcycleh, instr_rdinstr, instr_rdinstrh};
 
 	reg [63:0] new_ascii_instr;
 	/*
 	`FORMAL_KEEP reg [63:0] dbg_ascii_instr;
 	`FORMAL_KEEP reg [31:0] dbg_insn_imm;
 	`FORMAL_KEEP reg [4:0] dbg_insn_rs1;
 	`FORMAL_KEEP reg [4:0] dbg_insn_rs2;
 	`FORMAL_KEEP reg [4:0] dbg_insn_rd;
 	`FORMAL_KEEP reg [31:0] dbg_rs1val;
 	`FORMAL_KEEP reg [31:0] dbg_rs2val;
 	`FORMAL_KEEP reg dbg_rs1val_valid;
 	`FORMAL_KEEP reg dbg_rs2val_valid;*/
 
 	always @* begin
 		new_ascii_instr = "";
 
 		if (instr_lui)      new_ascii_instr = "lui";
 		if (instr_auipc)    new_ascii_instr = "auipc";
 		if (instr_jal)      new_ascii_instr = "jal";
 		if (instr_jalr)     new_ascii_instr = "jalr";
 
 		if (instr_beq)      new_ascii_instr = "beq";
 		if (instr_bne)      new_ascii_instr = "bne";
 		if (instr_blt)      new_ascii_instr = "blt";
 		if (instr_bge)      new_ascii_instr = "bge";
 		if (instr_bltu)     new_ascii_instr = "bltu";
 		if (instr_bgeu)     new_ascii_instr = "bgeu";
 
 		if (instr_lb)       new_ascii_instr = "lb";
 		if (instr_lh)       new_ascii_instr = "lh";
 		if (instr_lw)       new_ascii_instr = "lw";
 		if (instr_lbu)      new_ascii_instr = "lbu";
 		if (instr_lhu)      new_ascii_instr = "lhu";
 		if (instr_sb)       new_ascii_instr = "sb";
 		if (instr_sh)       new_ascii_instr = "sh";
 		if (instr_sw)       new_ascii_instr = "sw";
 
 		if (instr_addi)     new_ascii_instr = "addi";
 		if (instr_slti)     new_ascii_instr = "slti";
 		if (instr_sltiu)    new_ascii_instr = "sltiu";
 		if (instr_xori)     new_ascii_instr = "xori";
 		if (instr_ori)      new_ascii_instr = "ori";
 		if (instr_andi)     new_ascii_instr = "andi";
 		if (instr_slli)     new_ascii_instr = "slli";
 		if (instr_srli)     new_ascii_instr = "srli";
 		if (instr_srai)     new_ascii_instr = "srai";
 
 		if (instr_add)      new_ascii_instr = "add";
 		if (instr_sub)      new_ascii_instr = "sub";
 		if (instr_sll)      new_ascii_instr = "sll";
 		if (instr_slt)      new_ascii_instr = "slt";
 		if (instr_sltu)     new_ascii_instr = "sltu";
 		if (instr_xor)      new_ascii_instr = "xor";
 		if (instr_srl)      new_ascii_instr = "srl";
 		if (instr_sra)      new_ascii_instr = "sra";
 		if (instr_or)       new_ascii_instr = "or";
 		if (instr_and)      new_ascii_instr = "and";
 
 		if (instr_rdcycle)  new_ascii_instr = "rdcycle";
 		if (instr_rdcycleh) new_ascii_instr = "rdcycleh";
 		if (instr_rdinstr)  new_ascii_instr = "rdinstr";
 		if (instr_rdinstrh) new_ascii_instr = "rdinstrh";
 
 		if (instr_getq)     new_ascii_instr = "getq";
 		if (instr_setq)     new_ascii_instr = "setq";
 		if (instr_retirq)   new_ascii_instr = "retirq";
 		if (instr_maskirq)  new_ascii_instr = "maskirq";
 		if (instr_waitirq)  new_ascii_instr = "waitirq";
 		if (instr_timer)    new_ascii_instr = "timer";
 	end
 
 	reg [63:0] q_ascii_instr;
 	reg [31:0] q_insn_imm;
 	reg [31:0] q_insn_opcode;
 	reg [4:0] q_insn_rs1;
 	reg [4:0] q_insn_rs2;
 	reg [4:0] q_insn_rd;
 	reg dbg_next;
 
 	wire launch_next_insn;
 	reg dbg_valid_insn;
 
 	reg [63:0] cached_ascii_instr;
 	reg [31:0] cached_insn_imm;
 	reg [31:0] cached_insn_opcode;
 	reg [4:0] cached_insn_rs1;
 	reg [4:0] cached_insn_rs2;
 	reg [4:0] cached_insn_rd;
 
 	always @(posedge clk) begin
 		q_ascii_instr <= dbg_ascii_instr;
 		q_insn_imm <= dbg_insn_imm;
 		q_insn_opcode <= dbg_insn_opcode;
 		q_insn_rs1 <= dbg_insn_rs1;
 		q_insn_rs2 <= dbg_insn_rs2;
 		q_insn_rd <= dbg_insn_rd;
 		dbg_next <= launch_next_insn;
 
 		if (!resetn || trap)
 			dbg_valid_insn <= 0;
 		else if (launch_next_insn)
 			dbg_valid_insn <= 1;
 
 		if (decoder_trigger_q) begin
 			cached_ascii_instr <= new_ascii_instr;
 			cached_insn_imm <= decoded_imm;
 			if (&next_insn_opcode[1:0])
 				cached_insn_opcode <= next_insn_opcode;
 			else
 				cached_insn_opcode <= {16'b0, next_insn_opcode[15:0]};
 			cached_insn_rs1 <= decoded_rs1;
 			cached_insn_rs2 <= decoded_rs2;
 			cached_insn_rd <= decoded_rd;
 		end
 
 		if (launch_next_insn) begin
 			dbg_insn_addr <= next_pc;
 		end
 	end
 
 	always @* begin
 		dbg_ascii_instr = q_ascii_instr;
 		dbg_insn_imm = q_insn_imm;
 		dbg_insn_opcode = q_insn_opcode;
 		dbg_insn_rs1 = q_insn_rs1;
 		dbg_insn_rs2 = q_insn_rs2;
 		dbg_insn_rd = q_insn_rd;
 
 		if (dbg_next) begin
 			if (decoder_pseudo_trigger_q) begin
 				dbg_ascii_instr = cached_ascii_instr;
 				dbg_insn_imm = cached_insn_imm;
 				dbg_insn_opcode = cached_insn_opcode;
 				dbg_insn_rs1 = cached_insn_rs1;
 				dbg_insn_rs2 = cached_insn_rs2;
 				dbg_insn_rd = cached_insn_rd;
 			end else begin
 				dbg_ascii_instr = new_ascii_instr;
 				if (&next_insn_opcode[1:0])
 					dbg_insn_opcode = next_insn_opcode;
 				else
 					dbg_insn_opcode = {16'b0, next_insn_opcode[15:0]};
 				dbg_insn_imm = decoded_imm;
 				dbg_insn_rs1 = decoded_rs1;
 				dbg_insn_rs2 = decoded_rs2;
 				dbg_insn_rd = decoded_rd;
 			end
 		end
 	end
 
 `ifdef DEBUGASM
 	always @(posedge clk) begin
 		if (dbg_next) begin
 			$display("debugasm %x %x %s", dbg_insn_addr, dbg_insn_opcode, dbg_ascii_instr ? dbg_ascii_instr : "*");
 		end
 	end
 `endif
 
 `ifdef DEBUG
 	always @(posedge clk) begin
 		if (dbg_next) begin
 			if (&dbg_insn_opcode[1:0])
 				$display("DECODE: 0x%08x 0x%08x %-0s", dbg_insn_addr, dbg_insn_opcode, dbg_ascii_instr ? dbg_ascii_instr : "UNKNOWN");
 			else
 				$display("DECODE: 0x%08x     0x%04x %-0s", dbg_insn_addr, dbg_insn_opcode[15:0], dbg_ascii_instr ? dbg_ascii_instr : "UNKNOWN");
 		end
 	end
 `endif
 
 	always @(posedge clk) begin
 		is_lui_auipc_jal <= |{instr_lui, instr_auipc, instr_jal};
 		is_lui_auipc_jal_jalr_addi_add_sub <= |{instr_lui, instr_auipc, instr_jal, instr_jalr, instr_addi, instr_add, instr_sub};
 		is_slti_blt_slt <= |{instr_slti, instr_blt, instr_slt};
 		is_sltiu_bltu_sltu <= |{instr_sltiu, instr_bltu, instr_sltu};
 		is_lbu_lhu_lw <= |{instr_lbu, instr_lhu, instr_lw};
 		is_compare <= |{is_beq_bne_blt_bge_bltu_bgeu, instr_slti, instr_slt, instr_sltiu, instr_sltu};
 
 		if (mem_do_rinst && mem_done) begin
 			instr_lui     <= mem_rdata_latched[6:0] == 7'b0110111;
 			instr_auipc   <= mem_rdata_latched[6:0] == 7'b0010111;
 			instr_jal     <= mem_rdata_latched[6:0] == 7'b1101111;
 			instr_jalr    <= mem_rdata_latched[6:0] == 7'b1100111 && mem_rdata_latched[14:12] == 3'b000;
 			instr_retirq  <= mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000010 && ENABLE_IRQ;
 			instr_waitirq <= mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000100 && ENABLE_IRQ;
 
 			is_beq_bne_blt_bge_bltu_bgeu <= mem_rdata_latched[6:0] == 7'b1100011;
 			is_lb_lh_lw_lbu_lhu          <= mem_rdata_latched[6:0] == 7'b0000011;
 			is_sb_sh_sw                  <= mem_rdata_latched[6:0] == 7'b0100011;
 			is_alu_reg_imm               <= mem_rdata_latched[6:0] == 7'b0010011;
 			is_alu_reg_reg               <= mem_rdata_latched[6:0] == 7'b0110011;
 
 			{ decoded_imm_uj[31:20], decoded_imm_uj[10:1], decoded_imm_uj[11], decoded_imm_uj[19:12], decoded_imm_uj[0] } <= $signed({mem_rdata_latched[31:12], 1'b0});
 
 			decoded_rd <= mem_rdata_latched[11:7];
 			decoded_rs1 <= mem_rdata_latched[19:15];
 			decoded_rs2 <= mem_rdata_latched[24:20];
 
 			if (mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000000 && ENABLE_IRQ && ENABLE_IRQ_QREGS)
 				decoded_rs1[regindex_bits-1] <= 1; // instr_getq
 
 			if (mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000010 && ENABLE_IRQ)
 				decoded_rs1 <= ENABLE_IRQ_QREGS ? irqregs_offset : 3; // instr_retirq
 
 			compressed_instr <= 0;
 			if (COMPRESSED_ISA && mem_rdata_latched[1:0] != 2'b11) begin
 				compressed_instr <= 1;
 				decoded_rd <= 0;
 				decoded_rs1 <= 0;
 				decoded_rs2 <= 0;
 
 				{ decoded_imm_uj[31:11], decoded_imm_uj[4], decoded_imm_uj[9:8], decoded_imm_uj[10], decoded_imm_uj[6],
 				  decoded_imm_uj[7], decoded_imm_uj[3:1], decoded_imm_uj[5], decoded_imm_uj[0] } <= $signed({mem_rdata_latched[12:2], 1'b0});
 
 				case (mem_rdata_latched[1:0])
 					2'b00: begin // Quadrant 0
 						case (mem_rdata_latched[15:13])
 							3'b000: begin // C.ADDI4SPN
 								is_alu_reg_imm <= |mem_rdata_latched[12:5];
 								decoded_rs1 <= 2;
 								decoded_rd <= 8 + mem_rdata_latched[4:2];
 							end
 							3'b010: begin // C.LW
 								is_lb_lh_lw_lbu_lhu <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rd <= 8 + mem_rdata_latched[4:2];
 							end
 							3'b110: begin // C.SW
 								is_sb_sh_sw <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rs2 <= 8 + mem_rdata_latched[4:2];
 							end
 						endcase
 					end
 					2'b01: begin // Quadrant 1
 						case (mem_rdata_latched[15:13])
 							3'b000: begin // C.NOP / C.ADDI
 								is_alu_reg_imm <= 1;
 								decoded_rd <= mem_rdata_latched[11:7];
 								decoded_rs1 <= mem_rdata_latched[11:7];
 							end
 							3'b001: begin // C.JAL
 								instr_jal <= 1;
 								decoded_rd <= 1;
 							end
 							3'b 010: begin // C.LI
 								is_alu_reg_imm <= 1;
 								decoded_rd <= mem_rdata_latched[11:7];
 								decoded_rs1 <= 0;
 							end
 							3'b 011: begin
 								if (mem_rdata_latched[12] || mem_rdata_latched[6:2]) begin
 									if (mem_rdata_latched[11:7] == 2) begin // C.ADDI16SP
 										is_alu_reg_imm <= 1;
 										decoded_rd <= mem_rdata_latched[11:7];
 										decoded_rs1 <= mem_rdata_latched[11:7];
 									end else begin // C.LUI
 										instr_lui <= 1;
 										decoded_rd <= mem_rdata_latched[11:7];
 										decoded_rs1 <= 0;
 									end
 								end
 							end
 							3'b100: begin
 								if (!mem_rdata_latched[11] && !mem_rdata_latched[12]) begin // C.SRLI, C.SRAI
 									is_alu_reg_imm <= 1;
 									decoded_rd <= 8 + mem_rdata_latched[9:7];
 									decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 									decoded_rs2 <= {mem_rdata_latched[12], mem_rdata_latched[6:2]};
 								end
 								if (mem_rdata_latched[11:10] == 2'b10) begin // C.ANDI
 									is_alu_reg_imm <= 1;
 									decoded_rd <= 8 + mem_rdata_latched[9:7];
 									decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								end
 								if (mem_rdata_latched[12:10] == 3'b011) begin // C.SUB, C.XOR, C.OR, C.AND
 									is_alu_reg_reg <= 1;
 									decoded_rd <= 8 + mem_rdata_latched[9:7];
 									decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 									decoded_rs2 <= 8 + mem_rdata_latched[4:2];
 								end
 							end
 							3'b101: begin // C.J
 								instr_jal <= 1;
 							end
 							3'b110: begin // C.BEQZ
 								is_beq_bne_blt_bge_bltu_bgeu <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rs2 <= 0;
 							end
 							3'b111: begin // C.BNEZ
 								is_beq_bne_blt_bge_bltu_bgeu <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rs2 <= 0;
 							end
 						endcase
 					end
 					2'b10: begin // Quadrant 2
 						case (mem_rdata_latched[15:13])
 							3'b000: begin // C.SLLI
 								if (!mem_rdata_latched[12]) begin
 									is_alu_reg_imm <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= mem_rdata_latched[11:7];
 									decoded_rs2 <= {mem_rdata_latched[12], mem_rdata_latched[6:2]};
 								end
 							end
 							3'b010: begin // C.LWSP
 								if (mem_rdata_latched[11:7]) begin
 									is_lb_lh_lw_lbu_lhu <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= 2;
 								end
 							end
 							3'b100: begin
 								if (mem_rdata_latched[12] == 0 && mem_rdata_latched[11:7] != 0 && mem_rdata_latched[6:2] == 0) begin // C.JR
 									instr_jalr <= 1;
 									decoded_rd <= 0;
 									decoded_rs1 <= mem_rdata_latched[11:7];
 								end
 								if (mem_rdata_latched[12] == 0 && mem_rdata_latched[6:2] != 0) begin // C.MV
 									is_alu_reg_reg <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= 0;
 									decoded_rs2 <= mem_rdata_latched[6:2];
 								end
 								if (mem_rdata_latched[12] != 0 && mem_rdata_latched[11:7] != 0 && mem_rdata_latched[6:2] == 0) begin // C.JALR
 									instr_jalr <= 1;
 									decoded_rd <= 1;
 									decoded_rs1 <= mem_rdata_latched[11:7];
 								end
 								if (mem_rdata_latched[12] != 0 && mem_rdata_latched[6:2] != 0) begin // C.ADD
 									is_alu_reg_reg <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= mem_rdata_latched[11:7];
 									decoded_rs2 <= mem_rdata_latched[6:2];
 								end
 							end
 							3'b110: begin // C.SWSP
 								is_sb_sh_sw <= 1;
 								decoded_rs1 <= 2;
 								decoded_rs2 <= mem_rdata_latched[6:2];
 							end
 						endcase
 					end
 				endcase
 			end
 		end
 
 		if (decoder_trigger && !decoder_pseudo_trigger) begin
 			pcpi_insn_i <= WITH_PCPI ? mem_rdata_q : 'bx;
 
 			instr_beq   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b000;
 			instr_bne   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b001;
 			instr_blt   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b100;
 			instr_bge   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b101;
 			instr_bltu  <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b110;
 			instr_bgeu  <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b111;
 
 			instr_lb    <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b000;
 			instr_lh    <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b001;
 			instr_lw    <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b010;
 			instr_lbu   <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b100;
 			instr_lhu   <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b101;
 
 			instr_sb    <= is_sb_sh_sw && mem_rdata_q[14:12] == 3'b000;
 			instr_sh    <= is_sb_sh_sw && mem_rdata_q[14:12] == 3'b001;
 			instr_sw    <= is_sb_sh_sw && mem_rdata_q[14:12] == 3'b010;
 
 			instr_addi  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b000;
 			instr_slti  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b010;
 			instr_sltiu <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b011;
 			instr_xori  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b100;
 			instr_ori   <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b110;
 			instr_andi  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b111;
 
 			instr_slli  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_srli  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_srai  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000;
 
 			instr_add   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b000 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_sub   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b000 && mem_rdata_q[31:25] == 7'b0100000;
 			instr_sll   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_slt   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b010 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_sltu  <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b011 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_xor   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b100 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_srl   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_sra   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000;
 			instr_or    <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b110 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_and   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b111 && mem_rdata_q[31:25] == 7'b0000000;
 
 			instr_rdcycle  <= ((mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11000000000000000010) ||
 			                   (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11000000000100000010)) && ENABLE_COUNTERS;
 			instr_rdcycleh <= ((mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11001000000000000010) ||
 			                   (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11001000000100000010)) && ENABLE_COUNTERS && ENABLE_COUNTERS64;
 			instr_rdinstr  <=  (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11000000001000000010) && ENABLE_COUNTERS;
 			instr_rdinstrh <=  (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11001000001000000010) && ENABLE_COUNTERS && ENABLE_COUNTERS64;
 
 			instr_ecall_ebreak <= ((mem_rdata_q[6:0] == 7'b1110011 && !mem_rdata_q[31:21] && !mem_rdata_q[19:7]) ||
 					(COMPRESSED_ISA && mem_rdata_q[15:0] == 16'h9002));
 
 			instr_getq    <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000000 && ENABLE_IRQ && ENABLE_IRQ_QREGS;
 			instr_setq    <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000001 && ENABLE_IRQ && ENABLE_IRQ_QREGS;
 			instr_maskirq <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000011 && ENABLE_IRQ;
 			instr_timer   <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000101 && ENABLE_IRQ && ENABLE_IRQ_TIMER;
 
 			is_slli_srli_srai <= is_alu_reg_imm && |{
 				mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000
 			};
 
 			is_jalr_addi_slti_sltiu_xori_ori_andi <= instr_jalr || is_alu_reg_imm && |{
 				mem_rdata_q[14:12] == 3'b000,
 				mem_rdata_q[14:12] == 3'b010,
 				mem_rdata_q[14:12] == 3'b011,
 				mem_rdata_q[14:12] == 3'b100,
 				mem_rdata_q[14:12] == 3'b110,
 				mem_rdata_q[14:12] == 3'b111
 			};
 
 			is_sll_srl_sra <= is_alu_reg_reg && |{
 				mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000
 			};
 
 			is_lui_auipc_jal_jalr_addi_add_sub <= 0;
 			is_compare <= 0;
 
 			(* parallel_case *)
 			case (1'b1)
 				instr_jal:
 					decoded_imm <= decoded_imm_uj;
 				|{instr_lui, instr_auipc}:
 					decoded_imm <= mem_rdata_q[31:12] << 12;
 				|{instr_jalr, is_lb_lh_lw_lbu_lhu, is_alu_reg_imm}:
 					decoded_imm <= $signed(mem_rdata_q[31:20]);
 				is_beq_bne_blt_bge_bltu_bgeu:
 					decoded_imm <= $signed({mem_rdata_q[31], mem_rdata_q[7], mem_rdata_q[30:25], mem_rdata_q[11:8], 1'b0});
 				is_sb_sh_sw:
 					decoded_imm <= $signed({mem_rdata_q[31:25], mem_rdata_q[11:7]});
 				default:
 					decoded_imm <= 1'bx;
 			endcase
 		end
 
 		if (!resetn) begin
 			is_beq_bne_blt_bge_bltu_bgeu <= 0;
 			is_compare <= 0;
 
 			instr_beq   <= 0;
 			instr_bne   <= 0;
 			instr_blt   <= 0;
 			instr_bge   <= 0;
 			instr_bltu  <= 0;
 			instr_bgeu  <= 0;
 
 			instr_addi  <= 0;
 			instr_slti  <= 0;
 			instr_sltiu <= 0;
 			instr_xori  <= 0;
 			instr_ori   <= 0;
 			instr_andi  <= 0;
 
 			instr_add   <= 0;
 			instr_sub   <= 0;
 			instr_sll   <= 0;
 			instr_slt   <= 0;
 			instr_sltu  <= 0;
 			instr_xor   <= 0;
 			instr_srl   <= 0;
 			instr_sra   <= 0;
 			instr_or    <= 0;
 			instr_and   <= 0;
 		end
 	end
 
 
 	// Main State Machine
 
 	localparam cpu_state_trap   = 8'b10000000;
 	localparam cpu_state_fetch  = 8'b01000000;
 	localparam cpu_state_ld_rs1 = 8'b00100000;
 	localparam cpu_state_ld_rs2 = 8'b00010000;
 	localparam cpu_state_exec   = 8'b00001000;
 	localparam cpu_state_shift  = 8'b00000100;
 	localparam cpu_state_stmem  = 8'b00000010;
 	localparam cpu_state_ldmem  = 8'b00000001;
 
 	reg [7:0] cpu_state;
 	reg [1:0] irq_state;
 
 	//`FORMAL_KEEP reg [127:0] dbg_ascii_state;
 
 	always @* begin
 		dbg_ascii_state = "";
 		if (cpu_state == cpu_state_trap)   dbg_ascii_state = "trap";
 		if (cpu_state == cpu_state_fetch)  dbg_ascii_state = "fetch";
 		if (cpu_state == cpu_state_ld_rs1) dbg_ascii_state = "ld_rs1";
 		if (cpu_state == cpu_state_ld_rs2) dbg_ascii_state = "ld_rs2";
 		if (cpu_state == cpu_state_exec)   dbg_ascii_state = "exec";
 		if (cpu_state == cpu_state_shift)  dbg_ascii_state = "shift";
 		if (cpu_state == cpu_state_stmem)  dbg_ascii_state = "stmem";
 		if (cpu_state == cpu_state_ldmem)  dbg_ascii_state = "ldmem";
 	end
 
 	reg set_mem_do_rinst;
 	reg set_mem_do_rdata;
 	reg set_mem_do_wdata;
 
 	reg latched_store;
 	reg latched_stalu;
 	reg latched_branch;
 	reg latched_compr;
 	reg latched_trace;
 	reg latched_is_lu;
 	reg latched_is_lh;
 	reg latched_is_lb;
 	reg [regindex_bits-1:0] latched_rd;
 
 	reg [31:0] current_pc;
 	assign next_pc = latched_store && latched_branch ? reg_out & ~1 : reg_next_pc;
 
 	reg [3:0] pcpi_timeout_counter;
 	reg pcpi_timeout;
 
 	reg [31:0] next_irq_pending;
 	reg do_waitirq;
 
 	reg [31:0] alu_out, alu_out_q;
 	reg alu_out_0, alu_out_0_q;
 	reg alu_wait, alu_wait_2;
 
 	reg [31:0] alu_add_sub;
 	reg [31:0] alu_shl, alu_shr;
 	reg alu_eq, alu_ltu, alu_lts;
 
 	generate if (TWO_CYCLE_ALU) begin
 		always @(posedge clk) begin
 			alu_add_sub <= instr_sub ? reg_op1 - reg_op2 : reg_op1 + reg_op2;
 			alu_eq <= reg_op1 == reg_op2;
 			alu_lts <= $signed(reg_op1) < $signed(reg_op2);
 			alu_ltu <= reg_op1 < reg_op2;
 			alu_shl <= reg_op1 << reg_op2[4:0];
 			alu_shr <= $signed({instr_sra || instr_srai ? reg_op1[31] : 1'b0, reg_op1}) >>> reg_op2[4:0];
 		end
 	end else begin
 		always @* begin
 			alu_add_sub = instr_sub ? reg_op1 - reg_op2 : reg_op1 + reg_op2;
 			alu_eq = reg_op1 == reg_op2;
 			alu_lts = $signed(reg_op1) < $signed(reg_op2);
 			alu_ltu = reg_op1 < reg_op2;
 			alu_shl = reg_op1 << reg_op2[4:0];
 			alu_shr = $signed({instr_sra || instr_srai ? reg_op1[31] : 1'b0, reg_op1}) >>> reg_op2[4:0];
 		end
 	end endgenerate
 
 	always @* begin
 		alu_out_0 = 'bx;
 		(* parallel_case, full_case *)
 		case (1'b1)
 			instr_beq:
 				alu_out_0 = alu_eq;
 			instr_bne:
 				alu_out_0 = !alu_eq;
 			instr_bge:
 				alu_out_0 = !alu_lts;
 			instr_bgeu:
 				alu_out_0 = !alu_ltu;
 			is_slti_blt_slt && (!TWO_CYCLE_COMPARE || !{instr_beq,instr_bne,instr_bge,instr_bgeu}):
 				alu_out_0 = alu_lts;
 			is_sltiu_bltu_sltu && (!TWO_CYCLE_COMPARE || !{instr_beq,instr_bne,instr_bge,instr_bgeu}):
 				alu_out_0 = alu_ltu;
 		endcase
 
 		alu_out = 'bx;
 		(* parallel_case, full_case *)
 		case (1'b1)
 			is_lui_auipc_jal_jalr_addi_add_sub:
 				alu_out = alu_add_sub;
 			is_compare:
 				alu_out = alu_out_0;
 			instr_xori || instr_xor:
 				alu_out = reg_op1 ^ reg_op2;
 			instr_ori || instr_or:
 				alu_out = reg_op1 | reg_op2;
 			instr_andi || instr_and:
 				alu_out = reg_op1 & reg_op2;
 			BARREL_SHIFTER && (instr_sll || instr_slli):
 				alu_out = alu_shl;
 			BARREL_SHIFTER && (instr_srl || instr_srli || instr_sra || instr_srai):
 				alu_out = alu_shr;
 		endcase
 
 `ifdef RISCV_FORMAL_BLACKBOX_ALU
 		alu_out_0 = $anyseq;
 		alu_out = $anyseq;
 `endif
 	end
 
 	reg clear_prefetched_high_word_q;
 	always @(posedge clk) clear_prefetched_high_word_q <= clear_prefetched_high_word;
 
 	always @* begin
 		clear_prefetched_high_word = clear_prefetched_high_word_q;
 		if (!prefetched_high_word)
 			clear_prefetched_high_word = 0;
 		if (latched_branch || irq_state || !resetn)
 			clear_prefetched_high_word = COMPRESSED_ISA;
 	end
 
 	reg cpuregs_write;
 	reg [31:0] cpuregs_wrdata_i;
     assign cpuregs_wrdata = cpuregs_wrdata_i;
 	reg [31:0] cpuregs_rs1;
 	reg [31:0] cpuregs_rs2;
 	reg [regindex_bits-1:0] decoded_rs;
 
 	always @* begin
 		cpuregs_write = 0;
 		cpuregs_wrdata_i = 'bx;
 
 		if (cpu_state == cpu_state_fetch) begin
 			(* parallel_case *)
 			case (1'b1)
 				latched_branch: begin
 					cpuregs_wrdata_i = reg_pc + (latched_compr ? 2 : 4);
 					cpuregs_write = 1;
 				end
 				latched_store && !latched_branch: begin
 					cpuregs_wrdata_i = latched_stalu ? alu_out_q : reg_out;
 					cpuregs_write = 1;
 				end
 				ENABLE_IRQ && irq_state[0]: begin
 					cpuregs_wrdata_i = reg_next_pc | latched_compr;
 					cpuregs_write = 1;
 				end
 				ENABLE_IRQ && irq_state[1]: begin
 					cpuregs_wrdata_i = irq_pending & ~irq_mask;
 					cpuregs_write = 1;
 				end
 			endcase
 		end
 	end
 
 `ifndef PICORV32_REGS
 	always @(posedge clk) begin
 		if (resetn && cpuregs_write && latched_rd)
 			cpuregs[latched_rd] <= cpuregs_wrdata_i;
 	end
 
 	always @* begin
 		decoded_rs = 'bx;
 		if (ENABLE_REGS_DUALPORT) begin
 `ifndef RISCV_FORMAL_BLACKBOX_REGS
 			cpuregs_rs1 = decoded_rs1 ? cpuregs[decoded_rs1] : 0;
 			cpuregs_rs2 = decoded_rs2 ? cpuregs[decoded_rs2] : 0;
 `else
 			cpuregs_rs1 = decoded_rs1 ? $anyseq : 0;
 			cpuregs_rs2 = decoded_rs2 ? $anyseq : 0;
 `endif
 		end else begin
 			decoded_rs = (cpu_state == cpu_state_ld_rs2) ? decoded_rs2 : decoded_rs1;
 `ifndef RISCV_FORMAL_BLACKBOX_REGS
 			cpuregs_rs1 = decoded_rs ? cpuregs[decoded_rs] : 0;
 `else
 			cpuregs_rs1 = decoded_rs ? $anyseq : 0;
 `endif
 			cpuregs_rs2 = cpuregs_rs1;
 		end
 	end
 `else
 
 	assign cpuregs_waddr = latched_rd;
 	assign cpuregs_raddr1 = ENABLE_REGS_DUALPORT ? decoded_rs1 : decoded_rs;
 	assign cpuregs_raddr2 = ENABLE_REGS_DUALPORT ? decoded_rs2 : 0;
 
 	always @* begin
 		decoded_rs = 'bx;
 		if (ENABLE_REGS_DUALPORT) begin
 			cpuregs_rs1 = decoded_rs1 ? cpuregs_rdata1 : 0;
 			cpuregs_rs2 = decoded_rs2 ? cpuregs_rdata2 : 0;
 		end else begin
 			decoded_rs = (cpu_state == cpu_state_ld_rs2) ? decoded_rs2 : decoded_rs1;
 			cpuregs_rs1 = decoded_rs ? cpuregs_rdata1 : 0;
 			cpuregs_rs2 = cpuregs_rs1;
 		end
 	end
 `endif
 
 	assign launch_next_insn = cpu_state == cpu_state_fetch && decoder_trigger && (!ENABLE_IRQ || irq_delay || irq_active || !(irq_pending & ~irq_mask));
 
 	always @(posedge clk) begin
 		trap <= 0;
 		reg_sh <= 'bx;
 		reg_out <= 'bx;
 		set_mem_do_rinst = 0;
 		set_mem_do_rdata = 0;
 		set_mem_do_wdata = 0;
 
 		alu_out_0_q <= alu_out_0;
 		alu_out_q <= alu_out;
 
 		alu_wait <= 0;
 		alu_wait_2 <= 0;
 
 		if (launch_next_insn) begin
 			dbg_rs1val <= 'bx;
 			dbg_rs2val <= 'bx;
 			dbg_rs1val_valid <= 0;
 			dbg_rs2val_valid <= 0;
 		end
 
 		if (WITH_PCPI && CATCH_ILLINSN) begin
 			if (resetn && pcpi_valid_i && !pcpi_int_wait) begin
 				if (pcpi_timeout_counter)
 					pcpi_timeout_counter <= pcpi_timeout_counter - 1;
 			end else
 				pcpi_timeout_counter <= ~0;
 			pcpi_timeout <= !pcpi_timeout_counter;
 		end
 
 		if (ENABLE_COUNTERS) begin
 			count_cycle <= resetn ? count_cycle + 1 : 0;
 			if (!ENABLE_COUNTERS64) count_cycle[63:32] <= 0;
 		end else begin
 			count_cycle <= 'bx;
 			count_instr <= 'bx;
 		end
 
 		next_irq_pending = ENABLE_IRQ ? irq_pending & LATCHED_IRQ : 'bx;
 
 		if (ENABLE_IRQ && ENABLE_IRQ_TIMER && timer) begin
 			if (timer - 1 == 0)
 				next_irq_pending[irq_timer] = 1;
 			timer <= timer - 1;
 		end
 
 		if (ENABLE_IRQ) begin
 			next_irq_pending = next_irq_pending | irq;
 		end
 
 		decoder_trigger <= mem_do_rinst && mem_done;
 		decoder_trigger_q <= decoder_trigger;
 		decoder_pseudo_trigger <= 0;
 		decoder_pseudo_trigger_q <= decoder_pseudo_trigger;
 		do_waitirq <= 0;
 
 		trace_valid <= 0;
 
 		if (!ENABLE_TRACE)
 			trace_data <= 'bx;
 
 		if (!resetn) begin
 			reg_pc <= PROGADDR_RESET;
 			reg_next_pc <= PROGADDR_RESET;
 			if (ENABLE_COUNTERS)
 				count_instr <= 0;
 			latched_store <= 0;
 			latched_stalu <= 0;
 			latched_branch <= 0;
 			latched_trace <= 0;
 			latched_is_lu <= 0;
 			latched_is_lh <= 0;
 			latched_is_lb <= 0;
 			pcpi_valid_i <= 0;
 			pcpi_timeout <= 0;
 			irq_active <= 0;
 			irq_delay <= 0;
 			irq_mask <= ~0;
 			next_irq_pending = 0;
 			irq_state <= 0;
 			eoi <= 0;
 			timer <= 0;
 			if (~STACKADDR) begin
 				latched_store <= 1;
 				latched_rd <= 2;
 				reg_out <= STACKADDR;
 			end
 			cpu_state <= cpu_state_fetch;
 		end else
 		(* parallel_case, full_case *)
 		case (cpu_state)
 			cpu_state_trap: begin
 				trap <= 1;
 			end
 
 			cpu_state_fetch: begin
 				mem_do_rinst <= !decoder_trigger && !do_waitirq;
 				mem_wordsize <= 0;
 
 				current_pc = reg_next_pc;
 
 				(* parallel_case *)
 				case (1'b1)
 					latched_branch: begin
 						current_pc = latched_store ? (latched_stalu ? alu_out_q : reg_out) & ~1 : reg_next_pc;
 						//`debug($display("ST_RD:  %2d 0x%08x, BRANCH 0x%08x", latched_rd, reg_pc + (latched_compr ? 2 : 4), current_pc);)
 					end
 					latched_store && !latched_branch: begin
 						//`debug($display("ST_RD:  %2d 0x%08x", latched_rd, latched_stalu ? alu_out_q : reg_out);)
 					end
 					ENABLE_IRQ && irq_state[0]: begin
 						current_pc = PROGADDR_IRQ;
 						irq_active <= 1;
 						mem_do_rinst <= 1;
 					end
 					ENABLE_IRQ && irq_state[1]: begin
 						eoi <= irq_pending & ~irq_mask;
 						next_irq_pending = next_irq_pending & irq_mask;
 					end
 				endcase
 
 				if (ENABLE_TRACE && latched_trace) begin
 					latched_trace <= 0;
 					trace_valid <= 1;
 					if (latched_branch)
 						trace_data <= (irq_active ? TRACE_IRQ : 0) | TRACE_BRANCH | (current_pc & 32'hfffffffe);
 					else
 						trace_data <= (irq_active ? TRACE_IRQ : 0) | (latched_stalu ? alu_out_q : reg_out);
 				end
 
 				reg_pc <= current_pc;
 				reg_next_pc <= current_pc;
 
 				latched_store <= 0;
 				latched_stalu <= 0;
 				latched_branch <= 0;
 				latched_is_lu <= 0;
 				latched_is_lh <= 0;
 				latched_is_lb <= 0;
 				latched_rd <= decoded_rd;
 				latched_compr <= compressed_instr;
 
 				if (ENABLE_IRQ && ((decoder_trigger && !irq_active && !irq_delay && |(irq_pending & ~irq_mask)) || irq_state)) begin
 					irq_state <=
 						irq_state == 2'b00 ? 2'b01 :
 						irq_state == 2'b01 ? 2'b10 : 2'b00;
 					latched_compr <= latched_compr;
 					if (ENABLE_IRQ_QREGS)
 						latched_rd <= irqregs_offset | irq_state[0];
 					else
 						latched_rd <= irq_state[0] ? 4 : 3;
 				end else
 				if (ENABLE_IRQ && (decoder_trigger || do_waitirq) && instr_waitirq) begin
 					if (irq_pending) begin
 						latched_store <= 1;
 						reg_out <= irq_pending;
 						reg_next_pc <= current_pc + (compressed_instr ? 2 : 4);
 						mem_do_rinst <= 1;
 					end else
 						do_waitirq <= 1;
 				end else
 				if (decoder_trigger) begin
 					//`debug($display("-- %-0t", $time);)
 					irq_delay <= irq_active;
 					reg_next_pc <= current_pc + (compressed_instr ? 2 : 4);
 					if (ENABLE_TRACE)
 						latched_trace <= 1;
 					if (ENABLE_COUNTERS) begin
 						count_instr <= count_instr + 1;
 						if (!ENABLE_COUNTERS64) count_instr[63:32] <= 0;
 					end
 					if (instr_jal) begin
 						mem_do_rinst <= 1;
 						reg_next_pc <= current_pc + decoded_imm_uj;
 						latched_branch <= 1;
 					end else begin
 						mem_do_rinst <= 0;
 						mem_do_prefetch <= !instr_jalr && !instr_retirq;
 						cpu_state <= cpu_state_ld_rs1;
 					end
 				end
 			end
 
 			cpu_state_ld_rs1: begin
 				reg_op1 <= 'bx;
 				reg_op2 <= 'bx;
 
 				(* parallel_case *)
 				case (1'b1)
 					(CATCH_ILLINSN || WITH_PCPI) && instr_trap: begin
 						if (WITH_PCPI) begin
 							//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 							reg_op1 <= cpuregs_rs1;
 							dbg_rs1val <= cpuregs_rs1;
 							dbg_rs1val_valid <= 1;
 							if (ENABLE_REGS_DUALPORT) begin
 								pcpi_valid_i <= 1;
 								//`debug($display("LD_RS2: %2d 0x%08x", decoded_rs2, cpuregs_rs2);)
 								reg_sh <= cpuregs_rs2;
 								reg_op2 <= cpuregs_rs2;
 								dbg_rs2val <= cpuregs_rs2;
 								dbg_rs2val_valid <= 1;
 								if (pcpi_int_ready) begin
 									mem_do_rinst <= 1;
 									pcpi_valid_i <= 0;
 									reg_out <= pcpi_int_rd;
 									latched_store <= pcpi_int_wr;
 									cpu_state <= cpu_state_fetch;
 								end else
 								if (CATCH_ILLINSN && (pcpi_timeout || instr_ecall_ebreak)) begin
 									pcpi_valid_i <= 0;
 									//`debug($display("EBREAK OR UNSUPPORTED INSN AT 0x%08x", reg_pc);)
 									if (ENABLE_IRQ && !irq_mask[irq_ebreak] && !irq_active) begin
 										next_irq_pending[irq_ebreak] = 1;
 										cpu_state <= cpu_state_fetch;
 									end else
 										cpu_state <= cpu_state_trap;
 								end
 							end else begin
 								cpu_state <= cpu_state_ld_rs2;
 							end
 						end else begin
 							//`debug($display("EBREAK OR UNSUPPORTED INSN AT 0x%08x", reg_pc);)
 							if (ENABLE_IRQ && !irq_mask[irq_ebreak] && !irq_active) begin
 								next_irq_pending[irq_ebreak] = 1;
 								cpu_state <= cpu_state_fetch;
 							end else
 								cpu_state <= cpu_state_trap;
 						end
 					end
 					ENABLE_COUNTERS && is_rdcycle_rdcycleh_rdinstr_rdinstrh: begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							instr_rdcycle:
 								reg_out <= count_cycle[31:0];
 							instr_rdcycleh && ENABLE_COUNTERS64:
 								reg_out <= count_cycle[63:32];
 							instr_rdinstr:
 								reg_out <= count_instr[31:0];
 							instr_rdinstrh && ENABLE_COUNTERS64:
 								reg_out <= count_instr[63:32];
 						endcase
 						latched_store <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					is_lui_auipc_jal: begin
 						reg_op1 <= instr_lui ? 0 : reg_pc;
 						reg_op2 <= decoded_imm;
 						if (TWO_CYCLE_ALU)
 							alu_wait <= 1;
 						else
 							mem_do_rinst <= mem_do_prefetch;
 						cpu_state <= cpu_state_exec;
 					end
 					ENABLE_IRQ && ENABLE_IRQ_QREGS && instr_getq: begin
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_out <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						latched_store <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && ENABLE_IRQ_QREGS && instr_setq: begin
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_out <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						latched_rd <= latched_rd | irqregs_offset;
 						latched_store <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && instr_retirq: begin
 						//eoi <= 0;
 						irq_active <= 0;
 						latched_branch <= 1;
 						latched_store <= 1;
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_out <= CATCH_MISALIGN ? (cpuregs_rs1 & 32'h fffffffe) : cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && instr_maskirq: begin
 						latched_store <= 1;
 						reg_out <= irq_mask;
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						irq_mask <= cpuregs_rs1 | MASKED_IRQ;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && ENABLE_IRQ_TIMER && instr_timer: begin
 						latched_store <= 1;
 						reg_out <= timer;
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						timer <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					is_lb_lh_lw_lbu_lhu && !instr_trap: begin
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_ldmem;
 						mem_do_rinst <= 1;
 					end
 					is_slli_srli_srai && !BARREL_SHIFTER: begin
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						reg_sh <= decoded_rs2;
 						cpu_state <= cpu_state_shift;
 					end
 					is_jalr_addi_slti_sltiu_xori_ori_andi, is_slli_srli_srai && BARREL_SHIFTER: begin
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						reg_op2 <= is_slli_srli_srai && BARREL_SHIFTER ? decoded_rs2 : decoded_imm;
 						if (TWO_CYCLE_ALU)
 							alu_wait <= 1;
 						else
 							mem_do_rinst <= mem_do_prefetch;
 						cpu_state <= cpu_state_exec;
 					end
 					default: begin
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						if (ENABLE_REGS_DUALPORT) begin
 							//`debug($display("LD_RS2: %2d 0x%08x", decoded_rs2, cpuregs_rs2);)
 							reg_sh <= cpuregs_rs2;
 							reg_op2 <= cpuregs_rs2;
 							dbg_rs2val <= cpuregs_rs2;
 							dbg_rs2val_valid <= 1;
 							(* parallel_case *)
 							case (1'b1)
 								is_sb_sh_sw: begin
 									cpu_state <= cpu_state_stmem;
 									mem_do_rinst <= 1;
 								end
 								is_sll_srl_sra && !BARREL_SHIFTER: begin
 									cpu_state <= cpu_state_shift;
 								end
 								default: begin
 									if (TWO_CYCLE_ALU || (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu)) begin
 										alu_wait_2 <= TWO_CYCLE_ALU && (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu);
 										alu_wait <= 1;
 									end else
 										mem_do_rinst <= mem_do_prefetch;
 									cpu_state <= cpu_state_exec;
 								end
 							endcase
 						end else
 							cpu_state <= cpu_state_ld_rs2;
 					end
 				endcase
 			end
 
 			cpu_state_ld_rs2: begin
 				//`debug($display("LD_RS2: %2d 0x%08x", decoded_rs2, cpuregs_rs2);)
 				reg_sh <= cpuregs_rs2;
 				reg_op2 <= cpuregs_rs2;
 				dbg_rs2val <= cpuregs_rs2;
 				dbg_rs2val_valid <= 1;
 
 				(* parallel_case *)
 				case (1'b1)
 					WITH_PCPI && instr_trap: begin
 						pcpi_valid_i <= 1;
 						if (pcpi_int_ready) begin
 							mem_do_rinst <= 1;
 							pcpi_valid_i <= 0;
 							reg_out <= pcpi_int_rd;
 							latched_store <= pcpi_int_wr;
 							cpu_state <= cpu_state_fetch;
 						end else
 						if (CATCH_ILLINSN && (pcpi_timeout || instr_ecall_ebreak)) begin
 							pcpi_valid_i <= 0;
 							//`debug($display("EBREAK OR UNSUPPORTED INSN AT 0x%08x", reg_pc);)
 							if (ENABLE_IRQ && !irq_mask[irq_ebreak] && !irq_active) begin
 								next_irq_pending[irq_ebreak] = 1;
 								cpu_state <= cpu_state_fetch;
 							end else
 								cpu_state <= cpu_state_trap;
 						end
 					end
 					is_sb_sh_sw: begin
 						cpu_state <= cpu_state_stmem;
 						mem_do_rinst <= 1;
 					end
 					is_sll_srl_sra && !BARREL_SHIFTER: begin
 						cpu_state <= cpu_state_shift;
 					end
 					default: begin
 						if (TWO_CYCLE_ALU || (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu)) begin
 							alu_wait_2 <= TWO_CYCLE_ALU && (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu);
 							alu_wait <= 1;
 						end else
 							mem_do_rinst <= mem_do_prefetch;
 						cpu_state <= cpu_state_exec;
 					end
 				endcase
 			end
 
 			cpu_state_exec: begin
 				reg_out <= reg_pc + decoded_imm;
 				if ((TWO_CYCLE_ALU || TWO_CYCLE_COMPARE) && (alu_wait || alu_wait_2)) begin
 					mem_do_rinst <= mem_do_prefetch && !alu_wait_2;
 					alu_wait <= alu_wait_2;
 				end else
 				if (is_beq_bne_blt_bge_bltu_bgeu) begin
 					latched_rd <= 0;
 					latched_store <= TWO_CYCLE_COMPARE ? alu_out_0_q : alu_out_0;
 					latched_branch <= TWO_CYCLE_COMPARE ? alu_out_0_q : alu_out_0;
 					if (mem_done)
 						cpu_state <= cpu_state_fetch;
 					if (TWO_CYCLE_COMPARE ? alu_out_0_q : alu_out_0) begin
 						decoder_trigger <= 0;
 						set_mem_do_rinst = 1;
 					end
 				end else begin
 					latched_branch <= instr_jalr;
 					latched_store <= 1;
 					latched_stalu <= 1;
 					cpu_state <= cpu_state_fetch;
 				end
 			end
 
 			cpu_state_shift: begin
 				latched_store <= 1;
 				if (reg_sh == 0) begin
 					reg_out <= reg_op1;
 					mem_do_rinst <= mem_do_prefetch;
 					cpu_state <= cpu_state_fetch;
 				end else if (TWO_STAGE_SHIFT && reg_sh >= 4) begin
 					(* parallel_case, full_case *)
 					case (1'b1)
 						instr_slli || instr_sll: reg_op1 <= reg_op1 << 4;
 						instr_srli || instr_srl: reg_op1 <= reg_op1 >> 4;
 						instr_srai || instr_sra: reg_op1 <= $signed(reg_op1) >>> 4;
 					endcase
 					reg_sh <= reg_sh - 4;
 				end else begin
 					(* parallel_case, full_case *)
 					case (1'b1)
 						instr_slli || instr_sll: reg_op1 <= reg_op1 << 1;
 						instr_srli || instr_srl: reg_op1 <= reg_op1 >> 1;
 						instr_srai || instr_sra: reg_op1 <= $signed(reg_op1) >>> 1;
 					endcase
 					reg_sh <= reg_sh - 1;
 				end
 			end
 
 			cpu_state_stmem: begin
 				if (ENABLE_TRACE)
 					reg_out <= reg_op2;
 				if (!mem_do_prefetch || mem_done) begin
 					if (!mem_do_wdata) begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							instr_sb: mem_wordsize <= 2;
 							instr_sh: mem_wordsize <= 1;
 							instr_sw: mem_wordsize <= 0;
 						endcase
 						if (ENABLE_TRACE) begin
 							trace_valid <= 1;
 							trace_data <= (irq_active ? TRACE_IRQ : 0) | TRACE_ADDR | ((reg_op1 + decoded_imm) & 32'hffffffff);
 						end
 						reg_op1 <= reg_op1 + decoded_imm;
 						set_mem_do_wdata = 1;
 					end
 					if (!mem_do_prefetch && mem_done) begin
 						cpu_state <= cpu_state_fetch;
 						decoder_trigger <= 1;
 						decoder_pseudo_trigger <= 1;
 					end
 				end
 			end
 
 			cpu_state_ldmem: begin
 				latched_store <= 1;
 				if (!mem_do_prefetch || mem_done) begin
 					if (!mem_do_rdata) begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							instr_lb || instr_lbu: mem_wordsize <= 2;
 							instr_lh || instr_lhu: mem_wordsize <= 1;
 							instr_lw: mem_wordsize <= 0;
 						endcase
 						latched_is_lu <= is_lbu_lhu_lw;
 						latched_is_lh <= instr_lh;
 						latched_is_lb <= instr_lb;
 						if (ENABLE_TRACE) begin
 							trace_valid <= 1;
 							trace_data <= (irq_active ? TRACE_IRQ : 0) | TRACE_ADDR | ((reg_op1 + decoded_imm) & 32'hffffffff);
 						end
 						reg_op1 <= reg_op1 + decoded_imm;
 						set_mem_do_rdata = 1;
 					end
 					if (!mem_do_prefetch && mem_done) begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							latched_is_lu: reg_out <= mem_rdata_word;
 							latched_is_lh: reg_out <= $signed(mem_rdata_word[15:0]);
 							latched_is_lb: reg_out <= $signed(mem_rdata_word[7:0]);
 						endcase
 						decoder_trigger <= 1;
 						decoder_pseudo_trigger <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 				end
 			end
 		endcase
 
 		if (CATCH_MISALIGN && resetn && (mem_do_rdata || mem_do_wdata)) begin
 			if (mem_wordsize == 0 && reg_op1[1:0] != 0) begin
 				//`debug($display("MISALIGNED WORD: 0x%08x", reg_op1);)
 				if (ENABLE_IRQ && !irq_mask[irq_buserror] && !irq_active) begin
 					next_irq_pending[irq_buserror] = 1;
 				end else
 					cpu_state <= cpu_state_trap;
 			end
 			if (mem_wordsize == 1 && reg_op1[0] != 0) begin
 				//`debug($display("MISALIGNED HALFWORD: 0x%08x", reg_op1);)
 				if (ENABLE_IRQ && !irq_mask[irq_buserror] && !irq_active) begin
 					next_irq_pending[irq_buserror] = 1;
 				end else
 					cpu_state <= cpu_state_trap;
 			end
 		end
 		if (CATCH_MISALIGN && resetn && mem_do_rinst && (COMPRESSED_ISA ? reg_pc[0] : |reg_pc[1:0])) begin
 			//`debug($display("MISALIGNED INSTRUCTION: 0x%08x", reg_pc);)
 			if (ENABLE_IRQ && !irq_mask[irq_buserror] && !irq_active) begin
 				next_irq_pending[irq_buserror] = 1;
 			end else
 				cpu_state <= cpu_state_trap;
 		end
 		if (!CATCH_ILLINSN && decoder_trigger_q && !decoder_pseudo_trigger_q && instr_ecall_ebreak) begin
 			cpu_state <= cpu_state_trap;
 		end
 
 		if (!resetn || mem_done) begin
 			mem_do_prefetch <= 0;
 			mem_do_rinst <= 0;
 			mem_do_rdata <= 0;
 			mem_do_wdata <= 0;
 		end
 
 		if (set_mem_do_rinst)
 			mem_do_rinst <= 1;
 		if (set_mem_do_rdata)
 			mem_do_rdata <= 1;
 		if (set_mem_do_wdata)
 			mem_do_wdata <= 1;
 
 		irq_pending <= next_irq_pending & ~MASKED_IRQ;
 
 		if (!CATCH_MISALIGN) begin
 			if (COMPRESSED_ISA) begin
 				reg_pc[0] <= 0;
 				reg_next_pc[0] <= 0;
 			end else begin
 				reg_pc[1:0] <= 0;
 				reg_next_pc[1:0] <= 0;
 			end
 		end
 		current_pc = 'bx;
 	end
 
 `ifdef RISCV_FORMAL
 	reg dbg_irq_call;
 	reg dbg_irq_enter;
 	reg [31:0] dbg_irq_ret;
 	always @(posedge clk) begin
 		rvfi_valid <= resetn && (launch_next_insn || trap) && dbg_valid_insn;
 		rvfi_order <= resetn ? rvfi_order + rvfi_valid : 0;
 
 		rvfi_insn <= dbg_insn_opcode;
 		rvfi_rs1_addr <= dbg_rs1val_valid ? dbg_insn_rs1 : 0;
 		rvfi_rs2_addr <= dbg_rs2val_valid ? dbg_insn_rs2 : 0;
 		rvfi_pc_rdata <= dbg_insn_addr;
 		rvfi_rs1_rdata <= dbg_rs1val_valid ? dbg_rs1val : 0;
 		rvfi_rs2_rdata <= dbg_rs2val_valid ? dbg_rs2val : 0;
 		rvfi_trap <= trap;
 		rvfi_halt <= trap;
 		rvfi_intr <= dbg_irq_enter;
 		rvfi_mode <= 3;
 
 		if (!resetn) begin
 			dbg_irq_call <= 0;
 			dbg_irq_enter <= 0;
 		end else
 		if (rvfi_valid) begin
 			dbg_irq_call <= 0;
 			dbg_irq_enter <= dbg_irq_call;
 		end else
 		if (irq_state == 1) begin
 			dbg_irq_call <= 1;
 			dbg_irq_ret <= next_pc;
 		end
 
 		if (!resetn) begin
 			rvfi_rd_addr <= 0;
 			rvfi_rd_wdata <= 0;
 		end else
 		if (cpuregs_write && !irq_state) begin
 			rvfi_rd_addr <= latched_rd;
 			rvfi_rd_wdata <= latched_rd ? cpuregs_wrdata_i : 0;
 		end else
 		if (rvfi_valid) begin
 			rvfi_rd_addr <= 0;
 			rvfi_rd_wdata <= 0;
 		end
 
 		casez (dbg_insn_opcode)
 			32'b 0000000_?????_000??_???_?????_0001011: begin // getq
 				rvfi_rs1_addr <= 0;
 				rvfi_rs1_rdata <= 0;
 			end
 			32'b 0000001_?????_?????_???_000??_0001011: begin // setq
 				rvfi_rd_addr <= 0;
 				rvfi_rd_wdata <= 0;
 			end
 			32'b 0000010_?????_00000_???_00000_0001011: begin // retirq
 				rvfi_rs1_addr <= 0;
 				rvfi_rs1_rdata <= 0;
 			end
 		endcase
 
 		if (!dbg_irq_call) begin
 			if (dbg_mem_instr) begin
 				rvfi_mem_addr <= 0;
 				rvfi_mem_rmask <= 0;
 				rvfi_mem_wmask <= 0;
 				rvfi_mem_rdata <= 0;
 				rvfi_mem_wdata <= 0;
 			end else
 			if (dbg_mem_valid && dbg_mem_ready) begin
 				rvfi_mem_addr <= dbg_mem_addr;
 				rvfi_mem_rmask <= dbg_mem_wstrb ? 0 : ~0;
 				rvfi_mem_wmask <= dbg_mem_wstrb;
 				rvfi_mem_rdata <= dbg_mem_rdata;
 				rvfi_mem_wdata <= dbg_mem_wdata;
 			end
 		end
 	end
 
 	always @* begin
 		rvfi_pc_wdata = dbg_irq_call ? dbg_irq_ret : dbg_insn_addr;
 	end
 `endif
 
 	// Formal Verification
 `ifdef FORMAL
 	reg [3:0] last_mem_nowait;
 	always @(posedge clk)
 		last_mem_nowait <= {last_mem_nowait, mem_ready || !mem_valid_i};
 
 	// stall the memory interface for max 4 cycles
 	restrict property (|last_mem_nowait || mem_ready || !mem_valid_i);
 
 	// resetn low in first cycle, after that resetn high
 	restrict property (resetn != $initstate);
 
 	// this just makes it much easier to read traces. uncomment as needed.
 	// assume property (mem_valid || !mem_ready);
 
 	reg ok;
 	always @* begin
 		if (resetn) begin
 			// instruction fetches are read-only
 			if (mem_valid_i && mem_instr_i)
 				assert (mem_wstrb_i == 0);
 
 			// cpu_state must be valid
 			ok = 0;
 			if (cpu_state == cpu_state_trap)   ok = 1;
 			if (cpu_state == cpu_state_fetch)  ok = 1;
 			if (cpu_state == cpu_state_ld_rs1) ok = 1;
 			if (cpu_state == cpu_state_ld_rs2) ok = !ENABLE_REGS_DUALPORT;
 			if (cpu_state == cpu_state_exec)   ok = 1;
 			if (cpu_state == cpu_state_shift)  ok = 1;
 			if (cpu_state == cpu_state_stmem)  ok = 1;
 			if (cpu_state == cpu_state_ldmem)  ok = 1;
 			assert (ok);
 		end
 	end
 
 	reg last_mem_la_read = 0;
 	reg last_mem_la_write = 0;
 	reg [31:0] last_mem_la_addr;
 	reg [31:0] last_mem_la_wdata;
 	reg [3:0] last_mem_la_wstrb = 0;
 
 	always @(posedge clk) begin
 		last_mem_la_read <= mem_la_read;
 		last_mem_la_write <= mem_la_write;
 		last_mem_la_addr <= mem_la_addr;
 		last_mem_la_wdata <= mem_la_wdata;
 		last_mem_la_wstrb <= mem_la_wstrb;
 
 		if (last_mem_la_read) begin
 			assert(mem_valid_i);
 			assert(mem_addr_i == last_mem_la_addr);
 			assert(mem_wstrb_i == 0);
 		end
 		if (last_mem_la_write) begin
 			assert(mem_valid_i);
 			assert(mem_addr_i == last_mem_la_addr);
 			assert(mem_wdata_i == last_mem_la_wdata);
 			assert(mem_wstrb_i == last_mem_la_wstrb);
 		end
 		if (mem_la_read || mem_la_write) begin
 			assert(!mem_valid_i || mem_ready);
 		end
 	end
 `endif
 
endmodule
//---- Top entity
module v55b120 #(
 parameter v9b0b95 = 5,
 parameter v1ab793 = 'h76,
 parameter v498463 = 1,
 parameter v1ff51b = 8
) (
 input v379e9e,
 input [3:0] veea9f4,
 input [3:0] vda0d16,
 input [3:0] v3d0cdd,
 input [3:0] v9119d0,
 input v1cd63b,
 output v92ad22,
 output v7aeba1,
 output v47023d,
 output v265b49,
 output vfe95a2
);
 localparam p2 = v1ff51b;
 localparam p3 = v9b0b95;
 localparam p6 = v1ab793;
 localparam p27 = v498463;
 wire w0;
 wire w1;
 wire w4;
 wire w5;
 wire [0:7] w7;
 wire [0:3] w8;
 wire [0:3] w9;
 wire [0:2] w10;
 wire [0:7] w11;
 wire [0:3] w12;
 wire [0:3] w13;
 wire [0:3] w14;
 wire [0:3] w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire [0:3] w20;
 wire [0:3] w21;
 wire [0:3] w22;
 wire [0:3] w23;
 wire [0:3] w24;
 wire [0:3] w25;
 wire w26;
 wire w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 wire w33;
 wire w34;
 wire w35;
 wire w36;
 wire [0:7] w37;
 wire w38;
 wire w39;
 wire w40;
 wire [0:7] w41;
 wire [0:7] w42;
 wire [0:7] w43;
 assign v92ad22 = w0;
 assign v7aeba1 = w1;
 assign w12 = v9119d0;
 assign w13 = v3d0cdd;
 assign w14 = vda0d16;
 assign w15 = veea9f4;
 assign w16 = v1cd63b;
 assign w17 = v1cd63b;
 assign w18 = v1cd63b;
 assign w19 = v1cd63b;
 assign v47023d = w26;
 assign w28 = v379e9e;
 assign w29 = v379e9e;
 assign w30 = v379e9e;
 assign w31 = v379e9e;
 assign w32 = v379e9e;
 assign w33 = v379e9e;
 assign w34 = v379e9e;
 assign vfe95a2 = w36;
 assign w38 = v1cd63b;
 assign w39 = v1cd63b;
 assign v265b49 = w40;
 assign w9 = w8;
 assign w17 = w16;
 assign w18 = w16;
 assign w18 = w17;
 assign w19 = w16;
 assign w19 = w17;
 assign w19 = w18;
 assign w22 = w8;
 assign w22 = w9;
 assign w23 = w8;
 assign w23 = w9;
 assign w23 = w22;
 assign w29 = w28;
 assign w30 = w28;
 assign w30 = w29;
 assign w31 = w28;
 assign w31 = w29;
 assign w31 = w30;
 assign w32 = w28;
 assign w32 = w29;
 assign w32 = w30;
 assign w32 = w31;
 assign w33 = w28;
 assign w33 = w29;
 assign w33 = w30;
 assign w33 = w31;
 assign w33 = w32;
 assign w34 = w28;
 assign w34 = w29;
 assign w34 = w30;
 assign w34 = w31;
 assign w34 = w32;
 assign w34 = w33;
 assign w36 = w35;
 assign w38 = w16;
 assign w38 = w17;
 assign w38 = w18;
 assign w38 = w19;
 assign w39 = w16;
 assign w39 = w17;
 assign w39 = w18;
 assign w39 = w19;
 assign w39 = w38;
 v5ad97e #(
  .vc5c8ea(p6)
 ) vec171a (
  .v26dbdb(w11)
 );
 v76e9bf v386d4b (
  .v3fb88b(w7),
  .v97d40b(w10),
  .v3d1227(w11),
  .v062092(w37),
  .v30db33(w41),
  .v21e136(w42),
  .vbdd51f(w43)
 );
 v917222 v45c2db (
  .v285646(w8),
  .v766044(w21),
  .va191ad(w42)
 );
 va0b8df vec6754 (
  .va50a91(w8)
 );
 v917222 v50448f (
  .v285646(w9),
  .v766044(w20),
  .va191ad(w37)
 );
 v917222 v3cc599 (
  .v285646(w23),
  .v766044(w24),
  .va191ad(w41)
 );
 v917222 v05a94e (
  .v285646(w22),
  .v766044(w25),
  .va191ad(w43)
 );
 v07facf #(
  .vc20cea(p2)
 ) v0fb61d (
  .v97d6b9(w0),
  .v0b8191(w1),
  .vab2972(w4),
  .vd03772(w5),
  .vdae213(w7),
  .v9c4682(w30)
 );
 vd42255 #(
  .vaceb8f(p3)
 ) ve70865 (
  .v69602e(w4),
  .v87e8cb(w5),
  .v8b9e30(w10),
  .v192615(w33),
  .v8314fa(w35),
  .vbdbcb4(w39),
  .v680136(w40)
 );
 vef2764 #(
  .v573b2a(p27)
 ) vb0493a (
  .v4642b6(w26),
  .v6dda25(w28),
  .v27dec4(w35),
  .v92a149(w38)
 );
 vd72027 v79330b (
  .v8e4159(w15),
  .v23125b(w19),
  .ve6fa88(w20),
  .v9e41c3(w29)
 );
 vd72027 vf1da33 (
  .v8e4159(w14),
  .v23125b(w18),
  .ve6fa88(w21),
  .v9e41c3(w31)
 );
 vd72027 v1ac4cf (
  .v8e4159(w13),
  .v23125b(w17),
  .ve6fa88(w25),
  .v9e41c3(w32)
 );
 vd72027 v45980d (
  .v8e4159(w12),
  .v23125b(w16),
  .ve6fa88(w24),
  .v9e41c3(w34)
 );
endmodule

//---------------------------------------------------
//-- digitos-4
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Controlador para display SPI de 4 digitos modelo COM-1129 de SparkFun
//---------------------------------------------------
//---- Top entity
module v5ad97e #(
 parameter vc5c8ea = 0
) (
 output [7:0] v26dbdb
);
 localparam p0 = vc5c8ea;
 wire [0:7] w1;
 assign v26dbdb = w1;
 v5ad97e_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- Constante-8bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor genérico constante, de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0
//---------------------------------------------------

module v5ad97e_v465065 #(
 parameter VALUE = 0
) (
 output [7:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module v76e9bf (
 input [7:0] v71c62f,
 input [7:0] va541fd,
 input [7:0] v9b8a50,
 input [7:0] v30db33,
 input [7:0] vbdd51f,
 input [7:0] v21e136,
 input [7:0] v062092,
 input [7:0] v3d1227,
 input [2:0] v97d40b,
 output [7:0] v3fb88b
);
 wire [0:7] w0;
 wire [0:7] w1;
 wire [0:2] w2;
 wire [0:7] w3;
 wire [0:7] w4;
 wire [0:7] w5;
 wire [0:7] w6;
 wire [0:7] w7;
 wire [0:7] w8;
 wire [0:7] w9;
 assign v3fb88b = w0;
 assign w1 = v062092;
 assign w2 = v97d40b;
 assign w3 = v3d1227;
 assign w4 = v21e136;
 assign w5 = vbdd51f;
 assign w6 = v30db33;
 assign w7 = v71c62f;
 assign w8 = va541fd;
 assign w9 = v9b8a50;
 v76e9bf_ve4e0df ve4e0df (
  .o(w0),
  .i1(w1),
  .s(w2),
  .i0(w3),
  .i2(w4),
  .i3(w5),
  .i4(w6),
  .i7(w7),
  .i6(w8),
  .i5(w9)
 );
endmodule

//---------------------------------------------------
//-- Mux 8 a 1 de 8 bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Multiplexor de 8 a 1 de 8 bits
//---------------------------------------------------

module v76e9bf_ve4e0df (
 input [7:0] i7,
 input [7:0] i6,
 input [7:0] i5,
 input [7:0] i4,
 input [7:0] i3,
 input [7:0] i2,
 input [7:0] i1,
 input [7:0] i0,
 input [2:0] s,
 output [7:0] o
);
 //-- Multiplexor de 8 a 1, 
 //-- de 8 bits
 
 assign o = (s == 3'h0) ? i0 :
            (s == 3'h1) ? i1 :
            (s == 3'h2) ? i2 : 
            (s == 3'h3) ? i3 :
            (s == 3'h4) ? i4 :
            (s == 3'h5) ? i5 :
            (s == 3'h6) ? i6 :
            (s == 3'h7) ? i7 : 
            3'h0;
            
 
 
endmodule
//---- Top entity
module v917222 (
 input [3:0] v285646,
 input [3:0] v766044,
 output [7:0] va191ad
);
 wire [0:3] w0;
 wire [0:3] w1;
 wire [0:7] w2;
 assign w0 = v766044;
 assign w1 = v285646;
 assign va191ad = w2;
 v917222_v9a2a06 v9a2a06 (
  .i0(w0),
  .i1(w1),
  .o(w2)
 );
endmodule

//---------------------------------------------------
//-- Agregador-bus
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Agregador de 2 buses de 4-bits a bus de 8-bits
//---------------------------------------------------

module v917222_v9a2a06 (
 input [3:0] i1,
 input [3:0] i0,
 output [7:0] o
);
 assign o = {i1, i0};
 
endmodule
//---- Top entity
module va0b8df #(
 parameter vfffc23 = 0
) (
 output [3:0] va50a91
);
 localparam p0 = vfffc23;
 wire [0:3] w1;
 assign va50a91 = w1;
 v9274d3 #(
  .vc5c8ea(p0)
 ) v8800c6 (
  .v00a92d(w1)
 );
endmodule

//---------------------------------------------------
//-- Valor_0_4bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor constante 0 para bus de 4 bits
//---------------------------------------------------
//---- Top entity
module v9274d3 #(
 parameter vc5c8ea = 0
) (
 output [3:0] v00a92d
);
 localparam p1 = vc5c8ea;
 wire [0:3] w0;
 assign v00a92d = w0;
 v9274d3_v465065 #(
  .VALUE(p1)
 ) v465065 (
  .k(w0)
 );
endmodule

//---------------------------------------------------
//-- Constante-4bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor genérico constante, de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0
//---------------------------------------------------

module v9274d3_v465065 #(
 parameter VALUE = 0
) (
 output [3:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module v07facf #(
 parameter vc20cea = 1,
 parameter vdb812c = 1
) (
 input v9c4682,
 input v234035,
 input [7:0] vdae213,
 input vab2972,
 output v97d6b9,
 output v0b8191,
 output v66de83,
 output [7:0] v735089,
 output vd56c7f,
 output vd03772
);
 localparam p1 = vdb812c;
 localparam p15 = vc20cea;
 wire w0;
 wire [0:7] w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire [0:7] w12;
 wire w13;
 wire [0:7] w14;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 assign v66de83 = w0;
 assign v735089 = w2;
 assign w3 = vab2972;
 assign vd03772 = w4;
 assign vd56c7f = w5;
 assign w6 = v9c4682;
 assign w9 = v9c4682;
 assign w10 = v234035;
 assign w12 = vdae213;
 assign v97d6b9 = w13;
 assign w16 = v9c4682;
 assign w17 = v9c4682;
 assign w18 = v9c4682;
 assign w19 = v9c4682;
 assign w20 = v9c4682;
 assign v0b8191 = w22;
 assign w23 = vab2972;
 assign w24 = vab2972;
 assign w9 = w6;
 assign w16 = w6;
 assign w16 = w9;
 assign w17 = w6;
 assign w17 = w9;
 assign w17 = w16;
 assign w18 = w6;
 assign w18 = w9;
 assign w18 = w16;
 assign w18 = w17;
 assign w19 = w6;
 assign w19 = w9;
 assign w19 = w16;
 assign w19 = w17;
 assign w19 = w18;
 assign w20 = w6;
 assign w20 = w9;
 assign w20 = w16;
 assign w20 = w17;
 assign w20 = w18;
 assign w20 = w19;
 assign w23 = w3;
 assign w24 = w3;
 assign w24 = w23;
 assign w27 = w26;
 assign w28 = w26;
 assign w28 = w27;
 v21cfcc v8f020a (
  .v9fb85f(w8)
 );
 v58ed2b v97c59c (
  .ve8318d(w4),
  .va4102a(w20),
  .vf54559(w28)
 );
 vef2764 #(
  .v573b2a(p1)
 ) v2408dd (
  .v4642b6(w0),
  .v6dda25(w18),
  .v92a149(w24),
  .v27dec4(w27)
 );
 vaaa99e v1399d2 (
  .v27dec4(w7),
  .vcd5251(w8),
  .ve4a668(w9),
  .v4642b6(w11),
  .vd793aa(w21)
 );
 v0705a6 v24bc5f (
  .v717e81(w6),
  .v3c12b5(w7),
  .ve7f5e6(w10)
 );
 v8d6618 v61e6ec (
  .ve6fa88(w2),
  .v8e4159(w14),
  .v9e41c3(w17),
  .v23125b(w26)
 );
 vda3384 va4e38c (
  .vff2be1(w11),
  .vd21667(w12),
  .v677807(w13),
  .v4db459(w14),
  .v6dda25(w16),
  .v9e7459(w23),
  .v1624bf(w25)
 );
 vf12fd8 #(
  .v684e9b(p15)
 ) vedba67 (
  .v8567d2(w3),
  .vf2804a(w5),
  .ve91b66(w19),
  .v2b4e0e(w21),
  .v38596d(w22),
  .v0fe16d(w25),
  .v432f8e(w26)
 );
endmodule

//---------------------------------------------------
//-- spi-master
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- SPI master. Realiza una transacción
//---------------------------------------------------
//---- Top entity
module v21cfcc (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v21cfcc_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

//---------------------------------------------------
//-- 0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Un bit constante a 0
//---------------------------------------------------

module v21cfcc_vb2eccd (
 output q
);
 //-- Bit constante a 0
 assign q = 1'b0;
 
 
endmodule
//---- Top entity
module v58ed2b #(
 parameter v71e305 = 0
) (
 input va4102a,
 input vf54559,
 output va58c5b,
 output ve8318d
);
 localparam p2 = v71e305;
 wire w0;
 wire w1;
 wire w3;
 assign w0 = va4102a;
 assign ve8318d = w1;
 assign w3 = vf54559;
 v58ed2b_vb8adf8 #(
  .INI(p2)
 ) vb8adf8 (
  .clk(w0),
  .q(w1),
  .d(w3)
 );
endmodule

//---------------------------------------------------
//-- sys-DFF-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- System - D Flip-flop. Capture data every system clock cycle. Verilog implementation
//---------------------------------------------------

module v58ed2b_vb8adf8 #(
 parameter INI = 0
) (
 input clk,
 input d,
 output q
);
 //-- Initial value
 reg qi = INI;
 
 //-- Capture the input data  
 //-- on the rising edge of  
 //-- the system clock
 always @(posedge clk)
   qi <= d;
   
 //-- Connect the register with the
 //-- output
 assign q = qi;
endmodule
//---- Top entity
module vef2764 #(
 parameter v573b2a = 0
) (
 input v6dda25,
 input v27dec4,
 input v92a149,
 output v4642b6
);
 localparam p3 = v573b2a;
 wire w0;
 wire w1;
 wire w2;
 wire w4;
 assign w0 = v27dec4;
 assign w1 = v92a149;
 assign w2 = v6dda25;
 assign v4642b6 = w4;
 vef2764_v56c60e #(
  .INI(p3)
 ) v56c60e (
  .set(w0),
  .reset(w1),
  .clk(w2),
  .q(w4)
 );
endmodule

//---------------------------------------------------
//-- RS-FF-set-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- RS-FF-set-verilog. RS Flip-flop with priority set. Implementation in verilog
//---------------------------------------------------

module vef2764_v56c60e #(
 parameter INI = 0
) (
 input clk,
 input set,
 input reset,
 output q
);
 //-- Initial value
 reg qi = INI;
 
 always @(posedge clk)
 begin
 
   //-- Priority on set
   //-- It is first checked
   if (set == 1'b1) 
     qi <= 1'b1;
     
   //-- Second: check reset
   else if (reset == 1'b1)
     qi <= 1'b0;
     
   //-- In any other case the FF
   //-- remains in its current 
   //-- state (no change)
 end
 
 //-- Connect the register with the
 //-- output
 assign q = qi;
 
endmodule
//---- Top entity
module vaaa99e #(
 parameter v5462c0 = 0
) (
 input ve4a668,
 input vcd5251,
 input v27dec4,
 input vd793aa,
 output vfe2b86,
 output v13c7f2,
 output v4642b6,
 output v785874
);
 localparam p1 = v5462c0;
 wire w0;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign v4642b6 = w0;
 assign w2 = ve4a668;
 assign w3 = vcd5251;
 assign w4 = v27dec4;
 assign w5 = vd793aa;
 vaaa99e_vf7e02c #(
  .INI(p1)
 ) vf7e02c (
  .q(w0),
  .clk(w2),
  .rst(w3),
  .d(w4),
  .load(w5)
 );
endmodule

//---------------------------------------------------
//-- DFF-rst-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- DFF-rst. D Flip-Flop with load and reset. Implemented in verilog
//---------------------------------------------------

module vaaa99e_vf7e02c #(
 parameter INI = 0
) (
 input clk,
 input rst,
 input d,
 input load,
 output q
);
 //-- Initial value
 reg qi = INI;
 
 always @(posedge clk)
 begin
  
  //-- Priority for rst
  if (rst == 1'b1)
    qi <=INI;
    
  //-- Load input data
  else if (load == 1'b1)
    qi <= d;
  
 end
 
 //-- Connect the register with the
 //-- output
 assign q = qi;
 
endmodule
//---- Top entity
module v0705a6 (
 input v717e81,
 input ve7f5e6,
 output v994965,
 output v3c12b5
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v717e81;
 assign w1 = ve7f5e6;
 assign v3c12b5 = w2;
 v0705a6_ve03af9 ve03af9 (
  .clk(w0),
  .d(w1),
  .q(w2)
 );
endmodule

//---------------------------------------------------
//-- Sync-x01-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Sync-x01: 1-bit input with the system clock domain (Verilog implementation)
//---------------------------------------------------

module v0705a6_ve03af9 (
 input clk,
 input d,
 output q
);
 //-- Two D flip-flops
 //-- connected in cascade
 
 reg q1 = 0;
 reg q2 = 0;
 
 always @(posedge clk) 
 begin
   //-- First D Flip-Flop
   q1 <= d;
   
   //-- Secondo D Flip-flop
   q2 <= q1;
 end
 
 //-- Assign the output
 assign q = q2;
endmodule
//---- Top entity
module v8d6618 #(
 parameter v438624 = 0
) (
 input v9e41c3,
 input [7:0] v8e4159,
 input v23125b,
 output [7:0] ve6fa88
);
 localparam p0 = v438624;
 wire w1;
 wire w2;
 wire [0:7] w3;
 wire [0:7] w4;
 assign w1 = v9e41c3;
 assign w2 = v23125b;
 assign w3 = v8e4159;
 assign ve6fa88 = w4;
 v8d6618_vd976a7 #(
  .INI(p0)
 ) vd976a7 (
  .clk(w1),
  .load(w2),
  .d(w3),
  .q(w4)
 );
endmodule

//---------------------------------------------------
//-- 08-Reg
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 08-Reg: 8 bits Register. Verilog implementation
//---------------------------------------------------

module v8d6618_vd976a7 #(
 parameter INI = 0
) (
 input clk,
 input [7:0] d,
 input load,
 output [7:0] q
);
 //-- Generic register
 //-- Number of bits
 localparam N = 8;
 
 //-- Initial value
 reg [N-1:0] qi = INI;
 
 always @(posedge clk)
 
   //-- The value is load only if  
   //-- load is 1
   if (load == 1'b1)
     qi <= d;
   
 //-- Connect the register with the
 //-- output
 assign q = qi;
endmodule
//---- Top entity
module vda3384 #(
 parameter v4636b4 = 0
) (
 input v6dda25,
 input vff2be1,
 input [7:0] vd21667,
 input v9e7459,
 input v1624bf,
 output va90362,
 output v677807,
 output [7:0] v4db459,
 output v5edb51,
 output v4d234c
);
 localparam p2 = v4636b4;
 wire w0;
 wire w1;
 wire [0:7] w3;
 wire w4;
 wire w5;
 wire w6;
 wire [0:7] w7;
 assign w0 = v6dda25;
 assign w1 = vff2be1;
 assign v4db459 = w3;
 assign v677807 = w4;
 assign w5 = v1624bf;
 assign w6 = v9e7459;
 assign w7 = vd21667;
 vda3384_vd6f051 #(
  .INI(p2)
 ) vd6f051 (
  .clk(w0),
  .sin(w1),
  .q(w3),
  .sout(w4),
  .shift(w5),
  .load(w6),
  .din(w7)
 );
endmodule

//---------------------------------------------------
//-- 08-SL-ld
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 08-SL-ld: 8 bits shift left register with load. Verilog implementation
//---------------------------------------------------

module vda3384_vd6f051 #(
 parameter INI = 0
) (
 input clk,
 input sin,
 input [7:0] din,
 input load,
 input shift,
 output sout,
 output [7:0] q
);
 //-- Generic Shift Left register
 //-- With reset input
 //-- Number of bits
 localparam N = 8;
 
 //-- Initial value
 reg [N-1:0] qi = INI;
 
 always @(posedge clk)
 begin
 
   //-- Load
   if (load == 1)
     qi <= din[7:0];
     
   else
     //-- Shift to the right when the
     //-- shift iput is 1
     if (shift == 1)
 
       //-- Shift to the left
       qi <= {qi[N-2:0], sin};
 end
 
 //-- Serial out: 
 //-- It is the most significant bit
 assign sout = qi[N-1];
 
 //-- Paralell out
 assign q = qi;
endmodule
//---- Top entity
module vf12fd8 #(
 parameter v7b40c5 = 16,
 parameter v684e9b = 1
) (
 input ve91b66,
 input v8567d2,
 output vf2804a,
 output v38596d,
 output v2b4e0e,
 output v0fe16d,
 output v432f8e
);
 localparam p2 = v7b40c5;
 localparam p3 = v684e9b;
 wire w0;
 wire w1;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 assign v38596d = w0;
 assign v432f8e = w7;
 assign w8 = v8567d2;
 assign vf2804a = w11;
 assign v0fe16d = w14;
 assign v2b4e0e = w15;
 assign w16 = ve91b66;
 assign w17 = ve91b66;
 assign w18 = ve91b66;
 assign w19 = ve91b66;
 assign w20 = ve91b66;
 assign w21 = ve91b66;
 assign w22 = ve91b66;
 assign w23 = ve91b66;
 assign w1 = w0;
 assign w12 = w5;
 assign w13 = w0;
 assign w13 = w1;
 assign w17 = w16;
 assign w18 = w16;
 assign w18 = w17;
 assign w19 = w16;
 assign w19 = w17;
 assign w19 = w18;
 assign w20 = w16;
 assign w20 = w17;
 assign w20 = w18;
 assign w20 = w19;
 assign w21 = w16;
 assign w21 = w17;
 assign w21 = w18;
 assign w21 = w19;
 assign w21 = w20;
 assign w22 = w16;
 assign w22 = w17;
 assign w22 = w18;
 assign w22 = w19;
 assign w22 = w20;
 assign w22 = w21;
 assign w23 = w16;
 assign w23 = w17;
 assign w23 = w18;
 assign w23 = w19;
 assign w23 = w20;
 assign w23 = w21;
 assign w23 = w22;
 vb05aa7 #(
  .v9152e7(p3)
 ) vc04a45 (
  .v207fd0(w4),
  .va9e2af(w5),
  .v5688a8(w21)
 );
 vb7f713 v2d7428 (
  .v4642b6(w0),
  .vb5e8cd(w12),
  .v6dda25(w17)
 );
 v58ed2b v301d66 (
  .vf54559(w6),
  .ve8318d(w7),
  .va4102a(w23)
 );
 v58ed2b vdc2d30 (
  .vf54559(w8),
  .ve8318d(w9),
  .va4102a(w18)
 );
 v58ed2b ve0b3ea (
  .vf54559(w10),
  .ve8318d(w11),
  .va4102a(w16)
 );
 vae13be v73dcd3 (
  .ve78ab8(w1),
  .v3487af(w15),
  .ved8395(w19)
 );
 v3ae3bb vb7231e (
  .ve78ab8(w13),
  .v3487af(w14),
  .ved8395(w22)
 );
 vd1a4f5 #(
  .vaceb8f(p2)
 ) v3c84bd (
  .v69602e(w4),
  .v87e8cb(w5),
  .v8314fa(w6),
  .vbdbcb4(w9),
  .v680136(w10),
  .v192615(w20)
 );
endmodule

//---------------------------------------------------
//-- SPI-heart-2Mhz-div
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Señal de reloj de 8 pulsos, a 2MHZ / DIV (con divisor) 
//---------------------------------------------------
//---- Top entity
module vb05aa7 #(
 parameter v9152e7 = 1
) (
 input v5688a8,
 input v207fd0,
 output veabfb2,
 output va9e2af
);
 localparam p4 = v9152e7;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign veabfb2 = w0;
 assign va9e2af = w1;
 assign w2 = v5688a8;
 assign w3 = v207fd0;
 vb05aa7_v8b4ac8 #(
  .DIV(p4)
 ) v8b4ac8 (
  .p(w0),
  .tic(w1),
  .clk(w2),
  .start(w3)
 );
endmodule

//---------------------------------------------------
//-- timer-system-spi
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Temporizador en tics. La señal p está activa durante los tics indicados. ov se emite un tic al finalizar
//---------------------------------------------------

module vb05aa7_v8b4ac8 #(
 parameter DIV = 0
) (
 input clk,
 input start,
 output p,
 output tic
);
 //--------------------------------------------
 //-- Contador de tics
 //--------------------------------------------
 
 //-- Bloque timer-system especifico para usar
 //-- con el SPI. Se combina en serie con una
 //-- maquina de contar, de forma que con DIV=1
 //-- se produce una señal de reloj de 2Mhz
 //-- DIV=2  ---> 1Mhz
 //-- DIV=4 ----> 500Khz
 //-- DIV=5 ----> 250Khz
 
 //-- Añadido con respecto al timer-system normal
 localparam TICS = 3 * DIV -1;
 
 //-- Calcular el numero de bits para almacenar US tics
 localparam CB = $clog2(TICS);
 
 reg [CB-1:0] counter = 0;
 
 //-- Overflow del contador
 wire ov;
 
 //-- Señal de reset del contador
 wire rst;
 
 always @(posedge clk)
   if (rst)
     counter <= 0;
   else
     counter <= counter + 1;
       
 //-- Comprobar overflow
 assign ov = (counter == TICS-1);
     
 //---------------------------------------
 //-- Biestable de estado del timer
 //-- 0: Apagado  
 //-- 1: Funcionando
 reg q = 0;
 
 always @(posedge clk)
   if (start)
     q <= 1'b1;
   else if (rst)
     q<=1'b0;
     
 //-- Lógica de reset
 //En función de la entrada, el estado y  
 // el overflow se inicializa el contador y 
 // se habilita el corazón de tics
 assign rst = ~q | ov | start;
 
 //-- Salida de pulso
 assign p = q;
 
 //-- Salida de tic
 //-- Saca un tic cuando ha finalizado la cuenta
 assign tic = ov;
     
 
endmodule
//---- Top entity
module vb7f713 #(
 parameter v8bcde4 = 0
) (
 input v6dda25,
 input vb5e8cd,
 output v4642b6
);
 localparam p0 = v8bcde4;
 wire w1;
 wire w2;
 wire w3;
 assign w1 = v6dda25;
 assign w2 = vb5e8cd;
 assign v4642b6 = w3;
 vb7f713_v4a32dd #(
  .INI(p0)
 ) v4a32dd (
  .clk(w1),
  .t(w2),
  .q(w3)
 );
endmodule

//---------------------------------------------------
//-- TFF-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- TFF-verilog. System TFF with toggle input: It toogles on every system cycle if the input is active. Verilog implementation
//---------------------------------------------------

module vb7f713_v4a32dd #(
 parameter INI = 0
) (
 input clk,
 input t,
 output q
);
 //-- Initial value
 reg qi = INI;
 
 always @(posedge clk)
 begin
  
  //-- check the toogle input
  if (t == 1'b1)
    qi <= ~ qi;
  
 end
 
 //-- Connect the register with the
 //-- output
 assign q = qi;
 
endmodule
//---- Top entity
module vae13be (
 input ved8395,
 input ve78ab8,
 output v1c9ba2,
 output v3487af
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign w0 = ve78ab8;
 assign w1 = ved8395;
 assign w4 = ve78ab8;
 assign v3487af = w5;
 assign w4 = w0;
 v3676a0 v9d4cda (
  .v0e28cb(w2),
  .vcbab45(w3)
 );
 vba518e v57aa83 (
  .v0e28cb(w3),
  .v3ca442(w4),
  .vcbab45(w5)
 );
 v58ed2b v4953b3 (
  .vf54559(w0),
  .va4102a(w1),
  .ve8318d(w2)
 );
endmodule

//---------------------------------------------------
//-- Rising-edge-detector
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Rising-edge detector. It generates a 1-period pulse (tic) when a rising edge is detected on the input. Block implementation
//---------------------------------------------------
//---- Top entity
module v3676a0 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v3676a0_vd54ca1 vd54ca1 (
  .a(w0),
  .q(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- NOT gate (Verilog implementation)
//---------------------------------------------------

module v3676a0_vd54ca1 (
 input a,
 output q
);
 //-- NOT Gate
 assign q = ~a;
 
 
endmodule
//---- Top entity
module vba518e (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vba518e_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Two bits input And gate
//---------------------------------------------------

module vba518e_vf4938a (
 input a,
 input b,
 output c
);
 //-- AND gate
 //-- Verilog implementation
 
 assign c = a & b;
 
endmodule
//---- Top entity
module v3ae3bb (
 input ved8395,
 input ve78ab8,
 output v76dfe9,
 output v3487af
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign w0 = ve78ab8;
 assign w1 = ved8395;
 assign v3487af = w2;
 assign w3 = ve78ab8;
 assign w3 = w0;
 vba518e v6bfca1 (
  .vcbab45(w2),
  .v0e28cb(w4),
  .v3ca442(w5)
 );
 v3676a0 v84ca43 (
  .v0e28cb(w3),
  .vcbab45(w5)
 );
 v58ed2b vc2c6cf (
  .vf54559(w0),
  .va4102a(w1),
  .ve8318d(w4)
 );
endmodule

//---------------------------------------------------
//-- Falling-edge-detector CLONE
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Falling-edge detector. It generates a 1-period pulse (tic) when a falling edge is detected on the input
//---------------------------------------------------
//---- Top entity
module vd1a4f5 #(
 parameter vaceb8f = 8,
 parameter vc633fb = 1,
 parameter vd99aad = 0
) (
 input v192615,
 input vbdbcb4,
 input v87e8cb,
 output v680136,
 output [3:0] ve7048f,
 output v69602e,
 output v8314fa
);
 localparam p0 = vd99aad;
 localparam p1 = vc633fb;
 localparam p6 = vaceb8f;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w7;
 wire w8;
 wire [0:3] w9;
 wire [0:3] w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire [0:3] w18;
 wire [0:3] w19;
 wire [0:3] w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 assign w7 = vbdbcb4;
 assign w8 = v87e8cb;
 assign w11 = v192615;
 assign w12 = v192615;
 assign w13 = v192615;
 assign v680136 = w14;
 assign ve7048f = w19;
 assign v8314fa = w25;
 assign v69602e = w26;
 assign w12 = w11;
 assign w13 = w11;
 assign w13 = w12;
 assign w15 = w14;
 assign w16 = w14;
 assign w16 = w15;
 assign w19 = w18;
 assign w20 = w18;
 assign w20 = w19;
 assign w23 = w5;
 assign w24 = w5;
 assign w24 = w23;
 vb2090f v91590d (
  .vcbab45(w5),
  .v3ca442(w8),
  .v0e28cb(w16)
 );
 vb2090f vffa799 (
  .v3ca442(w2),
  .v0e28cb(w5),
  .vcbab45(w22)
 );
 vb2090f v234ec4 (
  .vcbab45(w3),
  .v3ca442(w4),
  .v0e28cb(w15)
 );
 v816138 v1cb7f5 (
  .v0e28cb(w3),
  .v3ca442(w21),
  .vcbab45(w26)
 );
 v04dced #(
  .v8d305c(p1)
 ) ve73b5c (
  .vbfafa4(w10),
  .v56adce(w18)
 );
 v2e6917 v95f509 (
  .v18e78c(w2),
  .v7b3e89(w9),
  .v6c4cc1(w20)
 );
 v33e7c0 #(
  .vc5c8ea(p6)
 ) v065438 (
  .vfc34be(w9)
 );
 v58ed2b vec7a64 (
  .ve8318d(w4),
  .va4102a(w13),
  .vf54559(w24)
 );
 v3c296a #(
  .v4800df(p0)
 ) vd0f700 (
  .v9406e4(w10),
  .v6dda25(w11),
  .va5013b(w17),
  .v4db459(w18),
  .v23125b(w23)
 );
 vaec21d vf48149 (
  .v143ae2(w7),
  .v68780b(w12),
  .v078fce(w14),
  .v3525a9(w17),
  .vf2d070(w21),
  .vb414d8(w22),
  .vd82121(w25)
 );
endmodule

//---------------------------------------------------
//-- count-4bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Máquina de contar, de 4 bits
//---------------------------------------------------
//---- Top entity
module v816138 (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 v816138_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- OR
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta OR
//---------------------------------------------------

module v816138_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta OR
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a | b;
 
 //-- endmodule
endmodule
//---- Top entity
module v04dced #(
 parameter v8d305c = 1
) (
 input [3:0] v56adce,
 output [3:0] vbfafa4
);
 localparam p0 = v8d305c;
 wire [0:3] w1;
 wire [0:3] w2;
 assign w1 = v56adce;
 assign vbfafa4 = w2;
 v04dced_va0c26a #(
  .k(p0)
 ) va0c26a (
  .a(w1),
  .s(w2)
 );
endmodule

//---------------------------------------------------
//-- sum-1op-4bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Sumador de un operando de 4 bits con una constante pasada como parámetro (No hay accarreo)
//---------------------------------------------------

module v04dced_va0c26a #(
 parameter k = 0
) (
 input [3:0] a,
 output [3:0] s
);
 assign s = a + k;
endmodule
//---- Top entity
module v2e6917 (
 input [3:0] v7b3e89,
 input [3:0] v6c4cc1,
 output v18e78c
);
 wire w0;
 wire [0:3] w1;
 wire [0:3] w2;
 assign v18e78c = w0;
 assign w1 = v6c4cc1;
 assign w2 = v7b3e89;
 v2e6917_vd75681 vd75681 (
  .eq(w0),
  .b(w1),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador de dos operandos
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de dos operandos de 4 bits
//---------------------------------------------------

module v2e6917_vd75681 (
 input [3:0] a,
 input [3:0] b,
 output eq
);
 assign eq = (a == b);
endmodule
//---- Top entity
module v33e7c0 #(
 parameter vc5c8ea = 1
) (
 output [3:0] vfc34be
);
 localparam p0 = vc5c8ea;
 wire [0:3] w1;
 assign vfc34be = w1;
 v33e7c0_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- Constante-4bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor genérico constante (menos 1), de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0
//---------------------------------------------------

module v33e7c0_v465065 #(
 parameter VALUE = 0
) (
 output [3:0] k
);
 assign k = VALUE-1;
endmodule
//---- Top entity
module v3c296a #(
 parameter v4800df = 0
) (
 input v6dda25,
 input va5013b,
 input [3:0] v9406e4,
 input v23125b,
 output ve74064,
 output v0c9980,
 output [3:0] v4db459,
 output v8c0d77
);
 localparam p0 = v4800df;
 wire [0:3] w1;
 wire w2;
 wire [0:3] w3;
 wire w4;
 wire w5;
 assign v4db459 = w1;
 assign w2 = v6dda25;
 assign w3 = v9406e4;
 assign w4 = va5013b;
 assign w5 = v23125b;
 v3c296a_vb9285f #(
  .INI(p0)
 ) vb9285f (
  .q(w1),
  .clk(w2),
  .d(w3),
  .rst(w4),
  .load(w5)
 );
endmodule

//---------------------------------------------------
//-- 04-Reg-rst
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 04-Reg-rst: 4 bits Register with reset. Verilog implementation
//---------------------------------------------------

module v3c296a_vb9285f #(
 parameter INI = 0
) (
 input clk,
 input rst,
 input [3:0] d,
 input load,
 output [3:0] q
);
 //-- Generic register with reset
 //-- Number of bits
 localparam N = 4;
 
 //-- Initial value
 reg [N-1:0] qi = INI;
 
 always @(posedge clk)
 begin
 
   //-- Reset has the priority
   if (rst == 1'b1)
     qi <= INI;
     
   else
     //-- The value is load only if  
     //-- load is 1
     if (load == 1'b1)
       qi <= d;
       
   //-- In any other case the reg
   //-- keeps its value
 end
 
 //-- Connect the register with the
 //-- output
 assign q = qi;
 
endmodule
//---- Top entity
module vaec21d (
 input v68780b,
 input v143ae2,
 input vb414d8,
 output v078fce,
 output v3525a9,
 output vf2d070,
 output vd82121
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 assign v078fce = w1;
 assign v3525a9 = w3;
 assign w4 = v143ae2;
 assign w5 = vb414d8;
 assign vf2d070 = w6;
 assign vd82121 = w8;
 assign w9 = v68780b;
 assign w10 = v68780b;
 assign w11 = v68780b;
 assign w1 = w0;
 assign w2 = w0;
 assign w2 = w1;
 assign w7 = w0;
 assign w7 = w1;
 assign w7 = w2;
 assign w10 = w9;
 assign w11 = w9;
 assign w11 = w10;
 v35f267 v719db6 (
  .v0e28cb(w2),
  .vcbab45(w3)
 );
 vef2764 vf3a8f7 (
  .v4642b6(w0),
  .v27dec4(w4),
  .v92a149(w5),
  .v6dda25(w9)
 );
 vae13be v896900 (
  .ve78ab8(w0),
  .v3487af(w6),
  .ved8395(w10)
 );
 v3ae3bb vee821f (
  .ve78ab8(w7),
  .v3487af(w8),
  .ved8395(w11)
 );
endmodule

//---------------------------------------------------
//-- Machine-state
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Biestable de almacenamiento del estado de la máquina
//---------------------------------------------------
//---- Top entity
module vd42255 #(
 parameter vaceb8f = 8,
 parameter vc633fb = 1,
 parameter vd99aad = 0
) (
 input v192615,
 input vbdbcb4,
 input v87e8cb,
 output v680136,
 output [2:0] v8b9e30,
 output v69602e,
 output v8314fa
);
 localparam p0 = vd99aad;
 localparam p1 = vc633fb;
 localparam p6 = vaceb8f;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w7;
 wire w8;
 wire [0:2] w9;
 wire [0:2] w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire [0:2] w18;
 wire [0:2] w19;
 wire [0:2] w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 assign w7 = vbdbcb4;
 assign w8 = v87e8cb;
 assign w11 = v192615;
 assign w12 = v192615;
 assign w13 = v192615;
 assign v680136 = w14;
 assign v8b9e30 = w19;
 assign v8314fa = w25;
 assign v69602e = w26;
 assign w12 = w11;
 assign w13 = w11;
 assign w13 = w12;
 assign w15 = w14;
 assign w16 = w14;
 assign w16 = w15;
 assign w19 = w18;
 assign w20 = w18;
 assign w20 = w19;
 assign w23 = w5;
 assign w24 = w5;
 assign w24 = w23;
 vb2090f v91590d (
  .vcbab45(w5),
  .v3ca442(w8),
  .v0e28cb(w16)
 );
 vb2090f vffa799 (
  .v3ca442(w2),
  .v0e28cb(w5),
  .vcbab45(w22)
 );
 vb2090f v234ec4 (
  .vcbab45(w3),
  .v3ca442(w4),
  .v0e28cb(w15)
 );
 v816138 v1cb7f5 (
  .v0e28cb(w3),
  .v3ca442(w21),
  .vcbab45(w26)
 );
 vb40da6 v8f26c8 (
  .v18e78c(w2),
  .v2e7398(w9),
  .v2af1cd(w20)
 );
 ve81274 #(
  .vc5c8ea(p6)
 ) v03d8cb (
  .v95ded6(w9)
 );
 v46aa41 #(
  .v8d305c(p1)
 ) v44f396 (
  .v6f3450(w10),
  .vba2ef8(w18)
 );
 vaec21d vb4cbbf (
  .v143ae2(w7),
  .v68780b(w12),
  .v078fce(w14),
  .v3525a9(w17),
  .vf2d070(w21),
  .vb414d8(w22),
  .vd82121(w25)
 );
 v94f5ce #(
  .v4800df(p0)
 ) vbedb28 (
  .v9406e4(w10),
  .v6dda25(w11),
  .va5013b(w17),
  .v4db459(w18),
  .v23125b(w23)
 );
 v58ed2b vfc9f0b (
  .ve8318d(w4),
  .va4102a(w13),
  .vf54559(w24)
 );
endmodule

//---------------------------------------------------
//-- count-04-3bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Máquina de contar, de 2 bits (cuenta hasta 4 ciclos)
//---------------------------------------------------
//---- Top entity
module vb40da6 (
 input [2:0] v2e7398,
 input [2:0] v2af1cd,
 output v18e78c
);
 wire w0;
 wire [0:2] w1;
 wire [0:2] w2;
 assign v18e78c = w0;
 assign w1 = v2af1cd;
 assign w2 = v2e7398;
 vb40da6_vd75681 vd75681 (
  .eq(w0),
  .b(w1),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador de dos operandos
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de dos operandos de 3 bits
//---------------------------------------------------

module vb40da6_vd75681 (
 input [2:0] a,
 input [2:0] b,
 output eq
);
 assign eq = (a == b);
endmodule
//---- Top entity
module ve81274 #(
 parameter vc5c8ea = 1
) (
 output [2:0] v95ded6
);
 localparam p0 = vc5c8ea;
 wire [0:2] w1;
 assign v95ded6 = w1;
 ve81274_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- Constante-3bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor genérico constante (menos 1), de 3 bits. Su valor se introduce como parámetro. Por defecto vale 0
//---------------------------------------------------

module ve81274_v465065 #(
 parameter VALUE = 0
) (
 output [2:0] k
);
 assign k = VALUE-1;
endmodule
//---- Top entity
module v46aa41 #(
 parameter v8d305c = 1
) (
 input [2:0] vba2ef8,
 output [2:0] v6f3450
);
 localparam p0 = v8d305c;
 wire [0:2] w1;
 wire [0:2] w2;
 assign w1 = vba2ef8;
 assign v6f3450 = w2;
 v46aa41_va0c26a #(
  .k(p0)
 ) va0c26a (
  .a(w1),
  .s(w2)
 );
endmodule

//---------------------------------------------------
//-- sum-1op-3bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Sumador de un operando de 3 bits con una constante pasada como parámetro (No hay accarreo)
//---------------------------------------------------

module v46aa41_va0c26a #(
 parameter k = 0
) (
 input [2:0] a,
 output [2:0] s
);
 assign s = a + k;
endmodule
//---- Top entity
module v94f5ce #(
 parameter v4800df = 0
) (
 input v6dda25,
 input va5013b,
 input [2:0] v9406e4,
 input v23125b,
 output ve74064,
 output v0c9980,
 output [2:0] v4db459,
 output v8c0d77
);
 localparam p0 = v4800df;
 wire [0:2] w1;
 wire w2;
 wire [0:2] w3;
 wire w4;
 wire w5;
 assign v4db459 = w1;
 assign w2 = v6dda25;
 assign w3 = v9406e4;
 assign w4 = va5013b;
 assign w5 = v23125b;
 v94f5ce_vb9285f #(
  .INI(p0)
 ) vb9285f (
  .q(w1),
  .clk(w2),
  .d(w3),
  .rst(w4),
  .load(w5)
 );
endmodule

//---------------------------------------------------
//-- 03-Reg-rst
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 03-Reg-rst: 3 bits Register with reset. Verilog implementation
//---------------------------------------------------

module v94f5ce_vb9285f #(
 parameter INI = 0
) (
 input clk,
 input rst,
 input [2:0] d,
 input load,
 output [2:0] q
);
 //-- Generic register with reset
 //-- Number of bits
 localparam N = 3;
 
 //-- Initial value
 reg [N-1:0] qi = INI;
 
 always @(posedge clk)
 begin
 
   //-- Reset has the priority
   if (rst == 1'b1)
     qi <= INI;
     
   else
     //-- The value is load only if  
     //-- load is 1
     if (load == 1'b1)
       qi <= d;
       
   //-- In any other case the reg
   //-- keeps its value
 end
 
 //-- Connect the register with the
 //-- output
 assign q = qi;
 
endmodule
//---- Top entity
module vd72027 #(
 parameter v438624 = 0
) (
 input v9e41c3,
 input [3:0] v8e4159,
 input v23125b,
 output [3:0] ve6fa88
);
 localparam p0 = v438624;
 wire w1;
 wire w2;
 wire [0:3] w3;
 wire [0:3] w4;
 assign w1 = v9e41c3;
 assign w2 = v23125b;
 assign w3 = v8e4159;
 assign ve6fa88 = w4;
 vd72027_vd976a7 #(
  .INI(p0)
 ) vd976a7 (
  .clk(w1),
  .load(w2),
  .d(w3),
  .q(w4)
 );
endmodule

//---------------------------------------------------
//-- 04-Reg
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 04-Reg: 4 bits Register. Verilog implementation
//---------------------------------------------------

module vd72027_vd976a7 #(
 parameter INI = 0
) (
 input clk,
 input [3:0] d,
 input load,
 output [3:0] q
);
 //-- Generic register
 //-- Number of bits
 localparam N = 4;
 
 //-- Initial value
 reg [N-1:0] qi = INI;
 
 always @(posedge clk)
 
   //-- The value is load only if  
   //-- load is 1
   if (load == 1'b1)
     qi <= d;
   
 //-- Connect the register with the
 //-- output
 assign q = qi;
endmodule
//---- Top entity
module v6c0c4a #(
 parameter vf2d743 = 'h03000000
) (
 input v1002e2,
 input v8fadcd,
 input [31:0] vd5de6b,
 input [31:0] v6d05a9,
 input [3:0] va57c44,
 output [7:0] v9d3deb,
 output vb21f3c,
 output v980561
);
 localparam p4 = vf2d743;
 wire [0:7] w0;
 wire [0:7] w1;
 wire w2;
 wire w3;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:3] w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire [0:31] w15;
 wire [0:31] w16;
 wire w17;
 assign v9d3deb = w0;
 assign vb21f3c = w9;
 assign w10 = va57c44;
 assign v980561 = w11;
 assign w12 = v1002e2;
 assign w13 = v1002e2;
 assign w14 = v8fadcd;
 assign w15 = vd5de6b;
 assign w16 = v6d05a9;
 assign w6 = w5;
 assign w7 = w5;
 assign w7 = w6;
 assign w11 = w2;
 assign w13 = w12;
 v6f058b va3b7f3 (
  .vd65308(w1),
  .v2ebc76(w16)
 );
 vb2090f v42ed31 (
  .vcbab45(w2),
  .v3ca442(w5),
  .v0e28cb(w17)
 );
 vb2090f v023908 (
  .v0e28cb(w3),
  .v3ca442(w7),
  .vcbab45(w9)
 );
 vf9bdaf #(
  .v6b316b(p4)
 ) v671bed (
  .v18e78c(w8),
  .ve1f562(w15)
 );
 vb2090f v076142 (
  .vcbab45(w5),
  .v0e28cb(w8),
  .v3ca442(w14)
 );
 v45c913 v8e2000 (
  .v930b03(w10),
  .v593f43(w17)
 );
 v8d6618 v2244d8 (
  .ve6fa88(w0),
  .v8e4159(w1),
  .v23125b(w2),
  .v9e41c3(w12)
 );
 v58ed2b v54a510 (
  .ve8318d(w3),
  .vf54559(w6),
  .va4102a(w13)
 );
endmodule

//---------------------------------------------------
//-- IO
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerto de salida
//---------------------------------------------------
//---- Top entity
module v6f058b (
 input [31:0] v2ebc76,
 output [7:0] v4a41db,
 output [7:0] v0d81e4,
 output [7:0] v6b375c,
 output [7:0] vd65308
);
 wire [0:31] w0;
 wire [0:7] w1;
 wire [0:7] w2;
 wire [0:7] w3;
 wire [0:7] w4;
 assign w0 = v2ebc76;
 assign vd65308 = w1;
 assign v6b375c = w2;
 assign v0d81e4 = w3;
 assign v4a41db = w4;
 v6f058b_v9a2a06 v9a2a06 (
  .i(w0),
  .o0(w1),
  .o1(w2),
  .o2(w3),
  .o3(w4)
 );
endmodule

//---------------------------------------------------
//-- Separador-bus
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 32-bits en 4 buses de 8 bits
//---------------------------------------------------

module v6f058b_v9a2a06 (
 input [31:0] i,
 output [7:0] o3,
 output [7:0] o2,
 output [7:0] o1,
 output [7:0] o0
);
 assign o3 = i[31:24];
 assign o2 = i[23:16];
 assign o1 = i[15:8];
 assign o0 = i[7:0];
endmodule
//---- Top entity
module v5242e2 (
 input [31:0] v917e97,
 input [31:0] v5664d9,
 input [31:0] v918400,
 input [31:0] vae8a69,
 input vec88a9,
 input v76f74e,
 input ve3469f,
 input v58d02d,
 output [31:0] v493538
);
 wire [0:1] w0;
 wire w1;
 wire [0:31] w2;
 wire [0:31] w3;
 wire [0:31] w4;
 wire [0:31] w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:31] w10;
 wire [0:31] w11;
 wire [0:31] w12;
 assign w2 = v917e97;
 assign w3 = v5664d9;
 assign w4 = v918400;
 assign w5 = vae8a69;
 assign w6 = vec88a9;
 assign w7 = v76f74e;
 assign w8 = v58d02d;
 assign w9 = ve3469f;
 assign v493538 = w10;
 v6835fc ve38aa0 (
  .ved33bc(w0),
  .v2828a2(w2),
  .v86e1b9(w3),
  .v010aaa(w4),
  .v930664(w5),
  .v242732(w11)
 );
 veecece vfd598f (
  .vfd29cc(w0),
  .v5a4b06(w1),
  .v78af34(w6),
  .v78ff37(w7),
  .v44b9b7(w8),
  .v259301(w9)
 );
 vad96c0 v4b1d09 (
  .ve50a7b(w1),
  .v9960f4(w10),
  .v231daa(w11),
  .v95bea5(w12)
 );
 v2c97f6 vde5edd (
  .v7c9bd8(w12)
 );
endmodule

//---------------------------------------------------
//-- Bus-4
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bus de 32 bits de 4 canales
//---------------------------------------------------
//---- Top entity
module v6835fc (
 input [31:0] v2828a2,
 input [31:0] v86e1b9,
 input [31:0] v010aaa,
 input [31:0] v930664,
 input [1:0] ved33bc,
 output [31:0] v242732
);
 wire [0:31] w0;
 wire [0:31] w1;
 wire [0:31] w2;
 wire [0:31] w3;
 wire [0:31] w4;
 wire [0:1] w5;
 assign w0 = v2828a2;
 assign w1 = v86e1b9;
 assign w2 = v010aaa;
 assign w3 = v930664;
 assign v242732 = w4;
 assign w5 = ved33bc;
 v6835fc_ve4e0df ve4e0df (
  .i3(w0),
  .i2(w1),
  .i1(w2),
  .i0(w3),
  .o(w4),
  .s(w5)
 );
endmodule

//---------------------------------------------------
//-- Mux-4-1-32bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Multiplexor de 4 a 1 de 32 bits
//---------------------------------------------------

module v6835fc_ve4e0df (
 input [31:0] i3,
 input [31:0] i2,
 input [31:0] i1,
 input [31:0] i0,
 input [1:0] s,
 output [31:0] o
);
 //-- Multiplexor de 4 a 1, 
 //-- de 32 bits
 
 assign o = (s == 3'h0) ? i0 :
            (s == 3'h1) ? i1 :
            (s == 3'h2) ? i2 : 
            (s == 3'h3) ? i3 :
            32'h0;
            
 
 
endmodule
//---- Top entity
module veecece (
 input v78af34,
 input v78ff37,
 input v259301,
 input v44b9b7,
 output [1:0] vfd29cc,
 output v5a4b06
);
 wire [0:1] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign vfd29cc = w0;
 assign v5a4b06 = w1;
 assign w2 = v78af34;
 assign w3 = v78ff37;
 assign w4 = v259301;
 assign w5 = v44b9b7;
 veecece_v4407ca v4407ca (
  .y(w0),
  .zero(w1),
  .i3(w2),
  .i2(w3),
  .i1(w4),
  .i0(w5)
 );
endmodule

//---------------------------------------------------
//-- Codificador-4-2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Codificador de 4 a 2, con prioridad. La salida zero se activa cuando ninguna entrada está activad
//---------------------------------------------------

module veecece_v4407ca (
 input i3,
 input i2,
 input i1,
 input i0,
 output [1:0] y,
 output zero
);
 //-- Codificador de 4 a 1
 
 //-- Señalizar que todos son ceros
 assign zero = ({i3,i2,i1,i0}==4'b00);
 
 
 assign y = (i3 == 1) ? 2'h3 :
            (i2 == 1) ? 2'h2 :
            (i1 == 1) ? 2'h1 : 0;
           
 
endmodule
//---- Top entity
module vad96c0 (
 input [31:0] v95bea5,
 input [31:0] v231daa,
 input ve50a7b,
 output [31:0] v9960f4
);
 wire w0;
 wire [0:31] w1;
 wire [0:31] w2;
 wire [0:31] w3;
 assign w0 = ve50a7b;
 assign v9960f4 = w1;
 assign w2 = v231daa;
 assign w3 = v95bea5;
 vad96c0_v4d0636 v4d0636 (
  .sel(w0),
  .o(w1),
  .i0(w2),
  .i1(w3)
 );
endmodule

//---------------------------------------------------
//-- 32-bits-Mux-2-1-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 2-to-1 Multplexer (32-bit channels). Verilog implementation
//---------------------------------------------------

module vad96c0_v4d0636 (
 input [31:0] i1,
 input [31:0] i0,
 input sel,
 output [31:0] o
);
 //-- 2-to-1 Multiplexer 
 
 assign o = sel ? i1 : i0;
endmodule
//---- Top entity
module vaba674 #(
 parameter v6478b6 = 1024
) (
 input v04ad7a,
 input [3:0] vd728f0,
 input v22c516,
 input vd7d395,
 input [31:0] v387cca,
 input [31:0] v8d6432,
 output v69f1ab,
 output [31:0] v13ce3e
);
 localparam p2 = v6478b6;
 wire [0:21] w0;
 wire [0:23] w1;
 wire w3;
 wire [0:3] w4;
 wire w5;
 wire w6;
 wire w7;
 wire [0:31] w8;
 wire [0:31] w9;
 wire w10;
 wire w11;
 wire [0:3] w12;
 wire [0:31] w13;
 wire w14;
 wire [0:31] w15;
 wire w16;
 wire w17;
 assign w8 = v387cca;
 assign w9 = v387cca;
 assign w10 = v22c516;
 assign w11 = vd7d395;
 assign w12 = vd728f0;
 assign w13 = v8d6432;
 assign v69f1ab = w14;
 assign v13ce3e = w15;
 assign w16 = v04ad7a;
 assign w17 = v04ad7a;
 assign w5 = w3;
 assign w9 = w8;
 assign w17 = w16;
 vf0a7c1 v00b15c (
  .vd903fe(w1),
  .v2ebc76(w9)
 );
 v359d9b v2b0874 (
  .vc5ea70(w0),
  .v84d8ec(w1)
 );
 vf6999a vaf52fa (
  .v7b40f2(w3),
  .vfa6171(w6),
  .v76af38(w7),
  .v7cacc4(w11)
 );
 v127665 #(
  .v16d6b8(p2)
 ) v9d2eb0 (
  .v18e78c(w7),
  .v229966(w8)
 );
 v35f267 v19c0ab (
  .vcbab45(w6),
  .v0e28cb(w10)
 );
 v13d09a vc5282a (
  .ve2642f(w4),
  .v76af38(w5),
  .vd317b3(w12)
 );
 v58ed2b ve2ae4f (
  .vf54559(w3),
  .ve8318d(w14),
  .va4102a(w16)
 );
 v33720b v13b1f8 (
  .va79cbd(w0),
  .vc52d9a(w4),
  .v72eed5(w13),
  .v02f96f(w15),
  .vfa6941(w17)
 );
endmodule

//---------------------------------------------------
//-- RAM-1KB-soc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- RAM block (1KB) with logic
//---------------------------------------------------
//---- Top entity
module vf0a7c1 (
 input [31:0] v2ebc76,
 output [7:0] v87715f,
 output [23:0] vd903fe
);
 wire [0:31] w0;
 wire [0:23] w1;
 wire [0:7] w2;
 assign w0 = v2ebc76;
 assign vd903fe = w1;
 assign v87715f = w2;
 vf0a7c1_v9a2a06 v9a2a06 (
  .i(w0),
  .o0(w1),
  .o1(w2)
 );
endmodule

//---------------------------------------------------
//-- Separador-8-24
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 32-bits en buses de 8 y 24 bits
//---------------------------------------------------

module vf0a7c1_v9a2a06 (
 input [31:0] i,
 output [7:0] o1,
 output [23:0] o0
);
 assign o1 = i[31:24];
 assign o0 = i[23:0];
endmodule
//---- Top entity
module v359d9b (
 input [23:0] v84d8ec,
 output [21:0] vc5ea70,
 output [1:0] v47f12b
);
 wire [0:21] w0;
 wire [0:1] w1;
 wire [0:23] w2;
 assign vc5ea70 = w0;
 assign v47f12b = w1;
 assign w2 = v84d8ec;
 v359d9b_v9a2a06 v9a2a06 (
  .o1(w0),
  .o0(w1),
  .i(w2)
 );
endmodule

//---------------------------------------------------
//-- Separador-22-2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 24-bits en dos buses de 22 y 2 bits
//---------------------------------------------------

module v359d9b_v9a2a06 (
 input [23:0] i,
 output [21:0] o1,
 output [1:0] o0
);
 assign o1 = i[23:2];
 assign o0 = i[1:0];
endmodule
//---- Top entity
module vf6999a (
 input vfa6171,
 input v7cacc4,
 input v76af38,
 output v7b40f2
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign v7b40f2 = w1;
 assign w2 = vfa6171;
 assign w3 = v7cacc4;
 assign w4 = v76af38;
 vb2090f v85500b (
  .vcbab45(w0),
  .v0e28cb(w2),
  .v3ca442(w3)
 );
 vb2090f v241483 (
  .v0e28cb(w0),
  .vcbab45(w1),
  .v3ca442(w4)
 );
endmodule

//---------------------------------------------------
//-- AND3
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND de 3 entradas
//---------------------------------------------------
//---- Top entity
module v127665 #(
 parameter v16d6b8 = 1
) (
 input [31:0] v229966,
 output v18e78c
);
 localparam p1 = v16d6b8;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = v229966;
 v127665_vd75681 #(
  .B(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Menor-que-1-op
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador menor que, de un operando de 32 bits
//---------------------------------------------------

module v127665_vd75681 #(
 parameter B = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a < B);
endmodule
//---- Top entity
module v13d09a (
 input [3:0] vd317b3,
 input v76af38,
 output [3:0] ve2642f
);
 wire w0;
 wire [0:3] w1;
 wire [0:3] w2;
 assign w0 = v76af38;
 assign w1 = vd317b3;
 assign ve2642f = w2;
 v13d09a_vce9fab vce9fab (
  .b(w0),
  .a(w1),
  .o(w2)
 );
endmodule

//---------------------------------------------------
//-- AND-4-1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND de dos operandos, de 1 y 4 bits
//---------------------------------------------------

module v13d09a_vce9fab (
 input [3:0] a,
 input b,
 output [3:0] o
);
 assign o[3] = a[3] & b;
 assign o[2] = a[2] & b;
 assign o[1] = a[1] & b;
 assign o[0] = a[0] & b;
endmodule
//---- Top entity
module v33720b (
 input vfa6941,
 input [3:0] vc52d9a,
 input [21:0] va79cbd,
 input [31:0] v72eed5,
 output [31:0] v02f96f
);
 wire [0:3] w0;
 wire [0:21] w1;
 wire [0:31] w2;
 wire [0:31] w3;
 wire w4;
 assign w0 = vc52d9a;
 assign w1 = va79cbd;
 assign w2 = v72eed5;
 assign v02f96f = w3;
 assign w4 = vfa6941;
 v33720b_v0ae20e v0ae20e (
  .wen(w0),
  .addr(w1),
  .wdata(w2),
  .rdata(w3),
  .clk(w4)
 );
endmodule

//---------------------------------------------------
//-- RAM-1KB
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Memoria ram de 1KB (256x32bits)
//---------------------------------------------------

module v33720b_v0ae20e (
 input clk,
 input [3:0] wen,
 input [21:0] addr,
 input [31:0] wdata,
 output [31:0] rdata
);
 localparam integer WORDS = 256;
 
 reg [31:0] mem [0:WORDS-1];
 reg [31:0] rdata_i;
 assign rdata = rdata_i;
 
 	always @(posedge clk) begin
 		rdata_i <= mem[addr];
 		if (wen[0]) mem[addr][ 7: 0] <= wdata[ 7: 0];
 		if (wen[1]) mem[addr][15: 8] <= wdata[15: 8];
 		if (wen[2]) mem[addr][23:16] <= wdata[23:16];
 		if (wen[3]) mem[addr][31:24] <= wdata[31:24];
 	end
endmodule
//---- Top entity
module v2b4233 #(
 parameter v55b764 = 1
) (
 input v4c8225,
 output v6d0651
);
 localparam p1 = v55b764;
 wire w0;
 wire w2;
 wire [0:5] w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 assign v6d0651 = w5;
 assign w7 = v4c8225;
 assign w8 = v4c8225;
 assign w9 = v4c8225;
 assign w6 = w2;
 assign w8 = w7;
 assign w9 = w7;
 assign w9 = w8;
 v21cfcc v3023dc (
  .v9fb85f(w4)
 );
 v2814a1 vf701ed (
  .vc7a3dc(w2),
  .v1c1141(w3)
 );
 vef2764 #(
  .v573b2a(p1)
 ) v9d4f65 (
  .v4642b6(w0),
  .v27dec4(w4),
  .v92a149(w6),
  .v6dda25(w8)
 );
 v192520 v2efe33 (
  .v65c173(w0),
  .v15fb32(w3),
  .vdd729a(w9)
 );
 vae13be vb7abdc (
  .ve78ab8(w2),
  .v3487af(w5),
  .ved8395(w7)
 );
endmodule

//---------------------------------------------------
//-- Init-tic
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Emitir un tic inicial al arrancar, y nunca más. Se esperan 32 tics antes de emitir el tic de inicialización
//---------------------------------------------------
//---- Top entity
module v2814a1 (
 input [5:0] v1c1141,
 output vc7a3dc,
 output [4:0] vaa52cb
);
 wire [0:5] w0;
 wire [0:4] w1;
 wire w2;
 assign w0 = v1c1141;
 assign vaa52cb = w1;
 assign vc7a3dc = w2;
 v2814a1_v9a2a06 v9a2a06 (
  .i(w0),
  .o0(w1),
  .o1(w2)
 );
endmodule

//---------------------------------------------------
//-- Separador-bus-1-5
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 6-bits en 1 bit y bus de 5 bits
//---------------------------------------------------

module v2814a1_v9a2a06 (
 input [5:0] i,
 output o1,
 output [4:0] o0
);
 assign o1 = i[5];
 assign o0 = i[4:0];
 
endmodule
//---- Top entity
module v192520 (
 input vdd729a,
 input v65c173,
 output [5:0] v15fb32
);
 wire w0;
 wire [0:5] w1;
 wire w2;
 assign w0 = vdd729a;
 assign v15fb32 = w1;
 assign w2 = v65c173;
 v192520_ve444b7 ve444b7 (
  .clk(w0),
  .q(w1),
  .ena(w2)
 );
endmodule

//---------------------------------------------------
//-- Contador-6bits-up-system-ena
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Contador del sistema, ascendente, de 6 bits, con enable 
//---------------------------------------------------

module v192520_ve444b7 (
 input clk,
 input ena,
 output [5:0] q
);
 reg [5:0] q_i;
 assign q = q_i;
 
 always @(posedge clk)
 begin
   if (ena)
     q_i <= q_i + 1;
 end
endmodule
//---- Top entity
module v372366 #(
 parameter vbce3f7 = 1024,
 parameter v386fc7 = 'h0200_0000
) (
 input v84763f,
 input v17983a,
 input [31:0] vbee9aa,
 input vba8655,
 input v78b064,
 output vbe14dd,
 output [31:0] v202123,
 output v9b4033,
 output v0da91a,
 output v40049a
);
 localparam p0 = vbce3f7;
 localparam p1 = v386fc7;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire [0:23] w7;
 wire w8;
 wire w9;
 wire w10;
 wire [0:31] w11;
 wire w12;
 wire w13;
 wire [0:31] w14;
 wire [0:31] w15;
 wire [0:31] w16;
 wire w17;
 assign v40049a = w4;
 assign v0da91a = w5;
 assign v9b4033 = w6;
 assign w9 = v78b064;
 assign vbe14dd = w10;
 assign v202123 = w11;
 assign w12 = v84763f;
 assign w13 = v17983a;
 assign w14 = vbee9aa;
 assign w15 = vbee9aa;
 assign w16 = vbee9aa;
 assign w17 = vba8655;
 assign w15 = w14;
 assign w16 = w14;
 assign w16 = w15;
 vf0a7c1 v3c7e19 (
  .vd903fe(w7),
  .v2ebc76(w16)
 );
 v65879d #(
  .v16d6b8(p0)
 ) vba8cb0 (
  .v18e78c(w2),
  .v3d8056(w14)
 );
 v127665 #(
  .v16d6b8(p1)
 ) v3beedf (
  .v18e78c(w3),
  .v229966(w15)
 );
 vf6999a v1797a3 (
  .vfa6171(w2),
  .v7cacc4(w3),
  .v7b40f2(w8),
  .v76af38(w17)
 );
 va7f020 v285423 (
  .v8c9980(w4),
  .v8593fa(w5),
  .vf34c0c(w6),
  .v5d7746(w7),
  .v3d9a95(w8),
  .vad115e(w9),
  .v5f2c67(w10),
  .v1de298(w11),
  .vc1deab(w12),
  .v5b0577(w13)
 );
endmodule

//---------------------------------------------------
//-- Flash-soc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Memoria flash con lógica para su mapeo
//---------------------------------------------------
//---- Top entity
module v65879d #(
 parameter v16d6b8 = 1
) (
 input [31:0] v3d8056,
 output v18e78c
);
 localparam p1 = v16d6b8;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = v3d8056;
 v65879d_vd75681 #(
  .B(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Mayor-igual-que-1-op
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador mayor o igual que, de un operando de 32 bits
//---------------------------------------------------

module v65879d_vd75681 #(
 parameter B = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a >= B);
endmodule
//---- Top entity
module va7f020 (
 input vc1deab,
 input v5b0577,
 input v3d9a95,
 input [23:0] v5d7746,
 input vad115e,
 output v5f2c67,
 output [31:0] v1de298,
 output vf34c0c,
 output v8593fa,
 output v8c9980
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:3] w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire [0:31] w9;
 wire w10;
 wire [0:23] w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire [0:7] w22;
 wire [0:7] w23;
 wire w24;
 wire [0:3] w25;
 wire w26;
 wire [0:3] w27;
 wire w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 wire w33;
 wire w34;
 wire w35;
 wire w36;
 wire w37;
 wire w38;
 assign vf34c0c = w0;
 assign v8593fa = w1;
 assign w2 = vad115e;
 assign v8c9980 = w3;
 assign w5 = vc1deab;
 assign w6 = vc1deab;
 assign v5f2c67 = w7;
 assign w8 = v5b0577;
 assign v1de298 = w9;
 assign w10 = v3d9a95;
 assign w11 = v5d7746;
 assign w6 = w5;
 assign w17 = w16;
 assign w21 = w20;
 va7f020_v5dc4ea v5dc4ea (
  .flash_csb(w0),
  .flash_clk(w1),
  .cfgreg_we(w4),
  .clk(w5),
  .ready(w7),
  .resetn(w8),
  .rdata(w9),
  .valid(w10),
  .addr(w11),
  .din_ready(w12),
  .xfer_resetn(w13),
  .dout_valid(w14),
  .flash_io0_oe(w15),
  .flash_io0_di(w16),
  .din_valid(w18),
  .flash_io1_oe(w19),
  .flash_io1_di(w20),
  .dout_data(w22),
  .din_data(w23),
  .flash_io0_do(w24),
  .dout_tag(w25),
  .flash_io1_do(w26),
  .din_tag(w27),
  .xfer_csb(w28),
  .din_cont(w29),
  .xfer_dspi(w30),
  .xfer_clk(w31),
  .din_qspi(w32),
  .xfer_io0_oe(w33),
  .xfer_ddr(w34),
  .xfer_io1_oe(w35),
  .din_rd(w36),
  .xfer_io0_do(w37),
  .xfer_io1_do(w38)
 );
 va7f020_v216dc9 v216dc9 (
  .clk(w6),
  .din_ready(w12),
  .resetn(w13),
  .dout_valid(w14),
  .flash_io0_di(w17),
  .din_valid(w18),
  .flash_io1_di(w21),
  .dout_data(w22),
  .din_data(w23),
  .dout_tag(w25),
  .din_tag(w27),
  .flash_csb(w28),
  .din_cont(w29),
  .din_dspi(w30),
  .flash_clk(w31),
  .din_qspi(w32),
  .flash_io0_oe(w33),
  .din_ddr(w34),
  .flash_io1_oe(w35),
  .din_rd(w36),
  .flash_io0_do(w37),
  .flash_io1_do(w38)
 );
 vbb787c v23c4c4 (
  .v6b2a2c(w2),
  .v248807(w19),
  .v790e82(w20),
  .vba979e(w26)
 );
 vd7e6ff v64ca2e (
  .v341fc3(w3),
  .v248807(w15),
  .v790e82(w16),
  .vba979e(w24)
 );
 va0b8df v610d99 (
  .va50a91(w4)
 );
endmodule

//---------------------------------------------------
//-- spi-flash
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Acceso a la memoria flash spi
//---------------------------------------------------

module va7f020_v5dc4ea (
 input clk,
 input resetn,
 input valid,
 input [23:0] addr,
 input flash_io0_di,
 input flash_io1_di,
 input [3:0] cfgreg_we,
 input [31:0] cfgreg_di,
 input din_ready,
 input dout_valid,
 input [7:0] dout_data,
 input [3:0] dout_tag,
 input xfer_csb,
 input xfer_clk,
 input xfer_io0_oe,
 input xfer_io1_oe,
 input xfer_io0_do,
 input xfer_io1_do,
 output ready,
 output [31:0] rdata,
 output flash_csb,
 output flash_clk,
 output flash_io0_oe,
 output flash_io1_oe,
 output flash_io0_do,
 output flash_io1_do,
 output [31:0] cfgreg_do,
 output xfer_resetn,
 output din_valid,
 output [7:0] din_data,
 output [3:0] din_tag,
 output din_cont,
 output xfer_dspi,
 output din_qspi,
 output xfer_ddr,
 output din_rd
);
 reg [31:0] rdata_i;
 assign rdata = rdata_i;
 reg        xfer_resetn_i;
 assign xfer_resetn = xfer_resetn_i;
 	reg        din_valid_i;
     assign din_valid = din_valid_i;
 	reg  [7:0] din_data_i;
     assign din_data = din_data_i;
 	reg  [3:0] din_tag_i;
     assign din_tag = din_tag_i;
 	reg        din_cont_i;
     assign din_tag = din_tag_i;
 	reg        din_qspi_i;
     assign din_qspi = din_qspi_i;
 	reg        din_ddr;
 	reg        din_rd_i;
     assign din_rd = din_rd_i;
 
 wire       dout_valid_i;
 assign dout_valid = dout_valid_i;
 	wire [7:0] dout_data_i;
     assign dout_data = dout_data_i;
 	wire [3:0] dout_tag_i;
     assign dout_tag = dout_tag_i;
 
 	reg [23:0] buffer;
 
 	reg [23:0] rd_addr;
 	reg rd_valid;
 	reg rd_wait;
 	reg rd_inc;
 
 	assign ready = valid && (addr == rd_addr) && rd_valid;
 	wire jump = valid && !ready && (addr != rd_addr+4) && rd_valid;
 
 	reg softreset;
 
 	reg       config_en;      // cfgreg[31]
 	reg       config_ddr;     // cfgreg[22]
 	reg       config_qspi;    // cfgreg[21]
 	reg       config_cont;    // cfgreg[20]
 	reg [3:0] config_dummy;   // cfgreg[19:16]
 	reg [3:0] config_oe;      // cfgreg[11:8]
 	reg       config_csb;     // cfgreg[5]
 	reg       config_clk;     // cfgref[4]
 	reg [3:0] config_do;      // cfgreg[3:0]
 
 	assign cfgreg_do[31] = config_en;
 	assign cfgreg_do[30:23] = 0;
 	assign cfgreg_do[22] = config_ddr;
 	assign cfgreg_do[21] = config_qspi;
 	assign cfgreg_do[20] = config_cont;
 	assign cfgreg_do[19:16] = config_dummy;
 	assign cfgreg_do[15:12] = 0;
 	assign cfgreg_do[11:8] = {1'b0, 1'b0, flash_io1_oe, flash_io0_oe};
 	assign cfgreg_do[7:6] = 0;
 	assign cfgreg_do[5] = flash_csb;
 	assign cfgreg_do[4] = flash_clk;
 	assign cfgreg_do[3:0] = {1'b0, 1'b0, flash_io1_di, flash_io0_di};
 
 	always @(posedge clk) begin
 		softreset <= !config_en || cfgreg_we;
 		if (!resetn) begin
 			softreset <= 1;
 			config_en <= 1;
 			config_csb <= 0;
 			config_clk <= 0;
 			config_oe <= 0;
 			config_do <= 0;
 			config_ddr <= 0;
 			config_qspi <= 0;
 			config_cont <= 0;
 			config_dummy <= 8;
 		end else begin
 			if (cfgreg_we[0]) begin
 				config_csb <= cfgreg_di[5];
 				config_clk <= cfgreg_di[4];
 				config_do <= cfgreg_di[3:0];
 			end
 			if (cfgreg_we[1]) begin
 				config_oe <= cfgreg_di[11:8];
 			end
 			if (cfgreg_we[2]) begin
 				config_ddr <= cfgreg_di[22];
 				config_qspi <= cfgreg_di[21];
 				config_cont <= cfgreg_di[20];
 				config_dummy <= cfgreg_di[19:16];
 			end
 			if (cfgreg_we[3]) begin
 				config_en <= cfgreg_di[31];
 			end
 		end
 	end
 
 	
 	wire xfer_io2_oe;
 	wire xfer_io3_oe;
 
 	
 	wire xfer_io2_do;
 	wire xfer_io3_do;
 
 	reg xfer_io0_90;
 	reg xfer_io1_90;
 	reg xfer_io2_90;
 	reg xfer_io3_90;
 
 	always @(negedge clk) begin
 		xfer_io0_90 <= xfer_io0_do;
 		xfer_io1_90 <= xfer_io1_do;
 		xfer_io2_90 <= xfer_io2_do;
 		xfer_io3_90 <= xfer_io3_do;
 	end
 
 	assign flash_csb = config_en ? xfer_csb : config_csb;
 	assign flash_clk = config_en ? xfer_clk : config_clk;
 
 	assign flash_io0_oe = config_en ? xfer_io0_oe : config_oe[0];
 	assign flash_io1_oe = config_en ? xfer_io1_oe : config_oe[1];
 	//assign flash_io2_oe = config_en ? xfer_io2_oe : config_oe[2];
 	//assign flash_io3_oe = config_en ? xfer_io3_oe : config_oe[3];
 
 	assign flash_io0_do = config_en ? (config_ddr ? xfer_io0_90 : xfer_io0_do) : config_do[0];
 	assign flash_io1_do = config_en ? (config_ddr ? xfer_io1_90 : xfer_io1_do) : config_do[1];
 	//assign flash_io2_do = config_en ? (config_ddr ? xfer_io2_90 : xfer_io2_do) : config_do[2];
 	//assign flash_io3_do = config_en ? (config_ddr ? xfer_io3_90 : xfer_io3_do) : config_do[3];
 
 	wire xfer_dspi_i = din_ddr && !din_qspi_i;
     assign xfer_dspi = xfer_dspi_i;
 	wire xfer_ddr_i = din_ddr && din_qspi_i;
     assign xfer_ddr = xfer_ddr_i;
 
 	reg [3:0] state;
 
 	always @(posedge clk) begin
 		xfer_resetn_i <= 1;
 		din_valid_i <= 0;
 
 		if (!resetn || softreset) begin
 			state <= 0;
 			xfer_resetn_i <= 0;
 			rd_valid <= 0;
 			din_tag_i <= 0;
 			din_cont_i <= 0;
 			din_qspi_i <= 0;
 			din_ddr <= 0;
 			din_rd_i <= 0;
 		end else begin
 			if (dout_valid_i && dout_tag_i == 1) buffer[ 7: 0] <= dout_data_i;
 			if (dout_valid_i && dout_tag_i == 2) buffer[15: 8] <= dout_data_i;
 			if (dout_valid_i && dout_tag_i == 3) buffer[23:16] <= dout_data_i;
 			if (dout_valid_i && dout_tag_i == 4) begin
 				rdata_i <= {dout_data_i, buffer};
 				rd_addr <= rd_inc ? rd_addr + 4 : addr;
 				rd_valid <= 1;
 				rd_wait <= rd_inc;
 				rd_inc <= 1;
 			end
 
 			if (valid)
 				rd_wait <= 0;
 
 			case (state)
 				0: begin
 					din_valid_i <= 1;
 					din_data_i <= 8'h ff;
 					din_tag_i <= 0;
 					if (din_ready) begin
 						din_valid_i <= 0;
 						state <= 1;
 					end
 				end
 				1: begin
 					if (dout_valid_i) begin
 						xfer_resetn_i <= 0;
 						state <= 2;
 					end
 				end
 				2: begin
 					din_valid_i <= 1;
 					din_data_i <= 8'h ab;
 					din_tag_i <= 0;
 					if (din_ready) begin
 						din_valid_i <= 0;
 						state <= 3;
 					end
 				end
 				3: begin
 					if (dout_valid_i) begin
 						xfer_resetn_i <= 0;
 						state <= 4;
 					end
 				end
 				4: begin
 					rd_inc <= 0;
 					din_valid_i <= 1;
 					din_tag_i <= 0;
 					case ({config_ddr, config_qspi})
 						2'b11: din_data_i <= 8'h ED;
 						2'b01: din_data_i <= 8'h EB;
 						2'b10: din_data_i <= 8'h BB;
 						2'b00: din_data_i <= 8'h 03;
 					endcase
 					if (din_ready) begin
 						din_valid_i <= 0;
 						state <= 5;
 					end
 				end
 				5: begin
 					if (valid && !ready) begin
 						din_valid_i <= 1;
 						din_tag_i <= 0;
 						din_data_i <= addr[23:16];
 						din_qspi_i <= config_qspi;
 						din_ddr <= config_ddr;
 						if (din_ready) begin
 							din_valid_i <= 0;
 							state <= 6;
 						end
 					end
 				end
 				6: begin
 					din_valid_i <= 1;
 					din_tag_i <= 0;
 					din_data_i <= addr[15:8];
 					if (din_ready) begin
 						din_valid_i <= 0;
 						state <= 7;
 					end
 				end
 				7: begin
 					din_valid_i <= 1;
 					din_tag_i <= 0;
 					din_data_i <= addr[7:0];
 					if (din_ready) begin
 						din_valid_i <= 0;
 						din_data_i <= 0;
 						state <= config_qspi || config_ddr ? 8 : 9;
 					end
 				end
 				8: begin
 					din_valid_i <= 1;
 					din_tag_i <= 0;
 					din_data_i <= config_cont ? 8'h A5 : 8'h FF;
 					if (din_ready) begin
 						din_rd_i <= 1;
 						din_data_i <= config_dummy;
 						din_valid_i <= 0;
 						state <= 9;
 					end
 				end
 				9: begin
 					din_valid_i <= 1;
 					din_tag_i <= 1;
 					if (din_ready) begin
 						din_valid_i <= 0;
 						state <= 10;
 					end
 				end
 				10: begin
 					din_valid_i <= 1;
 					din_data_i <= 8'h 00;
 					din_tag_i <= 2;
 					if (din_ready) begin
 						din_valid_i <= 0;
 						state <= 11;
 					end
 				end
 				11: begin
 					din_valid_i <= 1;
 					din_tag_i <= 3;
 					if (din_ready) begin
 						din_valid_i <= 0;
 						state <= 12;
 					end
 				end
 				12: begin
 					if (!rd_wait || valid) begin
 						din_valid_i <= 1;
 						din_tag_i <= 4;
 						if (din_ready) begin
 							din_valid_i <= 0;
 							state <= 9;
 						end
 					end
 				end
 			endcase
 
 			if (jump) begin
 				rd_inc <= 0;
 				rd_valid <= 0;
 				xfer_resetn_i <= 0;
 				if (config_cont) begin
 					state <= 5;
 				end else begin
 					state <= 4;
 					din_qspi_i <= 0;
 					din_ddr <= 0;
 				end
 				din_rd_i <= 0;
 			end
 		end
 	end
endmodule

module va7f020_v216dc9 (
 input clk,
 input resetn,
 input din_valid,
 input [7:0] din_data,
 input [3:0] din_tag,
 input din_cont,
 input din_dspi,
 input din_qspi,
 input din_ddr,
 input din_rd,
 input flash_io0_di,
 input flash_io1_di,
 output din_ready,
 output dout_valid,
 output [7:0] dout_data,
 output [3:0] dout_tag,
 output flash_csb,
 output flash_clk,
 output flash_io0_oe,
 output flash_io1_oe,
 output flash_io0_do,
 output flash_io1_do
);
 reg [7:0] obuffer;
 	reg [7:0] ibuffer;
 
 	reg [3:0] count;
 	reg [3:0] dummy_count;
 
 	reg xfer_cont;
 	reg xfer_dspi;
 	reg xfer_qspi;
 	reg xfer_ddr;
 	reg xfer_ddr_q;
 	reg xfer_rd;
 	reg [3:0] xfer_tag;
 	reg [3:0] xfer_tag_q;
 
 	reg [7:0] next_obuffer;
 	reg [7:0] next_ibuffer;
 	reg [3:0] next_count;
 
 	reg fetch;
 	reg next_fetch;
 	reg last_fetch;
 	
 	
 	reg flash_csb_i;
     assign flash_csb = flash_csb_i;
 	reg flash_clk_i;
     assign flash_clk = flash_clk_i;
 
 	reg flash_io0_oe_i;
     assign flash_io0_oe = flash_io0_oe_i;
 	reg flash_io1_oe_i;
     assign flash_io1_oe = flash_io1_oe_i;
 	
 
 	reg flash_io0_do_i;
     assign flash_io0_do = flash_io0_do_i;
 	reg flash_io1_do_i;
     assign flash_io1_do = flash_io1_do_i;
 	
 
 	always @(posedge clk) begin
 		xfer_ddr_q <= xfer_ddr;
 		xfer_tag_q <= xfer_tag;
 	end
 
 	assign din_ready = din_valid && resetn && next_fetch;
 
 	assign dout_valid = (xfer_ddr_q ? fetch && !last_fetch : next_fetch && !fetch) && resetn;
 	assign dout_data = ibuffer;
 	assign dout_tag = xfer_tag_q;
 
 	always @* begin
 		flash_io0_oe_i = 0;
 		flash_io1_oe_i = 0;
 		//flash_io2_oe = 0;
 		//flash_io3_oe = 0;
 
 		flash_io0_do_i = 0;
 		flash_io1_do_i = 0;
 		//flash_io2_do = 0;
 		//flash_io3_do = 0;
 
 		next_obuffer = obuffer;
 		next_ibuffer = ibuffer;
 		next_count = count;
 		next_fetch = 0;
 
 		if (dummy_count == 0) begin
 			casez ({xfer_ddr, xfer_qspi, xfer_dspi})
 				3'b 000: begin
 					flash_io0_oe_i = 1;
 					flash_io0_do_i = obuffer[7];
 
 					if (flash_clk_i) begin
 						next_obuffer = {obuffer[6:0], 1'b 0};
 						next_count = count - |count;
 					end else begin
 						next_ibuffer = {ibuffer[6:0], flash_io1_di};
 					end
 
 					next_fetch = (next_count == 0);
 				end
 				3'b 01?: begin
 					flash_io0_oe_i = !xfer_rd;
 					flash_io1_oe_i = !xfer_rd;
 					//flash_io2_oe = !xfer_rd;
 					//flash_io3_oe = !xfer_rd;
 
 					flash_io0_do_i = obuffer[4];
 					flash_io1_do_i = obuffer[5];
 					//flash_io2_do = obuffer[6];
 					//flash_io3_do = obuffer[7];
 
 					if (flash_clk_i) begin
 						next_obuffer = {obuffer[3:0], 4'b 0000};
 						next_count = count - {|count, 2'b00};
 					end else begin
 						next_ibuffer = {ibuffer[3:0], 1'b0, 1'b0, flash_io1_di, flash_io0_di};
 					end
 
 					next_fetch = (next_count == 0);
 				end
 				3'b 11?: begin
 					flash_io0_oe_i = !xfer_rd;
 					flash_io1_oe_i = !xfer_rd;
 					//flash_io2_oe = !xfer_rd;
 					//flash_io3_oe = !xfer_rd;
 
 					flash_io0_do_i = obuffer[4];
 					flash_io1_do_i = obuffer[5];
 					//flash_io2_do = obuffer[6];
 					//flash_io3_do = obuffer[7];
 
 					next_obuffer = {obuffer[3:0], 4'b 0000};
 					next_ibuffer = {ibuffer[3:0], 1'b0, 1'b0, flash_io1_di, flash_io0_di};
 					next_count = count - {|count, 2'b00};
 
 					next_fetch = (next_count == 0);
 				end
 				3'b ??1: begin
 					flash_io0_oe_i = !xfer_rd;
 					flash_io1_oe_i = !xfer_rd;
 
 					flash_io0_do_i = obuffer[6];
 					flash_io1_do_i = obuffer[7];
 
 					if (flash_clk_i) begin
 						next_obuffer = {obuffer[5:0], 2'b 00};
 						next_count = count - {|count, 1'b0};
 					end else begin
 						next_ibuffer = {ibuffer[5:0], flash_io1_di, flash_io0_di};
 					end
 
 					next_fetch = (next_count == 0);
 				end
 			endcase
 		end
 	end
 
 	always @(posedge clk) begin
 		if (!resetn) begin
 			fetch <= 1;
 			last_fetch <= 1;
 			flash_csb_i <= 1;
 			flash_clk_i <= 0;
 			count <= 0;
 			dummy_count <= 0;
 			xfer_tag <= 0;
 			xfer_cont <= 0;
 			xfer_dspi <= 0;
 			xfer_qspi <= 0;
 			xfer_ddr <= 0;
 			xfer_rd <= 0;
 		end else begin
 			fetch <= next_fetch;
 			last_fetch <= xfer_ddr ? fetch : 1;
 			if (dummy_count) begin
 				flash_clk_i <= !flash_clk_i && !flash_csb_i;
 				dummy_count <= dummy_count - flash_clk_i;
 			end else
 			if (count) begin
 				flash_clk_i <= !flash_clk_i && !flash_csb_i;
 				obuffer <= next_obuffer;
 				ibuffer <= next_ibuffer;
 				count <= next_count;
 			end
 			if (din_valid && din_ready) begin
 				flash_csb_i <= 0;
 				flash_clk_i <= 0;
 
 				count <= 8;
 				dummy_count <= din_rd ? din_data : 0;
 				obuffer <= din_data;
 
 				xfer_tag <= din_tag;
 				xfer_cont <= din_cont;
 				xfer_dspi <= din_dspi;
 				xfer_qspi <= din_qspi;
 				xfer_ddr <= din_ddr;
 				xfer_rd <= din_rd;
 			end
 		end
 	end
endmodule
//---- Top entity
module vbb787c (
 input v6b2a2c,
 input v248807,
 input vba979e,
 output v790e82
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v6b2a2c;
 assign w1 = v248807;
 assign w2 = vba979e;
 assign v790e82 = w3;
 vbb787c_v43ad2d v43ad2d (
  .pin(w0),
  .oe(w1),
  .dout(w2),
  .din(w3)
 );
endmodule

//---------------------------------------------------
//-- InOut
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bloque para entrada-salida (PIO)
//---------------------------------------------------

module vbb787c_v43ad2d (
 input pin,
 input oe,
 input dout,
 output din
);
   SB_IO #(
       .PIN_TYPE(6'b1010_01),
       .PULLUP(1'b0)
   ) triState (
       .PACKAGE_PIN(pin),
       .OUTPUT_ENABLE(oe),
       .D_OUT_0(dout),
       .D_IN_0(din)
   );
endmodule
//---- Top entity
module vd7e6ff (
 input v248807,
 input vba979e,
 output v341fc3,
 output v790e82
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v248807;
 assign w1 = vba979e;
 assign v790e82 = w2;
 assign v341fc3 = w3;
 vd7e6ff_v43ad2d v43ad2d (
  .oe(w0),
  .dout(w1),
  .din(w2),
  .pin(w3)
 );
endmodule

//---------------------------------------------------
//-- In-out-right
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bloque inout, con conexión de pin por la derecha
//---------------------------------------------------

module vd7e6ff_v43ad2d (
 input oe,
 input dout,
 output pin,
 output din
);
   SB_IO #(
       .PIN_TYPE(6'b1010_01),
       .PULLUP(1'b0)
   ) triState (
       .PACKAGE_PIN(pin),
       .OUTPUT_ENABLE(oe),
       .D_OUT_0(dout),
       .D_IN_0(din)
   );
endmodule
//---- Top entity
module v9e3734 #(
 parameter v31c48c = 'h
) (
 input v537510,
 input v6f1ced,
 input v44b3fa,
 input [31:0] v775e34,
 input v87d16b,
 input [31:0] v976ab6,
 input [3:0] v516c98,
 output [31:0] v235119,
 output vc84d54
);
 localparam p0 = v31c48c;
 wire w1;
 wire [0:3] w2;
 wire [0:31] w3;
 wire w4;
 wire [0:31] w5;
 assign w2 = v516c98;
 assign w3 = v775e34;
 assign w4 = v87d16b;
 assign w5 = v976ab6;
 v34c176 v6d294a (
 
 );
 va702c4 vb925c4 (
 
 );
 vea7a9f v0f62ec (
 
 );
 v9c4264 v740a02 (
 
 );
 vfe216f v3acde2 (
 
 );
 v484ba7 v47523b (
 
 );
 v85bf11 vab548e (
 
 );
 vf9bdaf #(
  .v6b316b(p0)
 ) v9b369f (
  .v18e78c(w1),
  .ve1f562(w3)
 );
 vb2090f v2b8390 (
  .v0e28cb(w1),
  .v3ca442(w4)
 );
 v45c913 v4e1401 (
  .v930b03(w2)
 );
 v9e3734_v020df3 v020df3 (
  .BusData(w5)
 );
endmodule


module v9e3734_v020df3 (
 input [31:0] BusData,
 output [3:0] adc_mode,
 output [6:0] adc_addr,
 output adc_RW,
 output [6:0] adc_toWritte
);
 wire [31:0] BusData;      // Entrada de 32 bits
 
 wire [6:0]  adc_addr;        
 wire        adc_RW;          
 wire [3:0]  adc_mode;        
 wire [6:0]  adc_write;      
 
 // Asignación
 assign adc_addr  = BusData[6:0];
 assign adc_RW    = BusData[7];
 assign adc_mode  = BusData[11:8];
 assign adc_write = BusData[18:12];
 
endmodule
//---- Top entity
module v34c176 #(
 parameter vb77f40 = 100000,
 parameter v63ca69 = 39
) (
 input v1f3320,
 input [7:0] v45c009,
 input v03da85,
 output v852a01,
 output v1c4983,
 output v06d8fb
);
 localparam p1 = v63ca69;
 localparam p9 = vb77f40;
 wire [0:7] w0;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire [0:1] w16;
 wire w17;
 wire [0:4] w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 wire w33;
 wire w34;
 wire w35;
 wire w36;
 wire w37;
 wire w38;
 wire w39;
 wire w40;
 wire w41;
 wire w42;
 wire w43;
 assign w0 = v45c009;
 assign w2 = v03da85;
 assign w11 = v03da85;
 assign v852a01 = w21;
 assign v1c4983 = w23;
 assign w24 = v03da85;
 assign v06d8fb = w25;
 assign w27 = v1f3320;
 assign w28 = v1f3320;
 assign w29 = v1f3320;
 assign w30 = v1f3320;
 assign w31 = v1f3320;
 assign w32 = v1f3320;
 assign w33 = v1f3320;
 assign w34 = v1f3320;
 assign w8 = w6;
 assign w10 = w6;
 assign w10 = w8;
 assign w11 = w2;
 assign w14 = w13;
 assign w17 = w7;
 assign w24 = w2;
 assign w24 = w11;
 assign w28 = w27;
 assign w29 = w27;
 assign w29 = w28;
 assign w30 = w27;
 assign w30 = w28;
 assign w30 = w29;
 assign w31 = w27;
 assign w31 = w28;
 assign w31 = w29;
 assign w31 = w30;
 assign w32 = w27;
 assign w32 = w28;
 assign w32 = w29;
 assign w32 = w30;
 assign w32 = w31;
 assign w33 = w27;
 assign w33 = w28;
 assign w33 = w29;
 assign w33 = w30;
 assign w33 = w31;
 assign w33 = w32;
 assign w34 = w27;
 assign w34 = w28;
 assign w34 = w29;
 assign w34 = w30;
 assign w34 = w31;
 assign w34 = w32;
 assign w34 = w33;
 assign w35 = w15;
 assign w36 = w15;
 assign w36 = w35;
 assign w38 = w37;
 assign w40 = w39;
 assign w41 = w25;
 assign w42 = w25;
 assign w42 = w41;
 assign w43 = w25;
 assign w43 = w41;
 assign w43 = w42;
 v28cfaa ve26255 (
  .v381ebf(w4),
  .v7e70ae(w5),
  .vb186da(w7),
  .vd7f8af(w17),
  .vc93bbe(w20),
  .vc13c07(w37),
  .v9b870f(w39)
 );
 v725b7e v87bce2 (
  .v9fb85f(w4)
 );
 vfc9dac v332cf4 (
  .v8b19dd(w16),
  .v3f8943(w37),
  .v64d863(w39)
 );
 v28cfaa v5e43a2 (
  .v381ebf(w6),
  .vb186da(w8),
  .vd7f8af(w10),
  .v7e70ae(w14),
  .vc93bbe(w22),
  .vc13c07(w38),
  .v9b870f(w40)
 );
 v725b7e v04ba73 (
  .v9fb85f(w6)
 );
 v21cfcc vaabf4b (
  .v9fb85f(w7)
 );
 v0e64bc #(
  .v207e0d(p9)
 ) v3d06f4 (
  .v8337bc(w12),
  .v531e20(w33)
 );
 vf6eefd va3b3de (
  .v08318f(w11),
  .v87e3a4(w12),
  .vd5249e(w13),
  .v4f9c1d(w29),
  .v141bc5(w42)
 );
 vd0fde2 vbfe495 (
  .v7c533e(w15),
  .v534dbf(w18),
  .vdd729a(w34),
  .ve61673(w43)
 );
 ve79148 v2bc580 (
  .vd76104(w16),
  .v7c533e(w19),
  .v712cd1(w25),
  .vdd729a(w31)
 );
 v80f53c v48414f (
  .v574e7c(w20),
  .vc0aed7(w21)
 );
 v80f53c vcbfbf3 (
  .v574e7c(w22),
  .vc0aed7(w23)
 );
 vda068d v2e932b (
  .v27a5de(w13),
  .v84d9a8(w15),
  .v499ca1(w26),
  .v6007e9(w30),
  .v73b318(w41)
 );
 v4108e6 #(
  .v639d5c(p1)
 ) v626506 (
  .vd45290(w2),
  .v3c20cc(w3),
  .v1fd596(w5),
  .vc6caea(w28),
  .v2ec953(w36)
 );
 v99b33b v91c04a (
  .vcdf6e3(w0),
  .v1fd596(w3),
  .vd45290(w24),
  .vc6caea(w27),
  .v2ec953(w35)
 );
 vb871fd v47a1fe (
  .v99e735(w18),
  .vab25a5(w19),
  .ve19890(w26),
  .v979191(w32)
 );
endmodule

//---------------------------------------------------
//-- I2C_write
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Maestro I2C de un byte de dato. Sólo escritura.
//---------------------------------------------------
//---- Top entity
module v28cfaa (
 input vd7f8af,
 input v7e70ae,
 input vb186da,
 input v381ebf,
 input vc13c07,
 input v9b870f,
 output vc93bbe
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 assign vc93bbe = w0;
 assign w1 = v381ebf;
 assign w2 = vb186da;
 assign w3 = v7e70ae;
 assign w4 = vd7f8af;
 assign w5 = v9b870f;
 assign w6 = vc13c07;
 v28cfaa_ve4e0df ve4e0df (
  .o(w0),
  .i0(w1),
  .i1(w2),
  .i2(w3),
  .i3(w4),
  .s0(w5),
  .s1(w6)
 );
endmodule

//---------------------------------------------------
//-- Mux 4 a 1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Multiplexor de 4 a 1. Implementado en verilog
//---------------------------------------------------

module v28cfaa_ve4e0df (
 input i3,
 input i2,
 input i1,
 input i0,
 input s1,
 input s0,
 output o
);
 wire [1:0] sel = {s1, s0};
 
 assign o = (sel == 2'b00) ? i0 :
            (sel == 2'b01) ? i1 :
            (sel == 2'b10) ? i2 : i3;
 
 
endmodule
//---- Top entity
module v725b7e (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v725b7e_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

//---------------------------------------------------
//-- 1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Un bit constante a 1
//---------------------------------------------------

module v725b7e_vb2eccd (
 output q
);
 //-- Bit constante a 1
 assign q = 1'b1;
 
 
endmodule
//---- Top entity
module vfc9dac (
 input [1:0] v8b19dd,
 output v3f8943,
 output v64d863
);
 wire w0;
 wire w1;
 wire [0:1] w2;
 assign v3f8943 = w0;
 assign v64d863 = w1;
 assign w2 = v8b19dd;
 vfc9dac_v9a2a06 v9a2a06 (
  .o1(w0),
  .o0(w1),
  .i(w2)
 );
endmodule

//---------------------------------------------------
//-- Separador-bus
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 2-bits en dos cables
//---------------------------------------------------

module vfc9dac_v9a2a06 (
 input [1:0] i,
 output o1,
 output o0
);
 assign o1 = i[1];
 assign o0 = i[0];
endmodule
//---- Top entity
module v0e64bc #(
 parameter v207e0d = 1
) (
 input v531e20,
 output v8337bc
);
 localparam p2 = v207e0d;
 wire w0;
 wire w1;
 assign v8337bc = w0;
 assign w1 = v531e20;
 v0e64bc_v94c6d7 #(
  .HZ(p2)
 ) v94c6d7 (
  .clk_o(w0),
  .clk(w1)
 );
endmodule

//---------------------------------------------------
//-- Corazon_Hz
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Corazon genérico para bombear bits a la frecuencia fijada en Hz (por defecto 1Hz)
//---------------------------------------------------

module v0e64bc_v94c6d7 #(
 parameter HZ = 0
) (
 input clk,
 output clk_o
);
 
 //parameter HZ=1;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000/HZ;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
   
 reg clk_o = 0;  
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_o <= ~clk_o;
 
endmodule
//---- Top entity
module vf6eefd (
 input v4f9c1d,
 input v87e3a4,
 input v08318f,
 input v141bc5,
 output vd5249e
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 assign vd5249e = w1;
 assign w3 = v87e3a4;
 assign w4 = v08318f;
 assign w6 = v141bc5;
 assign w7 = v141bc5;
 assign w9 = v87e3a4;
 assign w10 = v4f9c1d;
 assign w11 = v4f9c1d;
 assign w12 = v4f9c1d;
 assign w7 = w6;
 assign w9 = w3;
 assign w11 = w10;
 assign w12 = w10;
 assign w12 = w11;
 v7eacdf v410650 (
  .v2dffca(w0),
  .v10eedb(w2),
  .v0884a0(w10)
 );
 vb959c2 vb1a367 (
  .ve68648(w0),
  .v3c6908(w7),
  .vb4c770(w8),
  .v581b48(w11)
 );
 vb2090f v2f41a8 (
  .vcbab45(w1),
  .v3ca442(w8),
  .v0e28cb(w9)
 );
 vb959c2 v71c6f7 (
  .ve68648(w4),
  .vb4c770(w5),
  .v3c6908(w6),
  .v581b48(w12)
 );
 vb2090f v9e1efd (
  .vcbab45(w2),
  .v0e28cb(w3),
  .v3ca442(w5)
 );
endmodule

//---------------------------------------------------
//-- Start_down
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- La frecuencia de entrada siempre comienza en el ciclo bajo una vez que hacemos 
//---------------------------------------------------
//---- Top entity
module v7eacdf (
 input v0884a0,
 input v10eedb,
 output v2dffca
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v10eedb;
 assign v2dffca = w1;
 assign w2 = v0884a0;
 v7eacdf_v115ffb v115ffb (
  .i(w0),
  .o(w1),
  .clk(w2)
 );
endmodule

//---------------------------------------------------
//-- Bajada
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Detector de flanco de bajada. Emite un tic cuando detecta un flanco descendente
//---------------------------------------------------

module v7eacdf_v115ffb (
 input clk,
 input i,
 output o
);
 reg q = 0;
 
 always @(posedge clk)
   q <= i;
   
 assign o = (q & ~i);  
endmodule
//---- Top entity
module vb959c2 #(
 parameter v679341 = 0
) (
 input v581b48,
 input ve68648,
 input v3c6908,
 output vb4c770
);
 localparam p4 = v679341;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v581b48;
 assign w1 = ve68648;
 assign w2 = v3c6908;
 assign vb4c770 = w3;
 vb959c2_v4e11b3 #(
  .INI(p4)
 ) v4e11b3 (
  .clk(w0),
  .set(w1),
  .rst(w2),
  .q(w3)
 );
endmodule

//---------------------------------------------------
//-- Biestable-Set-Reset
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Biestable con entradas de Set y Reset síncronas, para poner y quitar notaficaciones de eventos
//---------------------------------------------------

module vb959c2_v4e11b3 #(
 parameter INI = 0
) (
 input clk,
 input set,
 input rst,
 output q
);
 reg q = INI;
 
 always @(posedge clk)
   if (set)
     q <= 1'b1;
   else if (rst)
     q<=1'b0;
endmodule
//---- Top entity
module vd0fde2 #(
 parameter v5e4a03 = 32
) (
 input vdd729a,
 input ve61673,
 input v7c533e,
 output [4:0] v534dbf,
 output v712cd1
);
 localparam p1 = v5e4a03;
 wire w0;
 wire w2;
 wire w3;
 wire w4;
 wire [0:4] w5;
 assign w0 = ve61673;
 assign w2 = v7c533e;
 assign w3 = vdd729a;
 assign v712cd1 = w4;
 assign v534dbf = w5;
 vd0fde2_vbd6086 #(
  .M(p1)
 ) vbd6086 (
  .rst(w0),
  .cnt(w2),
  .clk(w3),
  .ov(w4),
  .q(w5)
 );
endmodule

//---------------------------------------------------
//-- Contador-5bits-up-rst
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Contador módulo M, ascendente, de 5 bits, con reset 
//---------------------------------------------------

module vd0fde2_vbd6086 #(
 parameter M = 0
) (
 input clk,
 input rst,
 input cnt,
 output [4:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 5; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (rst | ov)
     qi <= 2'b00;
   else
     if (cnt)
       qi <= qi + 1;
       
 assign q = qi;
 
 //-- Comprobar overflow
 assign ov = (qi == M);
     
endmodule
//---- Top entity
module ve79148 #(
 parameter v5e4a03 = 4
) (
 input vdd729a,
 input ve61673,
 input v7c533e,
 output [1:0] vd76104,
 output v712cd1
);
 localparam p2 = v5e4a03;
 wire [0:1] w0;
 wire w1;
 wire w3;
 wire w4;
 wire w5;
 assign vd76104 = w0;
 assign w1 = ve61673;
 assign w3 = v7c533e;
 assign w4 = vdd729a;
 assign v712cd1 = w5;
 ve79148_vbd6086 #(
  .M(p2)
 ) vbd6086 (
  .q(w0),
  .rst(w1),
  .cnt(w3),
  .clk(w4),
  .ov(w5)
 );
endmodule

//---------------------------------------------------
//-- Contador-2bits-up-rst
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Contador módulo M, ascendente, de 2 bits, con reset 
//---------------------------------------------------

module ve79148_vbd6086 #(
 parameter M = 0
) (
 input clk,
 input rst,
 input cnt,
 output [1:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 2; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (rst | ov)
     qi <= 2'b00;
   else
     if (cnt)
       qi <= qi + 1;
       
 assign q = qi;
 
 //-- Comprobar overflow
 assign ov = (qi == M);
     
endmodule
//---- Top entity
module v80f53c (
 input v574e7c,
 output vc0aed7
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign vc0aed7 = w2;
 assign w3 = v574e7c;
 vd7e6ff v7f8b92 (
  .v248807(w0),
  .vba979e(w1),
  .v341fc3(w2)
 );
 v35f267 v972a00 (
  .vcbab45(w0),
  .v0e28cb(w3)
 );
 v21cfcc v25e4c3 (
  .v9fb85f(w1)
 );
endmodule

//---------------------------------------------------
//-- Tristate_I2C
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- La salida sólo da 0 o flotante. Una resistencia externa al circuito en pull-up a la salida ha de crear el 1.
//---------------------------------------------------
//---- Top entity
module vda068d (
 input v6007e9,
 input v27a5de,
 input v73b318,
 output v84d9a8,
 output v499ca1
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 assign w4 = v73b318;
 assign w9 = v27a5de;
 assign v499ca1 = w13;
 assign v84d9a8 = w14;
 assign w15 = v6007e9;
 assign w16 = v6007e9;
 assign w17 = v6007e9;
 assign w18 = v6007e9;
 assign w5 = w1;
 assign w7 = w1;
 assign w7 = w5;
 assign w8 = w0;
 assign w12 = w6;
 assign w16 = w15;
 assign w17 = w15;
 assign w17 = w16;
 assign w18 = w15;
 assign w18 = w16;
 assign w18 = w17;
 vc386a7 veb560e (
  .v3487af(w0),
  .vb1094d(w1),
  .ve78ab8(w9),
  .ved8395(w18)
 );
 vb959c2 v25e173 (
  .ve68648(w0),
  .v3c6908(w1),
  .vb4c770(w2),
  .v581b48(w15)
 );
 v7eacdf v709f2e (
  .v10eedb(w2),
  .v2dffca(w3),
  .v0884a0(w16)
 );
 vb959c2 ve8e5a6 (
  .ve68648(w3),
  .v3c6908(w4),
  .vb4c770(w6),
  .v581b48(w17)
 );
 vb2090f v588596 (
  .v3ca442(w5),
  .v0e28cb(w12),
  .vcbab45(w14)
 );
 v35f267 v34ff2b (
  .v0e28cb(w6),
  .vcbab45(w11)
 );
 v816138 vabbb6a (
  .v0e28cb(w7),
  .v3ca442(w8),
  .vcbab45(w10)
 );
 vb2090f v309d49 (
  .v0e28cb(w10),
  .v3ca442(w11),
  .vcbab45(w13)
 );
endmodule

//---------------------------------------------------
//-- FirstCycle
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Tics2 son 2 tics de la primera onda y no vuele a hacer nada. A partir del siguiente ciclo saldrán los tics por Shift.
//---------------------------------------------------
//---- Top entity
module vc386a7 (
 input ved8395,
 input ve78ab8,
 output v3487af,
 output vb1094d
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = ved8395;
 assign w1 = ve78ab8;
 assign v3487af = w2;
 assign vb1094d = w3;
 vc386a7_v287d69 v287d69 (
  .clk(w0),
  .i(w1),
  .up(w2),
  .down(w3)
 );
endmodule

//---------------------------------------------------
//-- Detector-flancos
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Detector de flancos de subida y bajada. Emite tic por las salidas correspondientes al detecta los flancos
//---------------------------------------------------

module vc386a7_v287d69 (
 input clk,
 input i,
 output up,
 output down
);
 reg q = 0;
 
 always @(posedge clk)
   q <= i;
   
 assign up = (~q & i);  
 assign down = (q & ~i);  
endmodule
//---- Top entity
module v4108e6 #(
 parameter v05c55e = 1,
 parameter v1882f7 = 0,
 parameter v639d5c = 39
) (
 input vc6caea,
 input v3c20cc,
 input vd45290,
 input v2ec953,
 output v1fd596
);
 localparam p2 = v639d5c;
 localparam p3 = v639d5c;
 localparam p4 = v1882f7;
 localparam p5 = v05c55e;
 localparam p8 = v05c55e;
 localparam p17 = v1882f7;
 wire w0;
 wire [0:6] w1;
 wire w6;
 wire w7;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 assign w7 = v3c20cc;
 assign w10 = vd45290;
 assign w11 = vd45290;
 assign w12 = vd45290;
 assign w13 = v2ec953;
 assign w14 = v2ec953;
 assign w15 = v2ec953;
 assign v1fd596 = w16;
 assign w19 = vc6caea;
 assign w20 = vc6caea;
 assign w21 = vc6caea;
 assign w11 = w10;
 assign w12 = w10;
 assign w12 = w11;
 assign w14 = w13;
 assign w15 = w13;
 assign w15 = w14;
 assign w20 = w19;
 assign w21 = w19;
 assign w21 = w20;
 ve8bebe #(
  .vc96e81(p3)
 ) v68cb87 (
  .v3ba3e6(w0),
  .v626f8c(w1),
  .v9bfaa9(w12),
  .v7d29fb(w15),
  .v0d3330(w16),
  .v4a6801(w20)
 );
 v9f38ea #(
  .vc96e81(p4)
 ) vd6428d (
  .v9b63fe(w0),
  .v3ba3e6(w9),
  .v9bfaa9(w11),
  .v7d29fb(w14),
  .v9b4312(w18),
  .v4a6801(w21)
 );
 v20b7db #(
  .vc5c8ea(p2)
 ) ved0b0a (
  .ve8dbeb(w1)
 );
 v9f38ea #(
  .vc96e81(p8)
 ) v8e6764 (
  .v9b4312(w6),
  .v3ba3e6(w7),
  .v9b63fe(w9),
  .v9bfaa9(w10),
  .v7d29fb(w13),
  .v4a6801(w19)
 );
 v3ba5d0 #(
  .vc5c8ea(p5)
 ) v1ccfb2 (
  .v268bfc(w6)
 );
 v3ba5d0 #(
  .vc5c8ea(p17)
 ) v229844 (
  .v268bfc(w18)
 );
endmodule

//---------------------------------------------------
//-- Address_I2C
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- registros de desplazamientos: address(7bits)+rw(1bit)+ack(1bit)
//---------------------------------------------------
//---- Top entity
module ve8bebe #(
 parameter vc96e81 = 0
) (
 input v4a6801,
 input v3ba3e6,
 input [6:0] v626f8c,
 input v9bfaa9,
 input v7d29fb,
 output v0d3330,
 output [6:0] v78ff73
);
 localparam p0 = vc96e81;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire [0:6] w6;
 wire [0:6] w7;
 assign w1 = v4a6801;
 assign w2 = v3ba3e6;
 assign w3 = v7d29fb;
 assign w4 = v9bfaa9;
 assign v0d3330 = w5;
 assign w6 = v626f8c;
 assign v78ff73 = w7;
 ve8bebe_v768248 #(
  .INI(p0)
 ) v768248 (
  .clk(w1),
  .si(w2),
  .shift(w3),
  .load(w4),
  .so(w5),
  .d(w6),
  .q(w7)
 );
endmodule

//---------------------------------------------------
//-- Registro-desplazamiento
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Registro de desplazamiento (izquierda) de 7 bits
//---------------------------------------------------

module ve8bebe_v768248 #(
 parameter INI = 0
) (
 input clk,
 input si,
 input [6:0] d,
 input load,
 input shift,
 output so,
 output [6:0] q
);
 //-- Numero de bits el registros de desplazamiento
 localparam N = 7;
 
 reg [N-1:0] q = INI;
 
 always @(posedge clk)
   if (load)
     q <= d;
   else if (shift)
     q <= {q[N-2:0], si};
     
 //-- Sacar el bit de mayor peso por serial-out    
 assign so = q[N-1];
endmodule
//---- Top entity
module v9f38ea #(
 parameter vc96e81 = 0
) (
 input v4a6801,
 input v3ba3e6,
 input v9b4312,
 input v9bfaa9,
 input v7d29fb,
 output v9b63fe
);
 localparam p0 = vc96e81;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 assign w1 = v4a6801;
 assign w2 = v3ba3e6;
 assign w3 = v7d29fb;
 assign w4 = v9bfaa9;
 assign v9b63fe = w5;
 assign w6 = v9b4312;
 v9f38ea_v768248 #(
  .INI(p0)
 ) v768248 (
  .clk(w1),
  .si(w2),
  .shift(w3),
  .load(w4),
  .q(w5),
  .d(w6)
 );
endmodule

//---------------------------------------------------
//-- Registro-desplazamiento
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Registro de desplazamiento (izquierda) de 2 bits
//---------------------------------------------------

module v9f38ea_v768248 #(
 parameter INI = 0
) (
 input clk,
 input si,
 input d,
 input load,
 input shift,
 output q
);
 
 reg q = INI;
 
 always @(posedge clk)
   if (load)
     q <= d;
   else if (shift)
     q <= si;
     
endmodule
//---- Top entity
module v20b7db #(
 parameter vc5c8ea = 0
) (
 output [6:0] ve8dbeb
);
 localparam p0 = vc5c8ea;
 wire [0:6] w1;
 assign ve8dbeb = w1;
 v20b7db_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- Constante-7bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor genérico constante, de 7 bits. Su valor se introduce como parámetro. Por defecto vale 0
//---------------------------------------------------

module v20b7db_v465065 #(
 parameter VALUE = 0
) (
 output [6:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module v3ba5d0 #(
 parameter vc5c8ea = 0
) (
 output v268bfc
);
 localparam p0 = vc5c8ea;
 wire w1;
 assign v268bfc = w1;
 v3ba5d0_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- Constante-1bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor genérico constante, de 1 bits. Su valor se introduce como parámetro. Por defecto vale 0
//---------------------------------------------------

module v3ba5d0_v465065 #(
 parameter VALUE = 0
) (
 output k
);
 assign k = VALUE;
endmodule
//---- Top entity
module v99b33b #(
 parameter v05c55e = 1
) (
 input vc6caea,
 input [7:0] vcdf6e3,
 input vd45290,
 input v2ec953,
 output v1fd596
);
 localparam p0 = v05c55e;
 localparam p2 = v05c55e;
 wire w1;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire [0:7] w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 assign w3 = vd45290;
 assign w4 = vd45290;
 assign w5 = v2ec953;
 assign v1fd596 = w6;
 assign w8 = vcdf6e3;
 assign w9 = v2ec953;
 assign w11 = vc6caea;
 assign w12 = vc6caea;
 assign w4 = w3;
 assign w9 = w5;
 assign w12 = w11;
 v9f38ea #(
  .vc96e81(p2)
 ) v8e6764 (
  .v9b4312(w1),
  .v9bfaa9(w3),
  .v7d29fb(w5),
  .v9b63fe(w7),
  .v3ba3e6(w10),
  .v4a6801(w11)
 );
 v3ba5d0 #(
  .vc5c8ea(p0)
 ) v1ccfb2 (
  .v268bfc(w1)
 );
 v53847c v87da75 (
  .v9bfaa9(w4),
  .v0d3330(w6),
  .v3ba3e6(w7),
  .v67ccbf(w8),
  .v7d29fb(w9),
  .v4a6801(w12)
 );
 v21cfcc vc2de90 (
  .v9fb85f(w10)
 );
endmodule

//---------------------------------------------------
//-- Data_I2C
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- registros de desplazamientos: data(8bits)+ack(1bit).
//---------------------------------------------------
//---- Top entity
module v53847c #(
 parameter vc96e81 = 0
) (
 input v4a6801,
 input v3ba3e6,
 input [7:0] v67ccbf,
 input v9bfaa9,
 input v7d29fb,
 output v0d3330,
 output [7:0] vd50ef8
);
 localparam p0 = vc96e81;
 wire [0:7] w1;
 wire w2;
 wire w3;
 wire [0:7] w4;
 wire w5;
 wire w6;
 wire w7;
 assign vd50ef8 = w1;
 assign w2 = v4a6801;
 assign w3 = v3ba3e6;
 assign w4 = v67ccbf;
 assign w5 = v7d29fb;
 assign w6 = v9bfaa9;
 assign v0d3330 = w7;
 v53847c_v768248 #(
  .INI(p0)
 ) v768248 (
  .q(w1),
  .clk(w2),
  .si(w3),
  .d(w4),
  .shift(w5),
  .load(w6),
  .so(w7)
 );
endmodule

//---------------------------------------------------
//-- Registro-desplazamiento
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Registro de desplazamiento (izquierda) de 8 bits
//---------------------------------------------------

module v53847c_v768248 #(
 parameter INI = 0
) (
 input clk,
 input si,
 input [7:0] d,
 input load,
 input shift,
 output so,
 output [7:0] q
);
 //-- Numero de bits el registros de desplazamiento
 localparam N = 8;
 
 reg [N-1:0] q = INI;
 
 always @(posedge clk)
   if (load)
     q <= d;
   else if (shift)
     q <= {q[N-2:0], si};
     
 //-- Sacar el bit de mayor peso por serial-out    
 assign so = q[N-1];
endmodule
//---- Top entity
module vb871fd #(
 parameter vbf6e5f = 19,
 parameter v9040ac = 20
) (
 input v979191,
 input ve19890,
 input [4:0] v99e735,
 output vab25a5
);
 localparam p0 = vbf6e5f;
 localparam p1 = v9040ac;
 wire w2;
 wire w3;
 wire [0:4] w4;
 wire w5;
 wire w6;
 wire [0:4] w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 assign w4 = v99e735;
 assign w7 = v99e735;
 assign w8 = v979191;
 assign w9 = v979191;
 assign vab25a5 = w11;
 assign w12 = ve19890;
 assign w7 = w4;
 assign w9 = w8;
 v3684ed #(
  .v6b316b(p0)
 ) v5ab7ad (
  .v18e78c(w2),
  .v4d7368(w4)
 );
 v3684ed #(
  .v6b316b(p1)
 ) v453a7d (
  .v18e78c(w3),
  .v4d7368(w7)
 );
 v8e2728 v9f9954 (
  .v10eedb(w2),
  .v2dffca(w5),
  .v0884a0(w8)
 );
 v8e2728 vedff27 (
  .v10eedb(w3),
  .v2dffca(w6),
  .v0884a0(w9)
 );
 v816138 vf8ef29 (
  .v0e28cb(w5),
  .v3ca442(w6),
  .vcbab45(w10)
 );
 v816138 vb9834f (
  .v0e28cb(w10),
  .vcbab45(w11),
  .v3ca442(w12)
 );
endmodule

//---------------------------------------------------
//-- stopCycle
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Complemento que junto a resto de los elementos crean la señal Stop.
//---------------------------------------------------
//---- Top entity
module v3684ed #(
 parameter v6b316b = 0
) (
 input [4:0] v4d7368,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:4] w2;
 assign v18e78c = w0;
 assign w2 = v4d7368;
 v3684ed_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 4 bits. Se compara si el operando es igual al parámetro
//---------------------------------------------------

module v3684ed_vd75681 #(
 parameter K = 0
) (
 input [4:0] a,
 output eq
);
 assign eq = (a == K);
endmodule
//---- Top entity
module v8e2728 (
 input v0884a0,
 input v10eedb,
 output v2dffca
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v10eedb;
 assign v2dffca = w1;
 assign w2 = v0884a0;
 v8e2728_v115ffb v115ffb (
  .i(w0),
  .o(w1),
  .clk(w2)
 );
endmodule

//---------------------------------------------------
//-- Subida
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Detector de flanco de subida. Emite un tic cuando detecta un flanco ascendente
//---------------------------------------------------

module v8e2728_v115ffb (
 input clk,
 input i,
 output o
);
 reg q = 0;
 
 always @(posedge clk)
   q <= i;
   
 assign o = (~q & i);  
endmodule
//---- Top entity
module va702c4 #(
 parameter vb77f40 = 100_000,
 parameter v8221e4 = 9
) (
 input v1f3320,
 input [15:0] v0df35e,
 input [7:0] v45c009,
 input v03da85,
 output vbaded2,
 output v1c4983,
 output v06d8fb,
 output v455c23
);
 localparam p5 = vb77f40;
 localparam p13 = v8221e4;
 wire [0:7] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire [0:15] w18;
 wire [0:15] w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 wire w33;
 wire w34;
 wire w35;
 wire w36;
 wire w37;
 wire w38;
 wire [0:15] w39;
 wire w40;
 wire w41;
 wire w42;
 wire [0:1] w43;
 wire [0:1] w44;
 wire w45;
 wire w46;
 wire w47;
 wire w48;
 assign w0 = v45c009;
 assign w12 = v1f3320;
 assign w15 = v03da85;
 assign w17 = v1f3320;
 assign w18 = v0df35e;
 assign v06d8fb = w21;
 assign v1c4983 = w23;
 assign vbaded2 = w26;
 assign w30 = v03da85;
 assign w31 = v1f3320;
 assign w32 = v1f3320;
 assign w33 = v1f3320;
 assign w34 = v1f3320;
 assign w35 = v1f3320;
 assign w36 = v1f3320;
 assign w37 = v1f3320;
 assign w38 = v1f3320;
 assign v455c23 = w48;
 assign w4 = w2;
 assign w9 = w3;
 assign w10 = w6;
 assign w14 = w7;
 assign w16 = w7;
 assign w16 = w14;
 assign w17 = w12;
 assign w21 = w20;
 assign w22 = w2;
 assign w22 = w4;
 assign w30 = w15;
 assign w31 = w12;
 assign w31 = w17;
 assign w32 = w12;
 assign w32 = w17;
 assign w32 = w31;
 assign w33 = w12;
 assign w33 = w17;
 assign w33 = w31;
 assign w33 = w32;
 assign w34 = w12;
 assign w34 = w17;
 assign w34 = w31;
 assign w34 = w32;
 assign w34 = w33;
 assign w35 = w12;
 assign w35 = w17;
 assign w35 = w31;
 assign w35 = w32;
 assign w35 = w33;
 assign w35 = w34;
 assign w36 = w12;
 assign w36 = w17;
 assign w36 = w31;
 assign w36 = w32;
 assign w36 = w33;
 assign w36 = w34;
 assign w36 = w35;
 assign w37 = w12;
 assign w37 = w17;
 assign w37 = w31;
 assign w37 = w32;
 assign w37 = w33;
 assign w37 = w34;
 assign w37 = w35;
 assign w37 = w36;
 assign w38 = w12;
 assign w38 = w17;
 assign w38 = w31;
 assign w38 = w32;
 assign w38 = w33;
 assign w38 = w34;
 assign w38 = w35;
 assign w38 = w36;
 assign w38 = w37;
 assign w41 = w40;
 assign w42 = w40;
 assign w42 = w41;
 assign w44 = w43;
 assign w46 = w45;
 assign w47 = w29;
 assign w48 = w29;
 assign w48 = w47;
 v725b7e v87bce2 (
  .v9fb85f(w1)
 );
 v725b7e v04ba73 (
  .v9fb85f(w2)
 );
 v21cfcc vaabf4b (
  .v9fb85f(w3)
 );
 v0e64bc #(
  .v207e0d(p5)
 ) v3d06f4 (
  .v531e20(w38),
  .v8337bc(w45)
 );
 vf6eefd va3b3de (
  .vd5249e(w6),
  .v4f9c1d(w17),
  .v141bc5(w20),
  .v08318f(w30),
  .v87e3a4(w45)
 );
 ve79148 v2bc580 (
  .v7c533e(w25),
  .vdd729a(w34),
  .ve61673(w40),
  .vd76104(w43)
 );
 vda068d v2e932b (
  .v27a5de(w6),
  .v84d9a8(w7),
  .v499ca1(w8),
  .v6007e9(w32),
  .v73b318(w41)
 );
 v99b33b v91c04a (
  .vcdf6e3(w0),
  .v1fd596(w11),
  .vc6caea(w12),
  .vd45290(w15),
  .v2ec953(w16)
 );
 v2ddbb2 #(
  .v5e4a03(p13)
 ) v019a90 (
  .v7c533e(w14),
  .v712cd1(w20),
  .vdd729a(w37),
  .ve61673(w42)
 );
 vd24e0f v87953d (
  .v085372(w18),
  .vd62140(w39)
 );
 v8d4ef5 v4b02b2 (
  .v7c533e(w7),
  .va1a83a(w19),
  .vdd729a(w36),
  .ve61673(w47)
 );
 v816138 va29249 (
  .v0e28cb(w24),
  .vcbab45(w25),
  .v3ca442(w28)
 );
 v1c7dae v588502 (
  .ve8318d(w26),
  .vf54559(w27),
  .va4102a(w31)
 );
 v3b3773 v97b240 (
  .v2b32a7(w28),
  .va52ff2(w29),
  .v0c57d9(w35),
  .vf13335(w40),
  .vc71f8b(w46)
 );
 ve33ecb vb5acf7 (
  .v381ebf(w1),
  .vb186da(w3),
  .vd7f8af(w9),
  .v7e70ae(w11),
  .vc93bbe(w27),
  .v6fb4d1(w43)
 );
 ve33ecb v726963 (
  .v381ebf(w2),
  .vb186da(w4),
  .v7e70ae(w10),
  .vd7f8af(w22),
  .vc93bbe(w23),
  .v6fb4d1(w44)
 );
 v1ae408 vc6434a (
  .v4ee00c(w8),
  .vcf4e12(w19),
  .v2b6c36(w24),
  .va5c4b9(w29),
  .v8a403d(w33),
  .v5c0876(w39)
 );
endmodule

//---------------------------------------------------
//-- I2C_write_generic
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Programmable generic write-only I2C master.
//---------------------------------------------------
//---- Top entity
module v2ddbb2 #(
 parameter v5e4a03 = 16
) (
 input vdd729a,
 input ve61673,
 input v7c533e,
 output [3:0] vfc94a5,
 output v712cd1
);
 localparam p1 = v5e4a03;
 wire w0;
 wire w2;
 wire w3;
 wire w4;
 wire [0:3] w5;
 assign w0 = ve61673;
 assign w2 = v7c533e;
 assign w3 = vdd729a;
 assign v712cd1 = w4;
 assign vfc94a5 = w5;
 v2ddbb2_vbd6086 #(
  .M(p1)
 ) vbd6086 (
  .rst(w0),
  .cnt(w2),
  .clk(w3),
  .ov(w4),
  .q(w5)
 );
endmodule

//---------------------------------------------------
//-- Contador-4bits-up-rst
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Contador módulo M, ascendente, de 4 bits, con reset 
//---------------------------------------------------

module v2ddbb2_vbd6086 #(
 parameter M = 0
) (
 input clk,
 input rst,
 input cnt,
 output [3:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 4; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (rst | ov)
     qi <= 0;
   else
     if (cnt)
       qi <= qi + 1;
 
 //-- Comprobar overflow
 assign ov = (qi == M);
 
 //-- En cuanto haya overflow
 //-- se saca 0 por la salida
 assign q = ov ? 0 : qi;
 
 
     
endmodule
//---- Top entity
module vd24e0f (
 input [15:0] v085372,
 output [15:0] vd62140
);
 wire [0:15] w0;
 wire [0:15] w1;
 assign w0 = v085372;
 assign vd62140 = w1;
 vd24e0f_vead792 vead792 (
  .i(w0),
  .o(w1)
 );
endmodule

//---------------------------------------------------
//-- x9
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Multiplica la entrada por 9.
//---------------------------------------------------

module vd24e0f_vead792 (
 input [15:0] i,
 output [15:0] o
);
 assign o = i * 9;
endmodule
//---- Top entity
module v8d4ef5 #(
 parameter v5e4a03 = 'h10000
) (
 input vdd729a,
 input ve61673,
 input v7c533e,
 output [15:0] va1a83a,
 output v712cd1
);
 localparam p1 = v5e4a03;
 wire w0;
 wire w2;
 wire w3;
 wire w4;
 wire [0:15] w5;
 assign w0 = ve61673;
 assign w2 = v7c533e;
 assign w3 = vdd729a;
 assign v712cd1 = w4;
 assign va1a83a = w5;
 v8d4ef5_vbd6086 #(
  .M(p1)
 ) vbd6086 (
  .rst(w0),
  .cnt(w2),
  .clk(w3),
  .ov(w4),
  .q(w5)
 );
endmodule

//---------------------------------------------------
//-- Contador-16bits-up-rst
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Contador módulo M, ascendente, de 16 bits, con reset 
//---------------------------------------------------

module v8d4ef5_vbd6086 #(
 parameter M = 0
) (
 input clk,
 input rst,
 input cnt,
 output [15:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 16; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (rst | ov)
     qi <= 0;
   else
     if (cnt)
       qi <= qi + 1;
       
 assign q = qi;
 
 //-- Comprobar overflow
 assign ov = (qi == M);
     
endmodule
//---- Top entity
module v1c7dae #(
 parameter v71e305 = 0
) (
 input va4102a,
 input vf54559,
 output ve8318d
);
 localparam p2 = v71e305;
 wire w0;
 wire w1;
 wire w3;
 assign w0 = va4102a;
 assign ve8318d = w1;
 assign w3 = vf54559;
 v1c7dae_vb8adf8 #(
  .INI(p2)
 ) vb8adf8 (
  .clk(w0),
  .q(w1),
  .d(w3)
 );
endmodule

//---------------------------------------------------
//-- Biestable-D
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Biestable de datos (Tipo D). Cuando se recibe un tic por load se captura el dato
//---------------------------------------------------

module v1c7dae_vb8adf8 #(
 parameter INI = 0
) (
 input clk,
 input d,
 output q
);
 reg q = INI;
 always @(posedge clk)
   q <= d;
endmodule
//---- Top entity
module v3b3773 #(
 parameter v08ffed = 2
) (
 input v0c57d9,
 input va52ff2,
 input vc71f8b,
 output v2b32a7,
 output vf13335
);
 localparam p0 = v08ffed;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 assign vf13335 = w6;
 assign w7 = v0c57d9;
 assign w8 = v0c57d9;
 assign w10 = vc71f8b;
 assign w11 = va52ff2;
 assign w12 = v0c57d9;
 assign v2b32a7 = w13;
 assign w8 = w7;
 assign w9 = w6;
 assign w12 = w7;
 assign w12 = w8;
 assign w13 = w1;
 ve79148 #(
  .v5e4a03(p0)
 ) v9d04d5 (
  .v7c533e(w1),
  .v712cd1(w6),
  .vdd729a(w12)
 );
 vb2090f vd55f52 (
  .vcbab45(w1),
  .v0e28cb(w2),
  .v3ca442(w3)
 );
 vb959c2 v647f2c (
  .vb4c770(w2),
  .v581b48(w7),
  .v3c6908(w9),
  .ve68648(w11)
 );
 vc386a7 v553091 (
  .v3487af(w4),
  .vb1094d(w5),
  .ved8395(w8),
  .ve78ab8(w10)
 );
 v816138 vf49c08 (
  .vcbab45(w3),
  .v0e28cb(w4),
  .v3ca442(w5)
 );
endmodule

//---------------------------------------------------
//-- end_of_data_detector
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- End of data detector.
//---------------------------------------------------
//---- Top entity
module ve33ecb (
 input vd7f8af,
 input v7e70ae,
 input vb186da,
 input v381ebf,
 input [1:0] v6fb4d1,
 output vc93bbe
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire [0:1] w5;
 assign vc93bbe = w0;
 assign w1 = v381ebf;
 assign w2 = vb186da;
 assign w3 = v7e70ae;
 assign w4 = vd7f8af;
 assign w5 = v6fb4d1;
 ve33ecb_ve4e0df ve4e0df (
  .o(w0),
  .i0(w1),
  .i1(w2),
  .i2(w3),
  .i3(w4),
  .sel(w5)
 );
endmodule

//---------------------------------------------------
//-- Mux_4_1_bus
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Multiplexor de 4 a 1, bus. Implementado en verilog.
//---------------------------------------------------

module ve33ecb_ve4e0df (
 input i3,
 input i2,
 input i1,
 input i0,
 input [1:0] sel,
 output o
);
 
 assign o = (sel == 0) ? i0 :
            (sel == 1) ? i1 :
            (sel == 2) ? i2 : i3;
 
endmodule
//---- Top entity
module v1ae408 (
 input v8a403d,
 input v4ee00c,
 input [15:0] v5c0876,
 input [15:0] vcf4e12,
 output v2b6c36,
 output va5c4b9
);
 wire w0;
 wire [0:15] w1;
 wire [0:15] w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 assign w0 = v4ee00c;
 assign v2b6c36 = w0;
 assign w1 = v5c0876;
 assign w2 = vcf4e12;
 assign w5 = v4ee00c;
 assign va5c4b9 = w7;
 assign w8 = v8a403d;
 assign w5 = w0;
 v5349f3 vc618b0 (
  .v526b5b(w1),
  .ve920a5(w2),
  .v18e78c(w3)
 );
 vb2090f v60df25 (
  .v3ca442(w3),
  .v0e28cb(w4),
  .vcbab45(w9)
 );
 v1c7dae v38623b (
  .ve8318d(w4),
  .va4102a(w5),
  .vf54559(w6)
 );
 v725b7e vc5ae85 (
  .v9fb85f(w6)
 );
 v8e2728 v90465e (
  .v2dffca(w7),
  .v0884a0(w8),
  .v10eedb(w9)
 );
endmodule

//---------------------------------------------------
//-- EndData
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- End of data detector
//---------------------------------------------------
//---- Top entity
module v5349f3 (
 input [15:0] v526b5b,
 input [15:0] ve920a5,
 output v18e78c
);
 wire w0;
 wire [0:15] w1;
 wire [0:15] w2;
 assign v18e78c = w0;
 assign w1 = v526b5b;
 assign w2 = ve920a5;
 v5349f3_vd75681 vd75681 (
  .eq(w0),
  .a(w1),
  .b(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador_16
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de igualdad de 16 bits.
//---------------------------------------------------

module v5349f3_vd75681 (
 input [15:0] a,
 input [15:0] b,
 output eq
);
 assign eq = (a == b);
endmodule
//---- Top entity
module vea7a9f #(
 parameter vaa7e21 = 12000000,
 parameter vf72171 = 400000
) (
 input v195602,
 input v15d637,
 input v8d5a0a,
 output [11:0] v33c8d6,
 output [11:0] v75d11d,
 output [11:0] v4a0eb9,
 output [11:0] v31e23c,
 output v3351ca,
 inout v809f00,
 inout vc79dbf
);
 localparam p0 = vf72171;
 localparam p1 = vaa7e21;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire [0:11] w8;
 wire [0:11] w9;
 wire [0:11] w10;
 wire [0:11] w11;
 assign w2 = v15d637;
 assign w3 = v8d5a0a;
 assign w4 = v195602;
 assign v809f00 = w5;
 assign vc79dbf = w6;
 assign v3351ca = w7;
 assign v31e23c = w8;
 assign v4a0eb9 = w9;
 assign v75d11d = w10;
 assign v33c8d6 = w11;
 vea7a9f_ve9ee3c #(
  .FSCL(p0),
  .FCLK(p1)
 ) ve9ee3c (
  .reset(w2),
  .int(w3),
  .clk(w4),
  .sda(w5),
  .scl(w6),
  .sampletick(w7),
  .ana0(w8),
  .ana1(w9),
  .ana2(w10),
  .ana3(w11)
 );
endmodule

//---------------------------------------------------
//-- ADC_ADS7924_Arias
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- This module is a block that reads the 4 ADC inputs of the ADS7924 and presents the results as plain four 12-bit values.
//---------------------------------------------------

module vea7a9f_ve9ee3c #(
 parameter FCLK = 0,
 parameter FSCL = 0
) (
 input clk,
 input reset,
 input int,
 output [11:0] ana3,
 output [11:0] ana2,
 output [11:0] ana1,
 output [11:0] ana0,
 output sampletick,
 inout sda,
 inout scl
);
 ////////////////////////////////////////////////////////////////////
 //                ADS7924 reader (via I2C bus)
 // J. Arias (2024) Public domain sources
 //
 // This module is a block that reads the 4 ADC inputs of the ADS7924
 // and presents the results as plain four 12-bit values.
 // -First, it configure the ADC with "Auto-Burst Scan with Sleep" mode,
 //  with minimun sleep time (2.5ms / 4 = 625us), and 14us adquisition
 //  time (max source resistance: 100 kohm)
 // -Then it waits for BUSY pulses on the INT input, reads the 4 channel
 //  values, and keeps doing this again and again.
 // -A sample clock output is provided. This signal is low while the data
 //  is being updated. Output updates are atomic (the whole 12 bits of
 //  the outputs are written in parallel)
 //
 // I2C Details:
 // - ACK bits are ignored (there is nothing we can do if they fail, anyways)
 // - No clock stretching is allowed (this isn't a problem for the ADS7924)
 //
 // Performance:
 // - 1430 (+-20%) Samples/s. The sampling rate depends on an inaccurate 
 //   internal clock.
 // - 124 Logic cells.
 //
 // More info = https://groups.google.com/g/fpga-wars-explorando-el-lado-libre/c/9gcu-SFjloA
 
 // Clock dividers clk2 = 2*clkbit, almost square
 localparam DIVIDER = (FCLK/2)/FSCL;
 localparam NDIV = $clog2(DIVIDER);
 
 reg [NDIV-1:0]pres=0;
 always @(posedge clk) pres<= (pres==DIVIDER-1) ? 0 : pres+1;
 reg clk2=0;
 always @(posedge clk) clk2<=(pres<=(DIVIDER/2));
 
 reg clkbit=0;	// bit clock, active rising
 always @(posedge clk2) clkbit<=~clkbit;
 
 // SCL & SDA
 reg sclo1; // temp SCL output, 1/4 Tbit delay
 always @(negedge clk2) sclo1<=idle | (start&clkbit) | (stop&(~clkbit)) | clkbit;
 reg sclo;  // SCL output resampled (delayed 1 clk for equalization with respect SDA)
 always @(posedge clk) sclo<=sclo1;
 reg sdao;  // registered SDA output to avoid glitches
 always @(posedge clk) sdao <= idle | (start&clkbit) | (stop&(~clkbit)) | (datast&sh[8]) ;
 
 // Open-drain pins: SCL, SDA
 assign scl = sclo ? 1'bz : 1'b0;
 assign sda = sdao ? 1'bz : 1'b0;
 
 // bit counter (9 cycles: data + ACK)
 reg [3:0]bcnt=0;
 wire nxtinstr = (~datast)|bcnt[3];	// next instruction: after 9 cycles if in data state
 always @(posedge clkbit) bcnt<= nxtinstr ? 0 : bcnt+1;
 
 // Shift register (sda input and output)
 reg ssda;	// sampled SDA (SCL falling)
 always @(negedge scl) ssda<=sda;
 
 reg [8:0]sh; // 9-bit shift register
 always @(posedge clkbit) sh<= nxtinstr ? {ucode[7:0],ack} : {sh[7:0],ssda};
 
 /////////////////// SEQUENCER //////////////////////
 /// START / STOP / IDLE / DATA
 localparam IDL = 2'b00;
 localparam STA = 2'b01;
 localparam STP = 2'b10;
 localparam DAT = 2'b11;
 
 // instructions
 wire idle  = (ucode[10:9]==IDL);
 wire start = (ucode[10:9]==STA);
 wire stop  = (ucode[10:9]==STP);
 wire datast= (ucode[10:9]==DAT);
 
 localparam ACK = 1'b0;
 localparam NAK = 1'b1;
 wire ack =ucode[8];		// ACK bit to send
 
 wire goto=ucode[11];	// Goto to address 0
 wire wr0 =ucode[12];	// write channels #0 to #3
 wire wr1 =ucode[13];
 wire wr2 =ucode[14];
 wire wr3 =ucode[15];
 
 // address counter
 localparam ADDRST=16; 	// reset address
 reg [4:0]uaddr = ADDRST;// address counter
 
 always @(posedge clkbit or posedge reset)
 	if (reset) uaddr<=ADDRST;
 	// GOTO and IDLE with no data_av jumps to address 0
 	else uaddr<= (goto | (idle & (~data_av)))? 0 : uaddr + nxtinstr;
 	// GOTO jumps to address 0. IDLE blocks until data_av
 	//else uaddr<= goto ? 0 : uaddr + (nxtinstr & ((~idle)|data_av));
 
 // microcode ROM (asynchronous)
 //  includes control signals (write, goto) for current instruction, 
 //  and data to be loaded into the shift register for next instruction
 reg [15:0]ucode;	// not register, combinational
 always @*
 	case(uaddr)
 	// Operation loop
 	//              wr3-0  goto inst ack  data
 	5'd0 : ucode<={4'b0000,1'b0, IDL,1'bx,8'hxx};	// wait for INT edge
 	5'd1 : ucode<={4'b0000,1'b0, STA, NAK,8'h90};	// START, Slave address, write
 	5'd2 : ucode<={4'b0000,1'b0, DAT, NAK,8'h82};	// reg #2, increment address
 	5'd3 : ucode<={4'b0000,1'b0, DAT,1'bx,8'hXX};	// send last byte
 	5'd4 : ucode<={4'b0000,1'b0, STP,1'bx,8'hXX};	// STOP
 	
 	5'd5 : ucode<={4'b0000,1'b0, STA, NAK,8'h91};	// START, Slave address, read
 	5'd6 : ucode<={4'b0000,1'b0, DAT, ACK,8'hFF};	
 	5'd7 : ucode<={4'b0000,1'b0, DAT, ACK,8'hFF};	// DATA0_U
 	5'd8 : ucode<={4'b0001,1'b0, DAT, ACK,8'hFF};	// DATA0_L, write to AN0
 	5'd9 : ucode<={4'b0000,1'b0, DAT, ACK,8'hFF};	// DATA1_U
 	5'd10: ucode<={4'b0010,1'b0, DAT, ACK,8'hFF};	// DATA1_L, write to AN1
 	5'd11: ucode<={4'b0000,1'b0, DAT, ACK,8'hFF};	// DATA2_U
 	5'd12: ucode<={4'b0100,1'b0, DAT, ACK,8'hFF};	// DATA2_L, write to AN2
 	5'd13: ucode<={4'b0000,1'b0, DAT, NAK,8'hFF};	// DATA3_U
 	5'd14: ucode<={4'b1000,1'b0, DAT,1'bx,8'hXX};	// DATA3_L, write to AN3
 	5'd15: ucode<={4'b0000,1'b1, STP,1'bx,8'hXX};	// STOP, GOTO 0
 	
 	// Init: configuring ADC registers
 	5'd16: ucode<={4'b0000,1'b0, STA, NAK,8'h90};	// START, Slave address, write
 	5'd17: ucode<={4'b0000,1'b0, DAT, NAK,8'h80};	// reg #0, increment address
 	5'd18: ucode<={4'b0000,1'b0, DAT, NAK,8'hFC};	// Auto-Burst Scan with Sleep mode, ch #0
 	5'd19: ucode<={4'b0000,1'b0, DAT,1'bx,8'hXX};	// send last byte
 	5'd20: ucode<={4'b0000,1'b0, STP,1'bx,8'hXX};	// STOP
 	
 	5'd21: ucode<={4'b0000,1'b0, STA, NAK,8'h90};	// START, Slave address, write
 	5'd22: ucode<={4'b0000,1'b0, DAT, NAK,8'h92};	// reg #0x12, increment address 
 	5'd23: ucode<={4'b0000,1'b0, DAT, NAK,8'h04};	// INTCFG: INT=BUSY, active low
 	5'd24: ucode<={4'b0000,1'b0, DAT, NAK,8'h20};	// SLPCFG: Sleep: 2.5ms/4
 	5'd25: ucode<={4'b0000,1'b0, DAT, NAK,8'h04};	// ACQCFG: 4*2+6 = 14us
 	5'd26: ucode<={4'b0000,1'b0, DAT,1'bx,8'hXX};	// send last byte
 	5'd27: ucode<={4'b0000,1'b1, STP,1'bx,8'hXX};	// STOP, GOTO 0
 
 	default: ucode<=16'hxxxx;
 	endcase
 	
 // Output registers
 // notice the ACK bit hasn't been yet shifted in when 'nxtinstr' is asserted
 reg [7:0]olddat;	// previous byte
 always @(posedge clkbit) if (nxtinstr) olddat<=sh[7:0];
 reg [11:0]an0;
 reg [11:0]an1;
 reg [11:0]an2;
 reg [11:0]an3;
 always @(posedge clkbit) begin
 	if (nxtinstr & wr0) an0<={olddat,sh[7:4]};
 	if (nxtinstr & wr1) an1<={olddat,sh[7:4]};
 	if (nxtinstr & wr2) an2<={olddat,sh[7:4]};
 	if (nxtinstr & wr3) an3<={olddat,sh[7:4]};
 end
 
 // INT trigger
 // (Datasheet errata? There are 4 busy pulses, one per channel, when the datasheet
 // shows only one pulse on fig. 28 "Auto-Burst Scan With Sleep Operation Example".
 // Anyway, a workaround is implemented)
 reg [3:0]tim;	// Monostable timer (4 busy pulses -> single pulse)
 always @(posedge clkbit) tim <= int ? tim+(tim!=15) : 0;
 
 wire data_av =(tim==14); // Data Available for read
 
 // Sample Clock
 reg sampleck=0;
 always @(posedge clkbit) sampleck<= data_av ? 1'b0 :(goto ? 1'b1 : sampleck);
 
 assign sampletick = sampleck;
 assign ana0 = an0;
 assign ana1 = an1;
 assign ana2 = an2;
 assign ana3 = an3;
 
endmodule
//---- Top entity
module v9c4264 #(
 parameter vb33f66 = 12,
 parameter v2ea16f = 400
) (
 input va3e275,
 input vf23033,
 input [1:0] v2f10a1,
 input vbfe601,
 output v84f79b,
 output v488744,
 output v6c35bb,
 output [11:0] v916ef9,
 output v5df786
);
 localparam p2 = vb33f66;
 localparam p3 = v2ea16f;
 wire w0;
 wire w1;
 wire w4;
 wire [0:1] w5;
 wire w6;
 wire w7;
 wire w8;
 wire [0:11] w9;
 wire w10;
 assign v84f79b = w0;
 assign w1 = va3e275;
 assign w4 = vf23033;
 assign w5 = v2f10a1;
 assign w6 = vbfe601;
 assign v488744 = w7;
 assign v6c35bb = w8;
 assign v916ef9 = w9;
 assign v5df786 = w10;
 v9c4264_ve6dfd8 #(
  .Bits(p2),
  .Spd(p3)
 ) ve6dfd8 (
  .SCL(w0),
  .SDA_ADC(w1),
  .clk(w4),
  .SELEC(w5),
  .START(w6),
  .ERR(w7),
  .DONE(w8),
  .ADC_out(w9),
  .Reset(w10)
 );
endmodule

//---------------------------------------------------
//-- ADC_8_12B
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Control y lectura I2C del ADS7924
//---------------------------------------------------

module v9c4264_ve6dfd8 #(
 parameter Bits = 0,
 parameter Spd = 0
) (
 input SDA_ADC,
 input clk,
 input [1:0] SELEC,
 input START,
 output SCL,
 output ERR,
 output DONE,
 output [11:0] ADC_out,
 output Reset
);
 // Control y lectura ADS7924, Llorens_MRC, enero 2022 -OPERATIVO-BLOCK-
 
 reg [9:0]Dato[0:25];    // Array 25 datos 10b
 reg Bu[0:9];            // Array 9 datos 1b para sub-frame
 reg [4:0]Pdata=0;       // puntero de fila de Dato[]
 reg [4:0]Ldata;         // Nº de filas de Órdenes/Datos
 reg [14:0]L1=37;        // Salto Órdenes
 reg [14:0]L2=0;         // +Salto Orden Rstart Esp.(Norden=5)
 reg [14:0]L3=285;       // Salto Direcc/Datos
 reg [14:0]Cont=32200;   // Contador clk
 reg [14:0]Final=32000;  // Puntero Final frame I2C
 reg [14:0]Punt=0;       // Puntero contador
 reg [3:0]Pbit=0;        // Puntero bits en sub-frame
 reg [3:0]Sframe=8;      // Longitud sub-frame
 reg [14:0]On=2;         // Puntero Inicio sub-frame
 reg [14:0]Off=2;        // Puntero Final sub-frame
 reg Orden=0;            // Flag de Orden/Datos
 reg [3:0]Norden=0;      // Número de Orden
 reg [2:0]Vel=4;         // Velocidad 1=400Khz o 4=100Khz
 reg [4:0]f;             // Variable de for()
 reg ERR=0;              // Flag de Error
 reg DONE=0;             // Flag conversión ADC finalizada
 reg Reset=1;            // Salida para Reset de ADC
 reg Usb=1;              // Flag 8 bits altos ADC
 reg [12:0]Multip=1;     // Multiplicador para BIN>DEC
 reg Datafin[0:12];      // Array 12x1b recibidos del ADC
 reg [11:0]ADC_out=0;    // Datos de salida ADC
 wire SDAin;             // Linea interna Slave>>Master
 reg SCL=1;              // Bus de reloj I2C
 reg SDA=1;              // Bus de datos I2C
 reg DSW=1;              // Conmutación M>S o S>M
 
 
 SB_IO #(                // Primitiva Inout para línea SDA
     .PIN_TYPE(6'b1010_01),
     .PULLUP(1'b0)
     ) triState (
     .PACKAGE_PIN(SDA_ADC),
     .OUTPUT_ENABLE(DSW),
     .D_OUT_0(SDA),
     .D_IN_0(SDAin)
     );
 
 //********************* Secuencia I2C 8-12 bits ********************************
 always @(posedge clk)
 begin
     Cont++;
     if(Cont==1)begin                // Secuencia I2C 8-12 bits
             Dato[0]='b0000000101;   // Start
             Dato[1]='b1001000000;   // Dir 144+W+ACK
             Dato[2]='b0000000000;   // Dat 0+ACK
             Dato[3]='b1100110000;   // Dat 204+ACK
             Dato[4]='b0000001001;   // Restart
             Dato[5]='b1001000000;   // Dir 144+W+ACK
             Dato[6]= (SELEC*8)+8;   // Sel Canal ADC USB
             Dato[7]='b0000001001;   // Restart)
             Dato[8]='b1001000100;   // Dir 145+R+ACK
             Dato[9]='b0000000010;   // DataRead USB
         if(Bits==8) begin           // Secuencia 8 bits
             Dato[10]='b0000001101;
             Ldata=11;
         end   
         if(Bits==12) begin           // Secuencia 12 bits
             Dato[10]='b0000001001;   // Restart
             Dato[11]='b1001000000;   // Dir 144+W+ACK
             Dato[12]= Dato[6]+4;     // Sel Canal ADC LSB 
             Dato[13]='b0000001001;   // Restart
             Dato[14]='b1001000100;   // Dir 145+R+ACK
             Dato[15]='b0000000010;   // DataRead LSB     
             Dato[16]='b0000001101;   // Stop       
             Ldata=17;
         end
     end
     if(Spd==100) Vel=4; if(Spd==400) Vel=1; // Establecer velocidad
     L1=37*Vel; L3=285*Vel;                  // Saltos según velocidad
 
     //********** Procesar datos de secuencia I2C *********************
     if(Cont==On && Pdata<Ldata)begin        // inicio de subframe    
         Orden=Dato[Pdata] % 2;              // Extrae bit0 de Dato[Pdata]
         Dato[Pdata] = Dato[Pdata]>>1;       // Corre 1 bit a derecha (/2)
         for(f=0;f<9;f++)begin
             Bu[f] = Dato[Pdata] % 2;        // Valor último bit    
             Dato[Pdata] = Dato[Pdata]>>1;   // Corre 1 bit a derecha (/2)
         end
         if(Orden==0) Off=Off+L3;            // Salto aplicable L3
         if(Orden==1)begin
             Norden=Bu[1]*1+Bu[2]*2+Bu[3]*4; // Calcula Nº_orden
             if(Norden==5)Off=Off+L1+L2; else Off=Off+L1;   //Duración Restart
         end
         Punt=Cont;                          // Actualiza Punt a Cont
         Pbit=0;                             // Resetea Pbit a 0
     end
     if(Cont==Off && Pdata<Ldata)begin       // Final de sub-frame
         On=Off+1;                           // Siguiente arranque sub-frame
         Pdata++;                            // Siguiente Dato[Pdata]r
         Orden=0;                            // Resetea flag Orden sig sub-frame
         Norden=0;                           // Resetea Nº Orden sig sub-frame
     end
     if(Pdata==Ldata) begin Final=Cont; Pdata++; end    // Final de frame
 
     //********** Generar Secuencia *********************************************
     if(Orden==0 && Pdata>0 && Pdata<Ldata && Pbit<=Sframe)begin     // Generación SDA, SCL 
         if(Cont==Punt+1 && Bu[8-Pbit]==1 && Pbit<8) SDA=1;          // SDA Master > Slave                           
         if(Cont==Punt+1 && Bu[8-Pbit]==0 && Pbit<9) SDA=0;          // SDA Slave > Master 
 
         if(Bu[0]==1 && Pbit==0 && Cont==Punt+1) DSW=0;              // Slave>Master Read
         if(Bu[0]==1 && Pbit==Sframe-1 && Cont==Punt+(22*Vel)) DSW=1;// Master>Slave Read                
         
         if(Bu[0]==0 && Pbit==Sframe && Cont==Punt+(7*Vel)) DSW = 0; // Slave>Master Write       
         if(Bu[0]==0 && Pbit==Sframe && Cont==Punt+(21*Vel)) DSW = 1;// Master>Slave Write                
 
         if(Cont==Punt+(7*Vel)) SCL=1;                               // Reloj a 1
         if(Cont==Punt+(22*Vel)) SCL=0;                              // Reloj a 0
 
         if(Bu[0]==1)begin
             if(Cont==Punt+(15*Vel) && SDAin==1 && Usb==1) Datafin[Pbit]=1;  // 8b USB      
             if(Cont==Punt+(15*Vel) && SDAin==1 && Usb==0) Datafin[Pbit+8]=1;// 4b LSB
             if(Cont==Punt+(30*Vel) && Pbit==Sframe) Usb=0;
         end
         if(Cont==Punt+(30*Vel)) begin Punt=Punt+(30*Vel); Pbit++; end   // Final Subframe
         if(Bu[0]==0 && DSW==0 && SDAin==1) ERR=1;                       // Error NACK
     end
 
     if(Orden==1 && Pdata<Ldata)begin
         if(Norden==1 && Cont==Punt) SDA=0;                  // Start
         if(Norden==1 && Cont==Punt+(7*Vel)) SCL=0;
         //*********************************
         if(Norden==2 && Cont==Punt) SDA=1;                  // Restart    
         if(Norden==2 && Cont==Punt+(5*Vel)) SCL=1;
         if(Norden==2 && Cont==Punt+(10*Vel)) SDA=0;
         if(Norden==2 && Cont==Punt+(15*Vel)) SCL=0;
         //*********************************
         if(Norden==3 && Cont==Punt) SCL=1;                  // Stop
         if(Norden==3 && Cont==Punt+(7*Vel)) SDA=1;
         //*********************************        
         if(Norden==4 && Cont==Punt) Reset=0;                // Reset
         if(Norden==4 && Cont==Punt+(10*Vel)) Reset=1;
         //*********************************        
         if(Norden==5 && Cont==Punt) SDA=1;                  // Restart Lrst    
         if(Norden==5 && Cont==Punt+(5*Vel)) SCL=1;
         if(Norden==5 && Cont==Punt+(10*Vel)+L2) SDA=0;
         if(Norden==5 && Cont==Punt+(15*Vel)+L2) SCL=0;
     end
 
     //******* FINAL DE FRAME I2C ***********************************************
     if(Cont==Final+1)begin
         for(f=0; f<12; f++)begin                        // Cálculo valor ADC final
             if(Datafin[11-f]==1) ADC_out = ADC_out + Multip;
             Multip=Multip<<1;
         end
         if(Bits==8) ADC_out=ADC_out>>4;                 // Reducción a 8 bits
     end
     if(Cont==Final+2) DONE=1;                           // Indicador de final de frame
     if(Cont==Final+102) DONE=0;                         // Final de indicador de frame 
     if(Cont==Final+103)begin                            // Actualizar variables
         Pdata=0; Punt=0; On=2; Off=2; Orden=0; Pbit=0; Vel=4; ERR=0;
         Usb=1; Multip=1; SCL=1; SDA=1; DSW=1; Orden=0; Norden=0; 
         for(f=0;f<12;f++) Datafin[f]=0;
     end
     if(Cont>=Final+104)begin                            // Bucle de espera a START
         Cont=Final+104; 
         if(START==1) begin Cont=0; ADC_out=0; Final=32000; Reset=1; end
     end 
 end   
 
 
endmodule
//---- Top entity
module vfe216f #(
 parameter v405b24 = "v405b24.list",
 parameter v5d1cd2 = 3,
 parameter v8fc4bd = 1,
 parameter v2c5934 = "v2c5934.list",
 parameter v23caaf = 7'h48
) (
 input vfd9fa9,
 input v4dc7fc,
 input [1:0] v7b11d4,
 input v2fc012,
 output vb80e1b,
 output [7:0] vfe18cf,
 output v8ec998
);
 localparam p1 = v23caaf;
 localparam p9 = v2c5934;
 localparam p12 = v5d1cd2;
 localparam p27 = v8fc4bd;
 localparam p33 = v405b24;
 wire [0:7] w0;
 wire w2;
 wire w3;
 wire [0:7] w4;
 wire w5;
 wire w6;
 wire [0:6] w7;
 wire [0:1] w8;
 wire w10;
 wire w11;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire [0:17] w24;
 wire [0:2] w25;
 wire [0:2] w26;
 wire w28;
 wire [0:7] w29;
 wire [0:7] w30;
 wire [0:7] w31;
 wire [0:1] w32;
 wire [0:7] w34;
 wire w35;
 wire w36;
 wire w37;
 wire w38;
 wire w39;
 wire w40;
 wire w41;
 wire w42;
 wire w43;
 wire w44;
 wire w45;
 assign vfe18cf = w0;
 assign w2 = v4dc7fc;
 assign vb80e1b = w3;
 assign w32 = v7b11d4;
 assign w35 = v2fc012;
 assign w36 = vfd9fa9;
 assign w37 = vfd9fa9;
 assign w38 = vfd9fa9;
 assign w39 = vfd9fa9;
 assign w40 = vfd9fa9;
 assign w41 = vfd9fa9;
 assign w42 = vfd9fa9;
 assign w44 = vfd9fa9;
 assign v8ec998 = w45;
 assign w10 = w6;
 assign w14 = w6;
 assign w14 = w10;
 assign w20 = w6;
 assign w20 = w10;
 assign w20 = w14;
 assign w21 = w15;
 assign w26 = w25;
 assign w37 = w36;
 assign w38 = w36;
 assign w38 = w37;
 assign w39 = w36;
 assign w39 = w37;
 assign w39 = w38;
 assign w40 = w36;
 assign w40 = w37;
 assign w40 = w38;
 assign w40 = w39;
 assign w41 = w36;
 assign w41 = w37;
 assign w41 = w38;
 assign w41 = w39;
 assign w41 = w40;
 assign w42 = w36;
 assign w42 = w37;
 assign w42 = w38;
 assign w42 = w39;
 assign w42 = w40;
 assign w42 = w41;
 assign w43 = w6;
 assign w43 = w10;
 assign w43 = w14;
 assign w43 = w20;
 assign w44 = w36;
 assign w44 = w37;
 assign w44 = w38;
 assign w44 = w39;
 assign w44 = w40;
 assign w44 = w41;
 assign w44 = w42;
 v89d234 v405ffe (
  .vb1c024(w0),
  .v39f831(w4),
  .vf892a0(w5),
  .v41eb95(w40)
 );
 v20b7db #(
  .vc5c8ea(p1)
 ) v38893d (
  .ve8dbeb(w7)
 );
 vb959c2 v270923 (
  .vb4c770(w6),
  .v3c6908(w16),
  .ve68648(w35),
  .v581b48(w37)
 );
 v8e2728 v0dff61 (
  .v10eedb(w6),
  .v2dffca(w11),
  .v0884a0(w38)
 );
 v1535f6 #(
  .vb36a78(p9)
 ) vcccfb9 (
  .vfde47f(w24),
  .v851180(w25)
 );
 vfe216f_v67db2c v67db2c (
  .op(w8),
  .i(w24),
  .value(w29),
  .regis(w30)
 );
 v117a33 #(
  .v5e4a03(p12)
 ) vf3a196 (
  .v712cd1(w16),
  .ve61673(w18),
  .v7c533e(w19),
  .vf4a676(w25),
  .vdd729a(w36)
 );
 v35f267 vf0c8f5 (
  .v0e28cb(w10),
  .vcbab45(w18)
 );
 v816138 v8221b9 (
  .v0e28cb(w11),
  .vcbab45(w13),
  .v3ca442(w23)
 );
 vb2090f vcfae5c (
  .v0e28cb(w14),
  .vcbab45(w19),
  .v3ca442(w21)
 );
 vb2090f v925465 (
  .v3ca442(w13),
  .vcbab45(w17),
  .v0e28cb(w20)
 );
 v1c7dae v4c83c4 (
  .vf54559(w15),
  .ve8318d(w22),
  .va4102a(w41)
 );
 v2b2787 v3716a6 (
  .v4dc7fc(w2),
  .vb80e1b(w3),
  .vfe18cf(w4),
  .v17d400(w5),
  .v329779(w7),
  .vc5c3a8(w8),
  .v122bbd(w15),
  .v54a38c(w17),
  .v8d0637(w29),
  .v64d54b(w31),
  .v6fc728(w39)
 );
 v1c7dae vbe08ed (
  .vf54559(w22),
  .ve8318d(w23),
  .va4102a(w42)
 );
 v359a55 v279edf (
  .v50d6c6(w28),
  .vd6b984(w30),
  .vf24dba(w31),
  .v02d898(w34)
 );
 vd9a3cf #(
  .v16d6b8(p27)
 ) v010bba (
  .v2e7398(w26),
  .v18e78c(w28)
 );
 vfbbede #(
  .vb36a78(p33)
 ) v4494aa (
  .v851180(w32),
  .vfde47f(w34)
 );
 v7eacdf v1041a6 (
  .v10eedb(w43),
  .v0884a0(w44),
  .v2dffca(w45)
 );
endmodule

//---------------------------------------------------
//-- adc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Analog-to-digital-converter
//---------------------------------------------------

module vfe216f_v67db2c (
 input [17:0] i,
 output [7:0] regis,
 output [7:0] value,
 output [1:0] op
);
 assign op = i[17:16];
 assign regis = i[15:8];
 assign value = i[7:0];
endmodule
//---- Top entity
module v89d234 #(
 parameter v422d28 = 0
) (
 input v41eb95,
 input [7:0] v39f831,
 input vf892a0,
 output [7:0] vb1c024
);
 localparam p0 = v422d28;
 wire [0:7] w1;
 wire [0:7] w2;
 wire w3;
 wire w4;
 assign vb1c024 = w1;
 assign w2 = v39f831;
 assign w3 = vf892a0;
 assign w4 = v41eb95;
 v89d234_v9148cb #(
  .INI(p0)
 ) v9148cb (
  .q(w1),
  .d(w2),
  .load(w3),
  .clk(w4)
 );
endmodule

//---------------------------------------------------
//-- Registro
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Registro de 8 bits
//---------------------------------------------------

module v89d234_v9148cb #(
 parameter INI = 0
) (
 input clk,
 input [7:0] d,
 input load,
 output [7:0] q
);
 localparam N = 8;
 
 reg [N-1:0] q = INI;
 
 always @(posedge clk)
   if (load)
     q <= d;
endmodule
//---- Top entity
module v1535f6 #(
 parameter vb36a78 = "vb36a78.list"
) (
 input [2:0] v851180,
 output [17:0] vfde47f
);
 localparam p0 = vb36a78;
 wire [0:2] w1;
 wire [0:17] w2;
 assign w1 = v851180;
 assign vfde47f = w2;
 v1535f6_v361fe9 #(
  .DATA(p0)
 ) v361fe9 (
  .i(w1),
  .q(w2)
 );
endmodule

//---------------------------------------------------
//-- mi-tabla3-18
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Circuito combinacional de 3 entradas y 18 salidas
//---------------------------------------------------

module v1535f6_v361fe9 #(
 parameter DATA = 0
) (
 input [2:0] i,
 output [17:0] q
);
 
 //-- Bits del bus de entrada
 localparam N = 3;
 
 //-- Bits del bus de salida
 localparam M = 18;
 
 //-- Calcular tamaño de la tabla
 //-- (filas) segun los bits de entrada
 localparam TAM = 2 ** N;
 
 //-- Definición de la tabla
 //-- Tabla de TAM elementos de M bits
 reg [M-1:0] tabla[0:TAM-1];
 
 //-- Read the table
 assign q = tabla[i];
 
 //-- Init table from DATA parameters
 initial begin
   if (DATA) $readmemh(DATA, tabla);
 end
endmodule
//---- Top entity
module v117a33 #(
 parameter v5e4a03 = 8
) (
 input vdd729a,
 input ve61673,
 input v7c533e,
 output [2:0] vf4a676,
 output v712cd1
);
 localparam p1 = v5e4a03;
 wire w0;
 wire w2;
 wire w3;
 wire w4;
 wire [0:2] w5;
 assign w0 = ve61673;
 assign w2 = v7c533e;
 assign w3 = vdd729a;
 assign v712cd1 = w4;
 assign vf4a676 = w5;
 v117a33_vbd6086 #(
  .M(p1)
 ) vbd6086 (
  .rst(w0),
  .cnt(w2),
  .clk(w3),
  .ov(w4),
  .q(w5)
 );
endmodule

//---------------------------------------------------
//-- Contador-3bits-up-rst
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Contador módulo M, ascendente, de 3 bits, con reset 
//---------------------------------------------------

module v117a33_vbd6086 #(
 parameter M = 0
) (
 input clk,
 input rst,
 input cnt,
 output [2:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 3; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (rst | ov)
     qi <= 2'b00;
   else
     if (cnt)
       qi <= qi + 1;
       
 assign q = qi;
 
 //-- Comprobar overflow
 assign ov = (qi == M);
     
endmodule
//---- Top entity
module v2b2787 #(
 parameter v20b6ac = "v20b6ac.list",
 parameter vdb1b8a = 3
) (
 input v6fc728,
 input v4dc7fc,
 input v876f60,
 input [6:0] v329779,
 input [7:0] v64d54b,
 input [7:0] v8d0637,
 input [1:0] vc5c3a8,
 input v54a38c,
 output vb80e1b,
 output ve89a9b,
 output [7:0] vfe18cf,
 output v17d400,
 output v122bbd
);
 localparam p1 = vdb1b8a;
 localparam p69 = v20b6ac;
 wire w0;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire [0:1] w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire [0:7] w26;
 wire w27;
 wire [0:7] w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 wire w33;
 wire w34;
 wire w35;
 wire w36;
 wire w37;
 wire w38;
 wire w39;
 wire [0:7] w40;
 wire [0:7] w41;
 wire w42;
 wire w43;
 wire [0:1] w44;
 wire [0:1] w45;
 wire [0:1] w46;
 wire [0:1] w47;
 wire [0:1] w48;
 wire w49;
 wire w50;
 wire w51;
 wire [0:6] w52;
 wire [0:7] w53;
 wire [0:7] w54;
 wire w55;
 wire w56;
 wire w57;
 wire w58;
 wire w59;
 wire w60;
 wire w61;
 wire w62;
 wire w63;
 wire w64;
 wire w65;
 wire w66;
 wire w67;
 wire w68;
 wire w70;
 assign w0 = v4dc7fc;
 assign vb80e1b = w6;
 assign ve89a9b = w9;
 assign vfe18cf = w28;
 assign w39 = v876f60;
 assign w47 = vc5c3a8;
 assign w52 = v329779;
 assign w53 = v64d54b;
 assign w54 = v8d0637;
 assign w55 = v54a38c;
 assign w56 = v6fc728;
 assign w57 = v6fc728;
 assign w58 = v6fc728;
 assign w59 = v6fc728;
 assign w60 = v6fc728;
 assign w61 = v6fc728;
 assign v17d400 = w62;
 assign w63 = v6fc728;
 assign w64 = v6fc728;
 assign w65 = v6fc728;
 assign w66 = v6fc728;
 assign w67 = v6fc728;
 assign v122bbd = w68;
 assign w23 = w10;
 assign w24 = w21;
 assign w25 = w7;
 assign w30 = w27;
 assign w35 = w33;
 assign w36 = w33;
 assign w36 = w35;
 assign w37 = w33;
 assign w37 = w35;
 assign w37 = w36;
 assign w42 = w19;
 assign w50 = w49;
 assign w57 = w56;
 assign w58 = w56;
 assign w58 = w57;
 assign w59 = w56;
 assign w59 = w57;
 assign w59 = w58;
 assign w60 = w56;
 assign w60 = w57;
 assign w60 = w58;
 assign w60 = w59;
 assign w61 = w56;
 assign w61 = w57;
 assign w61 = w58;
 assign w61 = w59;
 assign w61 = w60;
 assign w63 = w56;
 assign w63 = w57;
 assign w63 = w58;
 assign w63 = w59;
 assign w63 = w60;
 assign w63 = w61;
 assign w64 = w56;
 assign w64 = w57;
 assign w64 = w58;
 assign w64 = w59;
 assign w64 = w60;
 assign w64 = w61;
 assign w64 = w63;
 assign w65 = w56;
 assign w65 = w57;
 assign w65 = w58;
 assign w65 = w59;
 assign w65 = w60;
 assign w65 = w61;
 assign w65 = w63;
 assign w65 = w64;
 assign w66 = w56;
 assign w66 = w57;
 assign w66 = w58;
 assign w66 = w59;
 assign w66 = w60;
 assign w66 = w61;
 assign w66 = w63;
 assign w66 = w64;
 assign w66 = w65;
 assign w67 = w56;
 assign w67 = w57;
 assign w67 = w58;
 assign w67 = w59;
 assign w67 = w60;
 assign w67 = w61;
 assign w67 = w63;
 assign w67 = w64;
 assign w67 = w65;
 assign w67 = w66;
 assign w70 = w31;
 ve1a052 v3a7ca3 (
  .v6b2a2c(w0),
  .vba979e(w5),
  .v248807(w8),
  .v790e82(w10)
 );
 v23e63b #(
  .v75b2bb(p1)
 ) vb9b54e (
  .vd78d57(w2),
  .vd94b57(w13),
  .v3fd15e(w17),
  .v2379d3(w31),
  .vd92cd6(w55),
  .vcc8dd9(w56)
 );
 v8ba640 v29c916 (
  .v22d89c(w9),
  .vd0f6aa(w10),
  .vcfa9bb(w11),
  .vdff742(w35),
  .v30ed4b(w39),
  .v5dd22f(w65)
 );
 vfc9dac v07820e (
  .v8b19dd(w18),
  .v64d863(w19),
  .v3f8943(w43)
 );
 v35f267 va4427d (
  .v0e28cb(w19),
  .vcbab45(w34)
 );
 v56e0da v263adc (
  .v4fef26(w22),
  .v8fcf35(w24),
  .vd50ef8(w26),
  .v54c0b0(w63)
 );
 vb2090f va6a155 (
  .v3ca442(w20),
  .vcbab45(w21),
  .v0e28cb(w25)
 );
 v35f267 v2f4ce6 (
  .vcbab45(w20),
  .v0e28cb(w36)
 );
 v42ebf7 v478781 (
  .v9afc1f(w21),
  .ve8318d(w22),
  .vf54559(w23),
  .va4102a(w61)
 );
 vc146d4 v423c53 (
  .vc42023(w7),
  .v0e6505(w8),
  .v190b0b(w11),
  .vdb8ccc(w12),
  .v994809(w27),
  .v364b20(w37),
  .vf5404b(w60)
 );
 v89d234 v405ffe (
  .v39f831(w26),
  .vf892a0(w27),
  .vb1c024(w28),
  .v41eb95(w64)
 );
 v1c7dae vd9300d (
  .vf54559(w29),
  .ve8318d(w62),
  .va4102a(w66)
 );
 vb2090f vaa1091 (
  .vcbab45(w29),
  .v0e28cb(w30),
  .v3ca442(w32)
 );
 v3e4cef v0d19b0 (
  .ve41ea9(w3),
  .v610d09(w4),
  .v24cab2(w5),
  .vfb639d(w6),
  .v334d55(w16),
  .v6a8d27(w31),
  .v1b95b1(w58)
 );
 v35f267 va994d0 (
  .vcbab45(w32),
  .v0e28cb(w33)
 );
 v5cc6ec v0b57c9 (
  .vc93bbe(w33),
  .vb186da(w34),
  .v381ebf(w38),
  .v50d6c6(w50)
 );
 v725b7e v1b392a (
  .v9fb85f(w38)
 );
 v2b2787_v0fa555 v0fa555 (
  .b(w40),
  .w(w49),
  .a(w52)
 );
 vf1c84b vb60f13 (
  .v69afd7(w2),
  .v9c7419(w3),
  .v7da9df(w4),
  .v945c79(w7),
  .v1a1b36(w12),
  .v1368c3(w14),
  .v4c9f5f(w15),
  .vec0e14(w17),
  .vef36bc(w41),
  .v1c6ca1(w57)
 );
 v548334 ve8c896 (
  .ve9b26f(w13),
  .v8762e7(w14),
  .v650051(w15),
  .vea582e(w16),
  .v80c1bb(w18),
  .vf190ba(w44),
  .v49b5f9(w59)
 );
 v56cc18 vdc270f (
  .v3d1227(w40),
  .v3fb88b(w41),
  .vda0bfd(w42),
  .v50d6c6(w43),
  .v062092(w53),
  .v21e136(w54)
 );
 veebee1 v39309f (
  .v7fb9b3(w44),
  .v340b68(w45),
  .vc9d156(w46),
  .v50d6c6(w51)
 );
 v945d5c vb7cc31 (
  .v2978f0(w45)
 );
 vceff2d v2dc4e3 (
  .v2978f0(w46)
 );
 va47586 #(
  .vb36a78(p69)
 ) vb4821c (
  .v851180(w47),
  .vfde47f(w48)
 );
 vfc9dac ve5aef5 (
  .v8b19dd(w48),
  .v64d863(w49),
  .v3f8943(w51)
 );
 v1c7dae vfda31a (
  .va4102a(w67),
  .ve8318d(w68),
  .vf54559(w70)
 );
endmodule

//---------------------------------------------------
//-- i2c
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Controlador i2c que permite 3 transacciones: escritura, lectura y selección
//---------------------------------------------------

module v2b2787_v0fa555 (
 input [6:0] a,
 input w,
 output [7:0] b
);
 assign b = {a,w};
endmodule
//---- Top entity
module ve1a052 (
 input v6b2a2c,
 input v248807,
 input vba979e,
 output v790e82
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v6b2a2c;
 assign w1 = v248807;
 assign w2 = vba979e;
 assign v790e82 = w3;
 ve1a052_v43ad2d v43ad2d (
  .pin(w0),
  .oe(w1),
  .dout(w2),
  .din(w3)
 );
endmodule

//---------------------------------------------------
//-- Tri-state
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Tri-state logic block
//---------------------------------------------------

module ve1a052_v43ad2d (
 input pin,
 input oe,
 input dout,
 output din
);
   SB_IO #(
       .PIN_TYPE(6'b1010_01),
       .PULLUP(1'b0)
   ) triState (
       .PACKAGE_PIN(pin),
       .OUTPUT_ENABLE(oe),
       .D_OUT_0(dout),
       .D_IN_0(din)
   );
endmodule
//---- Top entity
module v23e63b #(
 parameter vf8c69c = 1,
 parameter v75b2bb = 2,
 parameter vd3b0b7 = 1
) (
 input vcc8dd9,
 input v2379d3,
 input vd92cd6,
 output vd78d57,
 output v3fd15e,
 output vd94b57
);
 localparam p1 = v75b2bb;
 localparam p4 = vd3b0b7;
 localparam p5 = vf8c69c;
 wire w0;
 wire w2;
 wire w3;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 assign vd78d57 = w0;
 assign v3fd15e = w2;
 assign w6 = v2379d3;
 assign w9 = vd92cd6;
 assign w10 = v2379d3;
 assign w11 = vcc8dd9;
 assign w12 = vcc8dd9;
 assign w13 = vcc8dd9;
 assign w14 = vcc8dd9;
 assign vd94b57 = w15;
 assign w17 = vcc8dd9;
 assign w8 = w0;
 assign w10 = w6;
 assign w12 = w11;
 assign w13 = w11;
 assign w13 = w12;
 assign w14 = w11;
 assign w14 = w12;
 assign w14 = w13;
 assign w16 = w3;
 assign w17 = w11;
 assign w17 = w12;
 assign w17 = w13;
 assign w17 = w14;
 vb959c2 #(
  .v679341(p5)
 ) vd7cb01 (
  .vb4c770(w0),
  .ve68648(w6),
  .v3c6908(w9),
  .v581b48(w11)
 );
 v3b630a #(
  .v187a47(p1)
 ) v65ebbc (
  .va9e2af(w3),
  .v6e1dd1(w7),
  .v5688a8(w13)
 );
 vb959c2 #(
  .v679341(p4)
 ) ve13051 (
  .vb4c770(w2),
  .v3c6908(w3),
  .ve68648(w10),
  .v581b48(w14)
 );
 v7eacdf v2908cb (
  .v2dffca(w7),
  .v10eedb(w8),
  .v0884a0(w12)
 );
 v1c7dae v0241a5 (
  .ve8318d(w15),
  .vf54559(w16),
  .va4102a(w17)
 );
endmodule

//---------------------------------------------------
//-- i2c-start
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Generar la condición de start en el bus I2C
//---------------------------------------------------
//---- Top entity
module v3b630a #(
 parameter v187a47 = 100
) (
 input v5688a8,
 input v6e1dd1,
 output veabfb2,
 output va9e2af
);
 localparam p4 = v187a47;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v6e1dd1;
 assign veabfb2 = w1;
 assign va9e2af = w2;
 assign w3 = v5688a8;
 v3b630a_v3140f5 #(
  .US(p4)
 ) v3140f5 (
  .start(w0),
  .p(w1),
  .tic(w2),
  .clk(w3)
 );
endmodule

//---------------------------------------------------
//-- timer-usec
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Temporizador en microsegundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar
//---------------------------------------------------

module v3b630a_v3140f5 #(
 parameter US = 0
) (
 input clk,
 input start,
 output p,
 output tic
);
 //localparam US;
 
 //-- Constante para dividir y obtener una señal de 
 //-- periodo 1 micro-segundo
 localparam M = 12;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el corazon
 wire rst_heart;
 
 //-- Overflow del temporizador del corazon
 wire ov_heart;
 
 //-- Habilitacion del corazon
 wire ena;
 
 //-- Tics del corazon
 wire tic_heart;
 
 //-- Contador del corazon
 reg [N-1:0] heart=0;
 
 always @(posedge clk)
   if (rst_heart)
     heart <= 0;
   else
     heart <= heart + 1;
 
 //-- Overflow del contador
 assign ov_heart = (heart == M-1);
 
 //-- La salida del corazon es la señal de overflow
 assign tic_heart = ov_heart;
 
 //-- Reset del corazon
 assign rst_heart =~ena | ov_heart;
 
 
 
 //--------------------------------------------
 //-- Contador de tics
 //--------------------------------------------
 
 //-- Calcular el numero de bits para almacenar US tics
 localparam CB = $clog2(US);
 
 reg [CB:0] counter = 0;
 
 //-- Overflow del contador
 wire ov;
 
 //-- Señal de reset del contador
 wire rst;
 
 always @(posedge clk)
 if (rst)
   counter <= 0;
 else
   if (tic_heart)
     counter <= counter + 1;
 
 //-- Evento: cuenta máxima de tics alcanzada
 assign ov = (counter == US);
 
 //---------------------------------------
 //-- Biestable de estado del timer
 //-- 0: Apagado  
 //-- 1: Funcionando
 reg q = 0;
 
 always @(posedge clk)
   if (start)
     q <= 1'b1;
   else if (rst)
     q<=1'b0;
     
 //-- Lógica de reset
 //En función de la entrada, el estado y  
 // el overflow se inicializa el contador y 
 // se habilita el corazón de tics
 assign rst = ~q | ov | start;
 assign ena = ~rst;
 
 //-- Salida de pulso
 assign p = q;
 
 //-- Salida de tic
 //-- Saca un tic cuando ha finalizado la cuenta
 assign tic = ov;
 
endmodule
//---- Top entity
module v8ba640 (
 input v5dd22f,
 input vd0f6aa,
 input vcfa9bb,
 input vdff742,
 input v30ed4b,
 output v22d89c
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 assign v22d89c = w0;
 assign w4 = vd0f6aa;
 assign w5 = vdff742;
 assign w6 = vcfa9bb;
 assign w7 = v30ed4b;
 assign w8 = v5dd22f;
 assign w9 = v5dd22f;
 assign w9 = w8;
 vb2090f v8826f2 (
  .vcbab45(w2),
  .v3ca442(w3),
  .v0e28cb(w4)
 );
 vb959c2 v623a62 (
  .vb4c770(w0),
  .ve68648(w1),
  .v3c6908(w7),
  .v581b48(w9)
 );
 v8e2728 vf8bd2a (
  .v2dffca(w1),
  .v10eedb(w2),
  .v0884a0(w8)
 );
 vb2090f v9608b2 (
  .vcbab45(w3),
  .v3ca442(w5),
  .v0e28cb(w6)
 );
endmodule

//---------------------------------------------------
//-- i2c-nak
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Detección de los ACKs del esclavo. Si no se recibe, se activa la salida NAK
//---------------------------------------------------
//---- Top entity
module v56e0da #(
 parameter v27bfca = 0
) (
 input v54c0b0,
 input v4fef26,
 input v8fcf35,
 output v0d3330,
 output [7:0] vd50ef8
);
 localparam p0 = v27bfca;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire [0:7] w5;
 assign v0d3330 = w1;
 assign w2 = v4fef26;
 assign w3 = v8fcf35;
 assign w4 = v54c0b0;
 assign vd50ef8 = w5;
 v56e0da_v56d51d #(
  .INI(p0)
 ) v56d51d (
  .so(w1),
  .si(w2),
  .shift(w3),
  .clk(w4),
  .q(w5)
 );
endmodule

//---------------------------------------------------
//-- Registro-desplazamiento
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Registro de desplazamiento (izquierda) de 8 bits
//---------------------------------------------------

module v56e0da_v56d51d #(
 parameter INI = 0
) (
 input clk,
 input si,
 input shift,
 output so,
 output [7:0] q
);
 //-- Numero de bits el registros de desplazamiento
 localparam N = 8;
 
 reg [N-1:0] q = INI;
 
 always @(posedge clk)
   if (shift)
     q <= {q[N-2:0], si};
     
 //-- Sacar el bit de mayor peso por serial-out    
 assign so = q[N-1];
endmodule
//---- Top entity
module v42ebf7 #(
 parameter v71e305 = 0
) (
 input va4102a,
 input vf54559,
 input v9afc1f,
 output ve8318d
);
 localparam p2 = v71e305;
 wire w0;
 wire w1;
 wire w3;
 wire w4;
 assign w0 = va4102a;
 assign ve8318d = w1;
 assign w3 = vf54559;
 assign w4 = v9afc1f;
 v42ebf7_vb8adf8 #(
  .INI(p2)
 ) vb8adf8 (
  .clk(w0),
  .q(w1),
  .d(w3),
  .load(w4)
 );
endmodule

//---------------------------------------------------
//-- Biestable-D
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Biestable de datos (Tipo D). Cuando se recibe un tic por load se captura el dato
//---------------------------------------------------

module v42ebf7_vb8adf8 #(
 parameter INI = 0
) (
 input clk,
 input d,
 input load,
 output q
);
 reg q = INI;
 always @(posedge clk)
   if (load)
     q <= d;
endmodule
//---- Top entity
module vc146d4 #(
 parameter ve8153a = 1,
 parameter vd0eb71 = 9,
 parameter v56a06a = 5
) (
 input vf5404b,
 input vc42023,
 input v364b20,
 input vdb8ccc,
 output v190b0b,
 output v994809,
 output v0e6505
);
 localparam p0 = vd0eb71;
 localparam p1 = v56a06a;
 localparam p9 = ve8153a;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 assign v0e6505 = w8;
 assign w10 = vdb8ccc;
 assign w11 = v364b20;
 assign w12 = vc42023;
 assign w13 = vdb8ccc;
 assign v190b0b = w14;
 assign w15 = vf5404b;
 assign w16 = vf5404b;
 assign w17 = vf5404b;
 assign w18 = vf5404b;
 assign v994809 = w19;
 assign w4 = w2;
 assign w13 = w10;
 assign w14 = w3;
 assign w16 = w15;
 assign w17 = w15;
 assign w17 = w16;
 assign w18 = w15;
 assign w18 = w16;
 assign w18 = w17;
 assign w19 = w2;
 assign w19 = w4;
 vd014cb #(
  .v5e4a03(p0)
 ) vf11cbd (
  .v712cd1(w2),
  .v7c533e(w12),
  .vdd729a(w17),
  .ve61673(w20)
 );
 v3b630a #(
  .v187a47(p1)
 ) ve93ca3 (
  .v6e1dd1(w2),
  .veabfb2(w3),
  .v5688a8(w15)
 );
 v35f267 v17c9d1 (
  .v0e28cb(w3),
  .vcbab45(w5)
 );
 v42ebf7 #(
  .v71e305(p9)
 ) v1113ff (
  .ve8318d(w7),
  .v9afc1f(w10),
  .vf54559(w11),
  .va4102a(w16)
 );
 vb959c2 v1d8b2d (
  .ve68648(w4),
  .vb4c770(w6),
  .v3c6908(w13),
  .v581b48(w18)
 );
 v5cc6ec v809f57 (
  .vb186da(w5),
  .v381ebf(w6),
  .v50d6c6(w7),
  .vc93bbe(w8)
 );
 vd30ca9 vffca7a (
  .v9fb85f(w20)
 );
endmodule

//---------------------------------------------------
//-- i2c-io
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Gestion de la entrada/salida en el bus i2c
//---------------------------------------------------
//---- Top entity
module vd014cb #(
 parameter v5e4a03 = 256
) (
 input vdd729a,
 input ve61673,
 input v7c533e,
 output [7:0] vb86fe4,
 output v712cd1
);
 localparam p1 = v5e4a03;
 wire w0;
 wire w2;
 wire w3;
 wire w4;
 wire [0:7] w5;
 assign w0 = ve61673;
 assign w2 = v7c533e;
 assign w3 = vdd729a;
 assign v712cd1 = w4;
 assign vb86fe4 = w5;
 vd014cb_vbd6086 #(
  .M(p1)
 ) vbd6086 (
  .rst(w0),
  .cnt(w2),
  .clk(w3),
  .ov(w4),
  .q(w5)
 );
endmodule

//---------------------------------------------------
//-- Contador-8bits-up-rst
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Contador módulo M, ascendente, de 8 bits, con reset 
//---------------------------------------------------

module vd014cb_vbd6086 #(
 parameter M = 0
) (
 input clk,
 input rst,
 input cnt,
 output [7:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 8; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (rst | ov)
     qi <= 0;
   else
     if (cnt)
       qi <= qi + 1;
       
 assign q = qi;
 
 //-- Comprobar overflow
 assign ov = (qi == M);
     
endmodule
//---- Top entity
module v5cc6ec (
 input vb186da,
 input v381ebf,
 input v50d6c6,
 output vc93bbe
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v50d6c6;
 assign vc93bbe = w1;
 assign w2 = v381ebf;
 assign w3 = vb186da;
 v5cc6ec_ve4e0df ve4e0df (
  .sel(w0),
  .o(w1),
  .i0(w2),
  .i1(w3)
 );
endmodule

//---------------------------------------------------
//-- Mux 2 a 1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Multiplexor de 2 a 1
//---------------------------------------------------

module v5cc6ec_ve4e0df (
 input i1,
 input i0,
 input sel,
 output o
);
 //-- Multiplexor de 2 a 1, 
 //-- de 8 bits
 
 reg _o;
 
 always @(*) begin
     case(sel)
         0: _o = i0;
         1: _o = i1;
         default: _o = i0;
     endcase
 end
 
 assign o = _o;
 
endmodule
//---- Top entity
module vd30ca9 (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 vd30ca9_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

//---------------------------------------------------
//-- bit-0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Constant bit 0
//---------------------------------------------------

module vd30ca9_vb2eccd (
 output q
);
 //-- Constant bit-0
 assign q = 1'b0;
 
 
endmodule
//---- Top entity
module v3e4cef #(
 parameter vd75665 = 5,
 parameter ve0391a = 2
) (
 input v1b95b1,
 input ve41ea9,
 input v610d09,
 input v334d55,
 output v24cab2,
 output vfb639d,
 output v6a8d27
);
 localparam p3 = ve0391a;
 localparam p15 = vd75665;
 wire w0;
 wire w1;
 wire w2;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 assign vfb639d = w0;
 assign v24cab2 = w4;
 assign v6a8d27 = w6;
 assign w8 = v610d09;
 assign w9 = ve41ea9;
 assign w11 = v1b95b1;
 assign w12 = v1b95b1;
 assign w13 = v1b95b1;
 assign w14 = v1b95b1;
 assign w16 = v334d55;
 assign w19 = v1b95b1;
 assign w22 = v1b95b1;
 assign w7 = w2;
 assign w12 = w11;
 assign w13 = w11;
 assign w13 = w12;
 assign w14 = w11;
 assign w14 = w12;
 assign w14 = w13;
 assign w18 = w17;
 assign w19 = w11;
 assign w19 = w12;
 assign w19 = w13;
 assign w19 = w14;
 assign w20 = w10;
 assign w21 = w6;
 assign w22 = w11;
 assign w22 = w12;
 assign w22 = w13;
 assign w22 = w14;
 assign w22 = w19;
 vb959c2 v2301a0 (
  .vb4c770(w1),
  .v3c6908(w10),
  .v581b48(w12),
  .ve68648(w17)
 );
 v816138 v4f5af9 (
  .vcbab45(w0),
  .v3ca442(w1),
  .v0e28cb(w8)
 );
 vb959c2 v8c0d08 (
  .ve68648(w2),
  .vb4c770(w5),
  .v581b48(w14),
  .v3c6908(w20)
 );
 v3b630a #(
  .v187a47(p3)
 ) vd80ff7 (
  .va9e2af(w2),
  .v5688a8(w11),
  .v6e1dd1(w18)
 );
 v816138 vb4f732 (
  .vcbab45(w4),
  .v0e28cb(w5),
  .v3ca442(w9)
 );
 v1c7dae v947bc6 (
  .ve8318d(w6),
  .vf54559(w7),
  .va4102a(w13)
 );
 v3b630a #(
  .v187a47(p15)
 ) vdc731d (
  .v6e1dd1(w16),
  .va9e2af(w17),
  .v5688a8(w19)
 );
 v1c7dae v44f3ab (
  .ve8318d(w10),
  .vf54559(w21),
  .va4102a(w22)
 );
endmodule

//---------------------------------------------------
//-- i2c-stop
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Generar una condición de parada en el bus i2c
//---------------------------------------------------
//---- Top entity
module vf1c84b #(
 parameter vd32d28 = 121,
 parameter vea5b6c = 9,
 parameter v9ee7b6 = 2,
 parameter vab6018 = 5
) (
 input v1c6ca1,
 input v69afd7,
 input vec0e14,
 input [7:0] vef36bc,
 input v1368c3,
 output v9c7419,
 output v7da9df,
 output v945c79,
 output v1a1b36,
 output v4c9f5f
);
 localparam p0 = vea5b6c;
 localparam p1 = vd32d28;
 localparam p2 = vab6018;
 localparam p5 = v9ee7b6;
 wire w3;
 wire w4;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 wire w29;
 wire [0:7] w30;
 assign v7da9df = w6;
 assign v9c7419 = w8;
 assign w10 = v69afd7;
 assign w11 = v1368c3;
 assign w12 = vec0e14;
 assign w16 = v1c6ca1;
 assign w17 = v1c6ca1;
 assign w18 = v1c6ca1;
 assign w19 = v1c6ca1;
 assign w20 = v1c6ca1;
 assign v4c9f5f = w24;
 assign v945c79 = w25;
 assign w26 = v1368c3;
 assign v1a1b36 = w26;
 assign w27 = v1368c3;
 assign w28 = v1368c3;
 assign w30 = vef36bc;
 assign w14 = w13;
 assign w15 = w13;
 assign w15 = w14;
 assign w17 = w16;
 assign w18 = w16;
 assign w18 = w17;
 assign w19 = w16;
 assign w19 = w17;
 assign w19 = w18;
 assign w20 = w16;
 assign w20 = w17;
 assign w20 = w18;
 assign w20 = w19;
 assign w25 = w4;
 assign w26 = w11;
 assign w27 = w11;
 assign w27 = w26;
 assign w28 = w11;
 assign w28 = w26;
 assign w28 = w27;
 v3b630a #(
  .v187a47(p2)
 ) vdd2366 (
  .v6e1dd1(w4),
  .veabfb2(w7),
  .v5688a8(w20),
  .va9e2af(w23)
 );
 v21cfcc vbd59f1 (
  .v9fb85f(w29)
 );
 v3b630a #(
  .v187a47(p5)
 ) v9a0bec (
  .va9e2af(w4),
  .v6e1dd1(w13),
  .v5688a8(w19)
 );
 v816138 v163e96 (
  .vcbab45(w6),
  .v3ca442(w7),
  .v0e28cb(w12)
 );
 v816138 ve52c88 (
  .vcbab45(w8),
  .v0e28cb(w9),
  .v3ca442(w10)
 );
 v086d7d #(
  .v7fc9e0(p0),
  .vd8d9ac(p1)
 ) v0f7762 (
  .v37ae70(w11),
  .ved4c0c(w13),
  .vb0a8d8(w18),
  .vffcbf8(w22)
 );
 v35f267 vf276f1 (
  .vcbab45(w21),
  .v0e28cb(w22)
 );
 vb2090f v073720 (
  .v3ca442(w21),
  .v0e28cb(w23),
  .vcbab45(w24)
 );
 v45f630 vdaad51 (
  .vf54559(w3),
  .ve8318d(w9),
  .v9afc1f(w15),
  .va4102a(w17),
  .vbbc50c(w27)
 );
 v53847c v1bd8df (
  .v0d3330(w3),
  .v7d29fb(w14),
  .v4a6801(w16),
  .v9bfaa9(w28),
  .v3ba3e6(w29),
  .v67ccbf(w30)
 );
endmodule

//---------------------------------------------------
//-- i2c-data
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Inyectar un byte en el bus i2c
//---------------------------------------------------
//---- Top entity
module v086d7d #(
 parameter vd8d9ac = 15,
 parameter v7fc9e0 = 24
) (
 input vb0a8d8,
 input v37ae70,
 output ved4c0c,
 output vffcbf8,
 output v5255d3
);
 localparam p1 = vd8d9ac;
 localparam p6 = v7fc9e0;
 wire w0;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 assign w7 = v37ae70;
 assign w8 = vb0a8d8;
 assign w9 = vb0a8d8;
 assign w10 = vb0a8d8;
 assign ved4c0c = w11;
 assign v5255d3 = w12;
 assign vffcbf8 = w13;
 assign w5 = w0;
 assign w9 = w8;
 assign w10 = w8;
 assign w10 = w9;
 assign w11 = w3;
 assign w12 = w2;
 assign w13 = w0;
 assign w13 = w5;
 vb959c2 v560ce2 (
  .vb4c770(w0),
  .v3c6908(w2),
  .ve68648(w7),
  .v581b48(w8)
 );
 vd585a5 #(
  .vfb06ae(p1)
 ) v6fd693 (
  .vb27aaa(w0),
  .v2a8434(w3),
  .vac0eb2(w9)
 );
 vd0fde2 #(
  .v5e4a03(p6)
 ) v427093 (
  .v712cd1(w2),
  .v7c533e(w3),
  .ve61673(w4),
  .vdd729a(w10)
 );
 v35f267 vfb2363 (
  .vcbab45(w4),
  .v0e28cb(w5)
 );
endmodule

//---------------------------------------------------
//-- Heart-tics
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Corazón  finito de tics. Emitir num tics cuando se recibe un tic de start
//---------------------------------------------------
//---- Top entity
module vd585a5 #(
 parameter vfb06ae = 15
) (
 input vac0eb2,
 input vb27aaa,
 output v2a8434
);
 localparam p2 = vfb06ae;
 wire w0;
 wire w1;
 wire w3;
 assign v2a8434 = w0;
 assign w1 = vac0eb2;
 assign w3 = vb27aaa;
 vd585a5_v6cac2f #(
  .TICS(p2)
 ) v6cac2f (
  .o(w0),
  .clk(w1),
  .ena(w3)
 );
endmodule

//---------------------------------------------------
//-- Corazon-tics
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Corazón de bombeo de tics, cuyo periodo está especificado en tics también
//---------------------------------------------------

module vd585a5_v6cac2f #(
 parameter TICS = 0
) (
 input clk,
 input ena,
 output o
);
 
 
 //-- Los TICs son directamente el módulo del contador
 localparam M = TICS;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 wire ov;
 assign ov = (divcounter == M-1);
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = ov | (ena == 0);
 
 //-- La salida es la señal de overflow
 assign o = ov;
 
 
 
 
endmodule
//---- Top entity
module v45f630 #(
 parameter v71e305 = 0
) (
 input va4102a,
 input vbbc50c,
 input vf54559,
 input v9afc1f,
 output ve8318d
);
 localparam p2 = v71e305;
 wire w0;
 wire w1;
 wire w3;
 wire w4;
 wire w5;
 assign w0 = va4102a;
 assign ve8318d = w1;
 assign w3 = vf54559;
 assign w4 = v9afc1f;
 assign w5 = vbbc50c;
 v45f630_vb8adf8 #(
  .INI(p2)
 ) vb8adf8 (
  .clk(w0),
  .q(w1),
  .d(w3),
  .load(w4),
  .rst(w5)
 );
endmodule

//---------------------------------------------------
//-- Biestable-D
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Biestable de datos (Tipo D). Cuando se recibe un tic por load se captura el dato
//---------------------------------------------------

module v45f630_vb8adf8 #(
 parameter INI = 0
) (
 input clk,
 input rst,
 input d,
 input load,
 output q
);
 reg q = INI;
 always @(posedge clk)
   if (rst)
     q <= INI;
   else if (load)
     q <= d;
endmodule
//---- Top entity
module v548334 (
 input v49b5f9,
 input [1:0] vf190ba,
 input v650051,
 input ve9b26f,
 output v8762e7,
 output vb50f83,
 output [1:0] v80c1bb,
 output vea582e
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire [0:1] w22;
 wire [0:1] w23;
 assign v8762e7 = w2;
 assign w7 = ve9b26f;
 assign w8 = v650051;
 assign w9 = v650051;
 assign vea582e = w14;
 assign w15 = v49b5f9;
 assign w16 = v49b5f9;
 assign w17 = v49b5f9;
 assign w18 = v49b5f9;
 assign w19 = v49b5f9;
 assign w20 = v49b5f9;
 assign vb50f83 = w21;
 assign v80c1bb = w22;
 assign w23 = vf190ba;
 assign w4 = w0;
 assign w9 = w8;
 assign w12 = w0;
 assign w12 = w4;
 assign w13 = w0;
 assign w13 = w4;
 assign w13 = w12;
 assign w16 = w15;
 assign w17 = w15;
 assign w17 = w16;
 assign w18 = w15;
 assign w18 = w16;
 assign w18 = w17;
 assign w19 = w15;
 assign w19 = w16;
 assign w19 = w17;
 assign w19 = w18;
 assign w20 = w15;
 assign w20 = w16;
 assign w20 = w17;
 assign w20 = w18;
 assign w20 = w19;
 assign w21 = w0;
 assign w21 = w4;
 assign w21 = w12;
 assign w21 = w13;
 vb959c2 v587931 (
  .vb4c770(w0),
  .ve68648(w7),
  .v3c6908(w10),
  .v581b48(w16)
 );
 v8e2728 v756c58 (
  .v10eedb(w0),
  .v2dffca(w1),
  .v0884a0(w15)
 );
 v816138 vac01fb (
  .v0e28cb(w1),
  .vcbab45(w3),
  .v3ca442(w5)
 );
 vb2090f vdae2b4 (
  .vcbab45(w2),
  .v0e28cb(w3),
  .v3ca442(w4)
 );
 v1c7dae vb9e6ad (
  .ve8318d(w5),
  .vf54559(w6),
  .va4102a(w19)
 );
 v1c7dae v378e34 (
  .ve8318d(w6),
  .vf54559(w8),
  .va4102a(w17)
 );
 v35f267 vb4a035 (
  .vcbab45(w11),
  .v0e28cb(w12)
 );
 v7eacdf v77d7c8 (
  .v10eedb(w13),
  .v2dffca(w14),
  .v0884a0(w20)
 );
 vb82ff1 v74dd34 (
  .v7c533e(w9),
  .v712cd1(w10),
  .ve61673(w11),
  .vdd729a(w18),
  .vd76104(w22),
  .v62eb51(w23)
 );
endmodule

//---------------------------------------------------
//-- machine-loop
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Máquina para hacer repeticiones
//---------------------------------------------------
//---- Top entity
module vb82ff1 (
 input vdd729a,
 input ve61673,
 input [1:0] v62eb51,
 input v7c533e,
 output [1:0] vd76104,
 output v712cd1
);
 wire [0:1] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire [0:1] w5;
 assign vd76104 = w0;
 assign w1 = ve61673;
 assign w2 = v7c533e;
 assign w3 = vdd729a;
 assign v712cd1 = w4;
 assign w5 = v62eb51;
 vb82ff1_vbd6086 vbd6086 (
  .q(w0),
  .rst(w1),
  .cnt(w2),
  .clk(w3),
  .ov(w4),
  .mod(w5)
 );
endmodule

//---------------------------------------------------
//-- Contador-2bits-up-rst-mod-M
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Contador módulo M, ascendente, de 2 bits, con reset 
//---------------------------------------------------

module vb82ff1_vbd6086 (
 input clk,
 input rst,
 input [1:0] mod,
 input cnt,
 output [1:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 2; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (rst | ov)
     qi <= 2'b00;
   else
     if (cnt)
       qi <= qi + 1;
       
 assign q = qi;
 
 //-- Comprobar overflow
 assign ov = (qi == mod);
     
endmodule
//---- Top entity
module v56cc18 (
 input [7:0] vbdd51f,
 input [7:0] v21e136,
 input [7:0] v062092,
 input [7:0] v3d1227,
 input v50d6c6,
 input vda0bfd,
 output [7:0] v3fb88b
);
 wire w0;
 wire w1;
 wire [0:7] w2;
 wire [0:7] w3;
 wire [0:7] w4;
 wire [0:7] w5;
 wire [0:7] w6;
 assign w0 = vda0bfd;
 assign w1 = v50d6c6;
 assign v3fb88b = w2;
 assign w3 = v3d1227;
 assign w4 = v062092;
 assign w5 = v21e136;
 assign w6 = vbdd51f;
 v56cc18_ve4e0df ve4e0df (
  .s0(w0),
  .s1(w1),
  .o(w2),
  .i0(w3),
  .i1(w4),
  .i2(w5),
  .i3(w6)
 );
endmodule

//---------------------------------------------------
//-- Mux 4 a 1 de 8 bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Multiplexor de 4 a 1 de 8 bits
//---------------------------------------------------

module v56cc18_ve4e0df (
 input [7:0] i3,
 input [7:0] i2,
 input [7:0] i1,
 input [7:0] i0,
 input s1,
 input s0,
 output [7:0] o
);
 //-- Multiplexor de 4 a 1, 
 //-- de 8 bits
 
 wire [1:0] sel = {s1, s0};
 
 assign o = (sel == 2'b00) ? i0 :
            (sel == 2'b01) ? i1 :
            (sel == 2'b10) ? i2 : i3;
 
 
endmodule
//---- Top entity
module veebee1 (
 input [1:0] vc9d156,
 input [1:0] v340b68,
 input v50d6c6,
 output [1:0] v7fb9b3
);
 wire w0;
 wire [0:1] w1;
 wire [0:1] w2;
 wire [0:1] w3;
 assign w0 = v50d6c6;
 assign v7fb9b3 = w1;
 assign w2 = vc9d156;
 assign w3 = v340b68;
 veebee1_ve4e0df ve4e0df (
  .sel(w0),
  .o(w1),
  .i1(w2),
  .i0(w3)
 );
endmodule

//---------------------------------------------------
//-- Mux 2 a 1 de 2 bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Multiplexor de 2 a 1 de 2 bits
//---------------------------------------------------

module veebee1_ve4e0df (
 input [1:0] i1,
 input [1:0] i0,
 input sel,
 output [1:0] o
);
 //-- Multiplexor de 2 a 1, 
 //-- de 2 bits
 
 reg [1:0] o;
 
 always @(*) begin
     case(sel)
         0: o = i0;
         1: o = i1;
         default: o = i0;
     endcase
 end
 
 
endmodule
//---- Top entity
module v945d5c #(
 parameter vfffc23 = 2
) (
 output [1:0] v2978f0
);
 localparam p1 = vfffc23;
 wire [0:1] w0;
 assign v2978f0 = w0;
 v157753 #(
  .vc5c8ea(p1)
 ) v9b88e7 (
  .v4ffce0(w0)
 );
endmodule

//---------------------------------------------------
//-- Valor_2_2bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor constante 2 para bus de 2 bits
//---------------------------------------------------
//---- Top entity
module v157753 #(
 parameter vc5c8ea = 0
) (
 output [1:0] v4ffce0
);
 localparam p1 = vc5c8ea;
 wire [0:1] w0;
 assign v4ffce0 = w0;
 v157753_v465065 #(
  .VALUE(p1)
 ) v465065 (
  .k(w0)
 );
endmodule

//---------------------------------------------------
//-- Constante-2bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor genérico constante, de 2 bits. Su valor se introduce como parámetro. Por defecto vale 0
//---------------------------------------------------

module v157753_v465065 #(
 parameter VALUE = 0
) (
 output [1:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module vceff2d #(
 parameter vfffc23 = 3
) (
 output [1:0] v2978f0
);
 localparam p1 = vfffc23;
 wire [0:1] w0;
 assign v2978f0 = w0;
 v157753 #(
  .vc5c8ea(p1)
 ) v2208c0 (
  .v4ffce0(w0)
 );
endmodule

//---------------------------------------------------
//-- Valor_3_2bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor constante 3 para bus de 2 bits
//---------------------------------------------------
//---- Top entity
module va47586 #(
 parameter vb36a78 = "vb36a78.list"
) (
 input [1:0] v851180,
 output [1:0] vfde47f
);
 localparam p0 = vb36a78;
 wire [0:1] w1;
 wire [0:1] w2;
 assign w1 = v851180;
 assign vfde47f = w2;
 va47586_v361fe9 #(
  .DATA(p0)
 ) v361fe9 (
  .i(w1),
  .q(w2)
 );
endmodule

//---------------------------------------------------
//-- mi-tabla2-2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Circuito combinacional de 2 entradas y 2 salidas
//---------------------------------------------------

module va47586_v361fe9 #(
 parameter DATA = 0
) (
 input [1:0] i,
 output [1:0] q
);
 
 //-- Bits del bus de entrada
 localparam N = 2;
 
 //-- Bits del bus de salida
 localparam M = 2;
 
 //-- Calcular tamaño de la tabla
 //-- (filas) segun los bits de entrada
 localparam TAM = 2 ** N;
 
 //-- Definición de la tabla
 //-- Tabla de TAM elementos de M bits
 reg [M-1:0] tabla[0:TAM-1];
 
 //-- Read the table
 assign q = tabla[i];
 
 //-- Init table from DATA parameters
 initial begin
   if (DATA) $readmemb(DATA, tabla);
 end
endmodule
//---- Top entity
module v359a55 (
 input [7:0] v02d898,
 input [7:0] vd6b984,
 input v50d6c6,
 output [7:0] vf24dba
);
 wire w0;
 wire [0:7] w1;
 wire [0:7] w2;
 wire [0:7] w3;
 assign w0 = v50d6c6;
 assign w1 = vd6b984;
 assign w2 = v02d898;
 assign vf24dba = w3;
 v359a55_ve4e0df ve4e0df (
  .sel(w0),
  .i0(w1),
  .i1(w2),
  .o(w3)
 );
endmodule

//---------------------------------------------------
//-- Mux 2 a 1 de 8 bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Multiplexor de 2 a 1 de 8 bits
//---------------------------------------------------

module v359a55_ve4e0df (
 input [7:0] i1,
 input [7:0] i0,
 input sel,
 output [7:0] o
);
 //-- Multiplexor de 2 a 1, 
 //-- de 8 bits
 
 reg [7:0] o;
 
 always @(*) begin
     case(sel)
         0: o = i0;
         1: o = i1;
         default: o = i0;
     endcase
 end
 
 
endmodule
//---- Top entity
module vd9a3cf #(
 parameter v16d6b8 = 0
) (
 input [2:0] v2e7398,
 output v18e78c
);
 localparam p2 = v16d6b8;
 wire w0;
 wire [0:2] w1;
 assign v18e78c = w0;
 assign w1 = v2e7398;
 vd9a3cf_vd75681 #(
  .B(p2)
 ) vd75681 (
  .eq(w0),
  .a(w1)
 );
endmodule

//---------------------------------------------------
//-- Igual-1-op
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de igualdad, de un operando de 3 bits
//---------------------------------------------------

module vd9a3cf_vd75681 #(
 parameter B = 0
) (
 input [2:0] a,
 output eq
);
 assign eq = (a == B);
endmodule
//---- Top entity
module vfbbede #(
 parameter vb36a78 = "vb36a78.list"
) (
 input [1:0] v851180,
 output [7:0] vfde47f
);
 localparam p0 = vb36a78;
 wire [0:1] w1;
 wire [0:7] w2;
 assign w1 = v851180;
 assign vfde47f = w2;
 vfbbede_v361fe9 #(
  .DATA(p0)
 ) v361fe9 (
  .i(w1),
  .q(w2)
 );
endmodule

//---------------------------------------------------
//-- mi-tabla2-8
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Circuito combinacional de 2 entradas y 8 salidas
//---------------------------------------------------

module vfbbede_v361fe9 #(
 parameter DATA = 0
) (
 input [1:0] i,
 output [7:0] q
);
 
 //-- Bits del bus de entrada
 localparam N = 2;
 
 //-- Bits del bus de salida
 localparam M = 8;
 
 //-- Calcular tamaño de la tabla
 //-- (filas) segun los bits de entrada
 localparam TAM = 2 ** N;
 
 //-- Definición de la tabla
 //-- Tabla de TAM elementos de M bits
 reg [M-1:0] tabla[0:TAM-1];
 
 //-- Read the table
 assign q = tabla[i];
 
 //-- Init table from DATA parameters
 initial begin
   if (DATA) $readmemh(DATA, tabla);
 end
endmodule
//---- Top entity
module v484ba7 #(
 parameter v55b594 = 2000,
 parameter v83bbc4 = 255,
 parameter vf99d89 = 0
) (
 input v096121,
 input vcaf9ab,
 output v0c6d1e
);
 localparam p3 = v55b594;
 localparam p4 = v83bbc4;
 localparam p5 = vf99d89;
 localparam p6 = v83bbc4;
 localparam p7 = vf99d89;
 wire [0:7] w0;
 wire w1;
 wire w2;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 assign w1 = vcaf9ab;
 assign v0c6d1e = w8;
 assign w9 = v096121;
 assign w10 = v096121;
 assign w11 = v096121;
 assign w10 = w9;
 assign w11 = w9;
 assign w11 = w10;
 vf061f4 ve77f8f (
  .v165d22(w0),
  .vf04ee2(w8),
  .v3d0d46(w11)
 );
 vfd70ac #(
  .v5e93d8(p6),
  .vc70f60(p7)
 ) v51959d (
  .v1e08cd(w0),
  .v192113(w1),
  .v83d2df(w2),
  .v3a9962(w10)
 );
 v484ba7_vb85f7d #(
  .Tms(p3),
  .Max(p4),
  .Min(p5)
 ) vb85f7d (
  .o(w2),
  .clk(w9)
 );
endmodule

//---------------------------------------------------
//-- Brillo-gradual
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Brillo gradual entre los dos extremos (Máx y Min). La entrada indica el brillo objetivo (1=Máximo, 0=Mínimo)
//---------------------------------------------------

module v484ba7_vb85f7d #(
 parameter Tms = 0,
 parameter Max = 0,
 parameter Min = 0
) (
 input clk,
 output o
);
 //---- Corazon de tics de µs
 //-- La frecuencia se calcula dividiendo el tiempo total (Tms)
 //-- entre la diferencia de niveles. Nos indica el numero de 
 //-- tics que hay que dar para llegar de Min a Max en Tms tiempo
 
 localparam US = (Tms*1000)/(Max-Min+1);
 
 //-- Constante para dividir y obtener una frecuencia de 1MHz
 localparam M = 12*US;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = (divcounter == M-1);
 
 //-- La salida es la señal de overflow
 assign o = reset;
 
 
 
 
endmodule
//---- Top entity
module vf061f4 #(
 parameter vaffc96 = 7
) (
 input v3d0d46,
 input [7:0] v165d22,
 output vf04ee2
);
 localparam p3 = vaffc96;
 wire w0;
 wire [0:7] w1;
 wire w2;
 wire [0:7] w4;
 wire [0:7] w5;
 wire [0:7] w6;
 wire w7;
 wire w8;
 wire [0:7] w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 assign vf04ee2 = w7;
 assign w9 = v165d22;
 assign w10 = v3d0d46;
 assign w11 = v3d0d46;
 assign w12 = v3d0d46;
 assign w13 = v3d0d46;
 assign w14 = v3d0d46;
 assign w5 = w4;
 assign w11 = w10;
 assign w12 = w10;
 assign w12 = w11;
 assign w13 = w10;
 assign w13 = w11;
 assign w13 = w12;
 assign w14 = w10;
 assign w14 = w11;
 assign w14 = w12;
 assign w14 = w13;
 v89d234 v219b82 (
  .vf892a0(w0),
  .v39f831(w1),
  .vb1c024(w6),
  .v41eb95(w12)
 );
 v7eacdf va8d776 (
  .v2dffca(w0),
  .v10eedb(w2),
  .v0884a0(w11)
 );
 vec5121 #(
  .vaf1d6e(p3)
 ) vab8a2b (
  .v7ff276(w2),
  .vdf5b7a(w4)
 );
 v27fd6d v7ab306 (
  .v9892c7(w5),
  .v9f69ad(w6),
  .v18e78c(w8)
 );
 v1c7dae vd8c9cc (
  .ve8318d(w7),
  .vf54559(w8),
  .va4102a(w13)
 );
 vd21196 v94e894 (
  .v7a3c8e(w4),
  .vfdbd5b(w10)
 );
 va940ef v65d4ca (
  .v5cd41a(w1),
  .v0ad762(w9),
  .v41eb95(w14)
 );
endmodule

//---------------------------------------------------
//-- brillo-led
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Fijar el brillo constante para el LED
//---------------------------------------------------
//---- Top entity
module vec5121 #(
 parameter vaf1d6e = 0
) (
 input [7:0] vdf5b7a,
 output v7ff276
);
 localparam p0 = vaf1d6e;
 wire w1;
 wire [0:7] w2;
 assign v7ff276 = w1;
 assign w2 = vdf5b7a;
 vec5121_vd80544 #(
  .BIT(p0)
 ) vd80544 (
  .o(w1),
  .i(w2)
 );
endmodule

//---------------------------------------------------
//-- Extract-1-bit
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Extractor de 1 bit de un bus de 8 bits
//---------------------------------------------------

module vec5121_vd80544 #(
 parameter BIT = 0
) (
 input [7:0] i,
 output o
);
 assign o = i[BIT];
endmodule
//---- Top entity
module v27fd6d (
 input [7:0] v9892c7,
 input [7:0] v9f69ad,
 output v18e78c
);
 wire w0;
 wire [0:7] w1;
 wire [0:7] w2;
 assign v18e78c = w0;
 assign w1 = v9f69ad;
 assign w2 = v9892c7;
 v27fd6d_vd75681 vd75681 (
  .eq(w0),
  .b(w1),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Menor-que-2-op
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador menor que, de dos operandos de 8 bits
//---------------------------------------------------

module v27fd6d_vd75681 (
 input [7:0] a,
 input [7:0] b,
 output eq
);
 assign eq = (a < b);
endmodule
//---- Top entity
module vd21196 (
 input vfdbd5b,
 output [7:0] v7a3c8e
);
 wire w0;
 wire [0:7] w1;
 assign w0 = vfdbd5b;
 assign v7a3c8e = w1;
 vd21196_vf093da vf093da (
  .clk(w0),
  .q(w1)
 );
endmodule

//---------------------------------------------------
//-- Contador-sistema-basico
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Contador del sistema, de 8 bits
//---------------------------------------------------

module vd21196_vf093da (
 input clk,
 output [7:0] q
);
 //-- Número de bits del contador
 localparam N = 8;
 
 reg [N-1:0] q = 0;
 
 always @(posedge clk)
     q <= q + 1;
endmodule
//---- Top entity
module va940ef #(
 parameter v422d28 = 0
) (
 input v41eb95,
 input [7:0] v0ad762,
 output [7:0] v5cd41a
);
 localparam p0 = v422d28;
 wire w1;
 wire [0:7] w2;
 wire [0:7] w3;
 assign w1 = v41eb95;
 assign v5cd41a = w2;
 assign w3 = v0ad762;
 va940ef_v9148cb #(
  .INI(p0)
 ) v9148cb (
  .clk(w1),
  .q(w2),
  .d(w3)
 );
endmodule

//---------------------------------------------------
//-- Registro-sistema
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Registro del sistema de 8 bits
//---------------------------------------------------

module va940ef_v9148cb #(
 parameter INI = 0
) (
 input clk,
 input [7:0] d,
 output [7:0] q
);
 localparam N = 8;
 
 reg [N-1:0] q = INI;
 
 always @(posedge clk)
     q <= d;
endmodule
//---- Top entity
module vfd70ac #(
 parameter vc03756 = "vc03756.list",
 parameter v5e93d8 = 255,
 parameter vc70f60 = 0,
 parameter v8e5d55 = 1,
 parameter v2b8e3d = -1
) (
 input v3a9962,
 input v192113,
 input v83d2df,
 output [7:0] v1e08cd
);
 localparam p1 = v8e5d55;
 localparam p3 = v2b8e3d;
 localparam p8 = vc03756;
 localparam p10 = v5e93d8;
 localparam p17 = vc70f60;
 localparam p18 = vc70f60;
 wire [0:7] w0;
 wire [0:7] w2;
 wire [0:7] w4;
 wire [0:7] w5;
 wire [0:7] w6;
 wire w7;
 wire [0:2] w9;
 wire [0:7] w11;
 wire w12;
 wire [0:7] w13;
 wire w14;
 wire [0:7] w15;
 wire w16;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 assign w14 = v83d2df;
 assign v1e08cd = w15;
 assign w16 = v3a9962;
 assign w19 = v192113;
 assign w20 = v192113;
 assign w4 = w0;
 assign w11 = w0;
 assign w11 = w4;
 assign w13 = w0;
 assign w13 = w4;
 assign w13 = w11;
 assign w15 = w0;
 assign w15 = w4;
 assign w15 = w11;
 assign w15 = w13;
 assign w20 = w19;
 v89d234 #(
  .v422d28(p18)
 ) vbc8ab0 (
  .vb1c024(w0),
  .v39f831(w6),
  .vf892a0(w7),
  .v41eb95(w16)
 );
 v359a55 v36ffe7 (
  .v02d898(w2),
  .vd6b984(w5),
  .vf24dba(w6),
  .v50d6c6(w19)
 );
 v7d7474 #(
  .v8d305c(p1)
 ) vf1d695 (
  .ve41da3(w0),
  .v9c083a(w2)
 );
 v7d7474 #(
  .v8d305c(p3)
 ) v805790 (
  .ve41da3(w4),
  .v9c083a(w5)
 );
 vb2090f v059640 (
  .vcbab45(w7),
  .v3ca442(w12),
  .v0e28cb(w14)
 );
 v590ad1 #(
  .vb36a78(p8)
 ) v40cba3 (
  .v851180(w9),
  .vfde47f(w12)
 );
 vd9c150 v8588d7 (
  .v0fc56f(w9),
  .v03aaf0(w20),
  .v1311d2(w21),
  .vee8a83(w22)
 );
 vca7316 #(
  .v6b316b(p10)
 ) vc98e07 (
  .v40cb98(w11),
  .v18e78c(w21)
 );
 vca7316 #(
  .v6b316b(p17)
 ) v24eda4 (
  .v40cb98(w13),
  .v18e78c(w22)
 );
endmodule

//---------------------------------------------------
//-- cont-up-down-limit
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Contador ascendente/descendente con límites
//---------------------------------------------------
//---- Top entity
module v7d7474 #(
 parameter v8d305c = 1
) (
 input [7:0] ve41da3,
 output [7:0] v9c083a
);
 localparam p0 = v8d305c;
 wire [0:7] w1;
 wire [0:7] w2;
 assign w1 = ve41da3;
 assign v9c083a = w2;
 v7d7474_va0c26a #(
  .k(p0)
 ) va0c26a (
  .a(w1),
  .s(w2)
 );
endmodule

//---------------------------------------------------
//-- sum-1op-8bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Sumador de un operando de 8 bits con una constante pasada como parámetro (No hay accarreo)
//---------------------------------------------------

module v7d7474_va0c26a #(
 parameter k = 0
) (
 input [7:0] a,
 output [7:0] s
);
 assign s = a + k;
endmodule
//---- Top entity
module v590ad1 #(
 parameter vb36a78 = "vb36a78.list"
) (
 input [2:0] v851180,
 output [0:0] vfde47f
);
 localparam p0 = vb36a78;
 wire [0:2] w1;
 wire [0:0] w2;
 assign w1 = v851180;
 assign vfde47f = w2;
 v590ad1_v361fe9 #(
  .DATA(p0)
 ) v361fe9 (
  .i(w1),
  .q(w2)
 );
endmodule

//---------------------------------------------------
//-- mi-tabla3-1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Circuito combinacional de 3 entradas y 1 salidas
//---------------------------------------------------

module v590ad1_v361fe9 #(
 parameter DATA = 0
) (
 input [2:0] i,
 output [0:0] q
);
 
 //-- Bits del bus de entrada
 localparam N = 3;
 
 //-- Bits del bus de salida
 localparam M = 1;
 
 //-- Calcular tamaño de la tabla
 //-- (filas) segun los bits de entrada
 localparam TAM = 2 ** N;
 
 //-- Definición de la tabla
 //-- Tabla de TAM elementos de M bits
 reg [M-1:0] tabla[0:TAM-1];
 
 //-- Read the table
 assign q = tabla[i];
 
 //-- Init table from DATA parameters
 initial begin
   if (DATA) $readmemb(DATA, tabla);
 end
endmodule
//---- Top entity
module vd9c150 (
 input v1311d2,
 input vee8a83,
 input v03aaf0,
 output [2:0] v0fc56f
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:2] w3;
 assign w0 = vee8a83;
 assign w1 = v03aaf0;
 assign w2 = v1311d2;
 assign v0fc56f = w3;
 vd9c150_v9a2a06 v9a2a06 (
  .i1(w0),
  .i0(w1),
  .i2(w2),
  .o(w3)
 );
endmodule

//---------------------------------------------------
//-- Agregador-bus
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Agregador de 3 cables en un bus de 3-bits
//---------------------------------------------------

module vd9c150_v9a2a06 (
 input i2,
 input i1,
 input i0,
 output [2:0] o
);
 assign o = {i2, i1, i0};
 
endmodule
//---- Top entity
module vca7316 #(
 parameter v6b316b = 0
) (
 input [7:0] v40cb98,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:7] w2;
 assign v18e78c = w0;
 assign w2 = v40cb98;
 vca7316_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 8 bits. Se compara si el operando es igual al parámetro
//---------------------------------------------------

module vca7316_vd75681 #(
 parameter K = 0
) (
 input [7:0] a,
 output eq
);
 assign eq = (a == K);
endmodule
//---- Top entity
module v85bf11 (
 input [11:0] va228b5,
 input [11:0] vf9627b,
 input v370eb5,
 output [11:0] ve2e329,
 output v4982f8,
 output v5a6ca4
);
 wire w0;
 wire [0:11] w1;
 wire [0:11] w2;
 wire [0:11] w3;
 assign w0 = v370eb5;
 assign ve2e329 = w1;
 assign w2 = vf9627b;
 assign w3 = va228b5;
 v2accd5 v197c2c (
  .v50d6c6(w0),
  .v985d83(w1),
  .vdc4478(w2),
  .v7faeb8(w3)
 );
endmodule

//---------------------------------------------------
//-- 12-bits-bus-write
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Writing into a 12-bits bus
//---------------------------------------------------
//---- Top entity
module v2accd5 (
 input [11:0] vdc4478,
 input [11:0] v7faeb8,
 input v50d6c6,
 output [11:0] v985d83
);
 wire w0;
 wire [0:11] w1;
 wire [0:11] w2;
 wire [0:11] w3;
 assign w0 = v50d6c6;
 assign w1 = v7faeb8;
 assign w2 = vdc4478;
 assign v985d83 = w3;
 v2accd5_ve4e0df ve4e0df (
  .sel(w0),
  .i0(w1),
  .i1(w2),
  .o(w3)
 );
endmodule

//---------------------------------------------------
//-- 12bits-2-1-Mux
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 12 bits, 2-1 Multiplexer
//---------------------------------------------------

module v2accd5_ve4e0df (
 input [11:0] i1,
 input [11:0] i0,
 input sel,
 output [11:0] o
);
 
 reg [11:0] o;
 
 always @(*) begin
     case(sel)
         0: o = i0;
         1: o = i1;
         default: o = i0;
     endcase
 end
 
 
endmodule
