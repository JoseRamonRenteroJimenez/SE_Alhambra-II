// Code generated by Icestudio 0.12
// Tue, 08 Apr 2025 20:34:31 GMT

`default_nettype none

//---- Top entity
module main #(
 parameter v269dbc = 'h0400_0000
) (
 input v87186f,
 input v4dc0ee,
 input [31:0] v867561,
 input v8859f4,
 input [31:0] v23504b,
 output v9127c2,
 output vfe2384,
 output [31:0] v504d16,
 output [0:7] vinit,
 inout v80923c
);
 localparam p0 = v269dbc;
 wire w1;
 wire [0:7] w2;
 wire [0:6] w3;
 wire w4;
 wire w5;
 wire [0:7] w6;
 wire [0:3] w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire [0:31] w14;
 wire [0:31] w15;
 wire w16;
 wire [0:31] w17;
 wire w18;
 assign v9127c2 = w8;
 assign w9 = v87186f;
 assign w10 = v87186f;
 assign w11 = v4dc0ee;
 assign w12 = v4dc0ee;
 assign w13 = v80923c;
 assign w14 = v867561;
 assign w15 = v867561;
 assign w16 = v8859f4;
 assign w17 = v23504b;
 assign w10 = w9;
 assign w12 = w11;
 assign w15 = w14;
 vf9bdaf #(
  .v6b316b(p0)
 ) v72f060 (
  .v18e78c(w1),
  .ve1f562(w14)
 );
 vb2090f vef47e6 (
  .v0e28cb(w1),
  .v3ca442(w16),
  .vcbab45(w18)
 );
 main_vecfcb9 vecfcb9 (
  .adc_reg(w2),
  .slv_addr(w3),
  .adc_rw(w4),
  .enable_start(w5),
  .adc_data_writte(w6),
  .adc_data_size(w7),
  .clk(w10),
  .rst(w12),
  .Bus_addr(w15),
  .Bus_data(w17),
  .serdat_cs(w18)
 );
 main_v77cc05 v77cc05 (
  .reg_obj(w2),
  .slv_addr(w3),
  .rw(w4),
  .enable(w5),
  .data_in(w6),
  .data_size(w7),
  .I2C_SCL(w8),
  .clk(w9),
  .rst(w11),
  .I2C_SDA(w13)
 );
 assign vinit = 8'b00000000;
endmodule

//---------------------------------------------------
//-- I2C
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Periférico encargado de la comunicación a través del bus I2C.
//---------------------------------------------------
//---- Top entity
module vf9bdaf #(
 parameter v6b316b = 0
) (
 input [31:0] ve1f562,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = ve1f562;
 vf9bdaf_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 32 bits. Se compara si el operando es igual al parámetro
//---------------------------------------------------

module vf9bdaf_vd75681 #(
 parameter K = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a[31:8] == K[31:8]);
endmodule
//---- Top entity
module vb2090f (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vb2090f_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND
//---------------------------------------------------

module vb2090f_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta AND
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a & b;
 
 //-- endmodule
endmodule

module main_vecfcb9 (
 input clk,
 input [31:0] Bus_addr,
 input [31:0] Bus_data,
 input serdat_cs,
 input rst,
 output enable_start,
 output adc_rw,
 output [6:0] slv_addr,
 output [7:0] adc_reg,
 output [7:0] adc_data_writte,
 output [3:0] adc_data_size
);
 localparam ADDR_SLAVE     = 3'b000; 
 localparam ADDR_REG_OBJ   = 3'b001; 
 localparam ADDR_DATA      = 3'b010; 
 localparam ADDR_RW        = 3'b011;
 localparam ADDR_DATA_SIZE = 3'B100;
 
 reg [31:0] dataArray =  32'b0;           
 reg reg_enable_start = 0;       
 
 assign slv_addr = dataArray[6:0];
 assign adc_reg = dataArray[15:8];
 assign adc_data_writte = dataArray[23:16];
 assign adc_rw = dataArray[24];
 assign adc_data_size = dataArray[28:25];
 
 assign enable_start = reg_enable_start;
 
 always @(posedge serdat_cs or posedge rst) begin
     if (rst) begin
         dataArray <= 32'b0;
         reg_enable_start <= 1'b0;
     end else if (serdat_cs) begin
         case (Bus_addr[2:0])  
             ADDR_SLAVE: begin
                 dataArray[6:0] <= Bus_data[6:0];
             end
             ADDR_REG_OBJ: begin
                 dataArray[15:8] <= Bus_data[7:0];
             end
             ADDR_DATA: begin
                 dataArray[23:16] <= Bus_data[7:0];
             end
             ADDR_RW: begin
                 dataArray[24] <= Bus_data[0];
             end
             ADDR_DATA_SIZE: begin
                 dataArray[28:25] <= Bus_data[23:0];
             end
         endcase
 
         if(Bus_addr[7:0] == 8'b00000000) begin
             reg_enable_start <= 1;
         end
     end
 end
 
 // integer i;
 //for (i = 0; i < 7; i = i + 1) begin
 //dataArray[8*Bus_addr[1:0]+i] <= Bus_data[i];
 //end
endmodule

module main_v77cc05 (
 input clk,
 input rst,
 input enable,
 input rw,
 input [6:0] slv_addr,
 input [7:0] reg_obj,
 input [7:0] data_in,
 input [3:0] data_size,
 output ready,
 output [7:0] data_out,
 output I2C_SCL,
 inout I2C_SDA
);
 localparam READY        = 0;
 localparam START        = 1;
 localparam COMMAND      = 2;
 localparam READ_ACK     = 3;
 localparam WRITE_DATA   = 4;
 localparam WRITE_ACK    = 5;
 localparam READ_DATA    = 6;
 localparam WRITE_NACK   = 7;
 localparam STOP         = 8;
 
 localparam DIVIDE_BY = 4;
 
 reg [3:0] state = READY;
 reg [7:0] counter = 0;
 reg [7:0] bit_ptr = 0;
 reg [15:0] tx_buffer = 0;
 reg [7:0] saved_addr = 0;
 reg [7:0] rd_buffer = 0;
 reg [2:0] clk_div = 0;
 reg reg_ready = 0;
 reg [7:0] reg_data_out = 0;
 reg i2c_clk = 1;
 reg sda_out = 1;
 reg write_enable = 1;
 reg i2c_scl_enable = 0;
 
 assign I2C_SCL = (i2c_scl_enable == 0) ? 1 : i2c_clk;
 assign I2C_SDA = (write_enable == 1) ? sda_out : 1'bz;
 
 assign ready = reg_ready;
 assign data_out = reg_data_out;
 // Clock I2C dividido
 always @(posedge clk) begin
 	if (clk_div == (DIVIDE_BY/2)-1) begin
 		i2c_clk <= ~i2c_clk;
 		clk_div <= 0;
 	end else begin
 		clk_div <= clk_div + 1;
 	end
 end
 // Control de habilitación del SCL
 always @(negedge i2c_clk or posedge rst) begin
 	if (rst)
 		i2c_scl_enable <= 0;
 	else
 		i2c_scl_enable <= (state != READY && state != START && state != STOP);
 end
 // Máquina de estados I2C
 always @(posedge i2c_clk or posedge rst) begin
 	if (rst) begin
 		state <= READY;
 		reg_ready <= 1;
 		sda_out <= 1;
 		write_enable <= 1;
 	end else begin
 		case (state)
 			READY: begin
 				if (enable) begin
 					saved_addr <= {slv_addr, rw};
 					tx_buffer <= data_in;
 					bit_ptr <= (num_packages * 16) - 1;
 					state <= START;
 					reg_ready <= 0;
 				end
 			end
 			START: begin
 				write_enable <= 1;
 				sda_out <= 0;
 				state <= COMMAND;
 				counter <= 7;
 			end
 			COMMAND: begin
 				sda_out <= saved_addr[counter];
 				if (counter == 0)
 					state <= READ_ACK;
 				else
 					counter <= counter - 1;
 			end
 			READ_ACK: begin
 				write_enable <= 0;
 				if (I2C_SDA == 0) begin
 					counter <= 7;
 					if (saved_addr[0] == 0)  // Write
 						state <= WRITE_DATA;
 					else                     // Read
 						state <= READ_DATA;
 				end else
 					state <= STOP;
 			end
 			WRITE_DATA: begin
 				sda_out <= tx_buffer[bit_ptr];
 				if (counter == 0)
 					state <= WRITE_ACK;
 				else begin
 					counter <= counter - 1;
 					bit_ptr <= bit_ptr - 1;
 				end
 			end
 			WRITE_ACK: begin
 				write_enable <= 0;
 				if (I2C_SDA == 0) begin
 					if (bit_ptr >= 8) begin
 						counter <= 7;
 						write_enable <= 1;
 						bit_ptr <= bit_ptr - 1;
 						sda_out <= tx_buffer[bit_ptr - 1];
 						state <= WRITE_DATA;
 					end else
 						state <= STOP;
 				end else
 					state <= STOP;
 			end
 			READ_DATA: begin
 				write_enable <= 0;
 				rd_buffer[counter] <= I2C_SDA;
 				if (counter == 0)
 					state <= WRITE_NACK;
 				else
 					counter <= counter - 1;
 			end
 			WRITE_NACK: begin
 				write_enable <= 1;
 				sda_out <= 1;
 				state <= STOP;
 			end
 			STOP: begin
 				write_enable <= 1;
 				sda_out <= 1;
 				reg_data_out <= rd_buffer;
 				reg_ready <= 1;
 				state <= READY;
 			end
 		endcase
 	end
 end
endmodule
