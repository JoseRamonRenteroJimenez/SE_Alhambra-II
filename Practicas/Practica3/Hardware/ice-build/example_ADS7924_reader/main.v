// Code generated by Icestudio 0.12

`default_nettype none

//---- Top entity
module main #(
 parameter v12020b = 12000000,
 parameter vc52075 = 400000
) (
 input vd24f28,
 input v6c3b9c,
 input vclk,
 output [7:0] v58e1f8,
 inout vd2db7b,
 inout vb095e8
);
 localparam p7 = v12020b;
 localparam p8 = vc52075;
 wire [0:7] w0;
 wire [0:7] w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire [0:11] w6;
 wire w9;
 wire w10;
 wire w11;
 assign v58e1f8 = w1;
 assign w2 = vd24f28;
 assign w3 = v6c3b9c;
 assign vb095e8 = w4;
 assign vd2db7b = w5;
 assign w10 = vclk;
 assign w11 = vclk;
 assign w11 = w10;
 main_v12f9c2 v12f9c2 (
  .b(w0),
  .a(w6)
 );
 vda06b5 vcc5b23 (
  .v39f831(w0),
  .vb1c024(w1),
  .vf892a0(w9),
  .v41eb95(w10)
 );
 vea7a9f #(
  .vaa7e21(p7),
  .vf72171(p8)
 ) vfe03d0 (
  .v15d637(w2),
  .v8d5a0a(w3),
  .vc79dbf(w4),
  .v809f00(w5),
  .v31e23c(w6),
  .v3351ca(w9),
  .v195602(w11)
 );
endmodule

//---------------------------------------------------
//-- Example-ADS7924-Arias
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Example of operation of the ADS7924 ADC
//---------------------------------------------------
//---- Top entity
module vda06b5 #(
 parameter v422d28 = 0
) (
 input v41eb95,
 input [7:0] v39f831,
 input vf892a0,
 output [7:0] vb1c024
);
 localparam p0 = v422d28;
 wire [0:7] w1;
 wire [0:7] w2;
 wire w3;
 wire w4;
 assign vb1c024 = w1;
 assign w2 = v39f831;
 assign w3 = vf892a0;
 assign w4 = v41eb95;
 vda06b5_v9148cb #(
  .INI(p0)
 ) v9148cb (
  .q(w1),
  .d(w2),
  .load(w3),
  .clk(w4)
 );
endmodule

//---------------------------------------------------
//-- Register_8_bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 8 bits register
//---------------------------------------------------

module vda06b5_v9148cb #(
 parameter INI = 0
) (
 input clk,
 input [7:0] d,
 input load,
 output [7:0] q
);
 localparam N = 8;
 
 reg [N-1:0] qi = INI;
 
 always @(posedge clk) begin
   if (load) qi <= d;
 end
 
 assign q = qi;
endmodule
//---- Top entity
module vea7a9f #(
 parameter vaa7e21 = 12000000,
 parameter vf72171 = 400000
) (
 input v195602,
 input v15d637,
 input v8d5a0a,
 output [11:0] v33c8d6,
 output [11:0] v75d11d,
 output [11:0] v4a0eb9,
 output [11:0] v31e23c,
 output v3351ca,
 inout v809f00,
 inout vc79dbf
);
 localparam p0 = vf72171;
 localparam p1 = vaa7e21;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire [0:11] w8;
 wire [0:11] w9;
 wire [0:11] w10;
 wire [0:11] w11;
 assign w2 = v15d637;
 assign w3 = v8d5a0a;
 assign w4 = v195602;
 assign v809f00 = w5;
 assign vc79dbf = w6;
 assign v3351ca = w7;
 assign v31e23c = w8;
 assign v4a0eb9 = w9;
 assign v75d11d = w10;
 assign v33c8d6 = w11;
 vea7a9f_ve9ee3c #(
  .FSCL(p0),
  .FCLK(p1)
 ) ve9ee3c (
  .reset(w2),
  .int(w3),
  .clk(w4),
  .sda(w5),
  .scl(w6),
  .sampletick(w7),
  .ana0(w8),
  .ana1(w9),
  .ana2(w10),
  .ana3(w11)
 );
endmodule

//---------------------------------------------------
//-- ADC_ADS7924_Arias
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- This module is a block that reads the 4 ADC inputs of the ADS7924 and presents the results as plain four 12-bit values.
//---------------------------------------------------

module vea7a9f_ve9ee3c #(
 parameter FCLK = 0,
 parameter FSCL = 0
) (
 input clk,
 input reset,
 input int,
 output [11:0] ana3,
 output [11:0] ana2,
 output [11:0] ana1,
 output [11:0] ana0,
 output sampletick,
 inout sda,
 inout scl
);
 ////////////////////////////////////////////////////////////////////
 //                ADS7924 reader (via I2C bus)
 // J. Arias (2024) Public domain sources
 //
 // This module is a block that reads the 4 ADC inputs of the ADS7924
 // and presents the results as plain four 12-bit values.
 // -First, it configure the ADC with "Auto-Burst Scan with Sleep" mode,
 //  with minimun sleep time (2.5ms / 4 = 625us), and 14us adquisition
 //  time (max source resistance: 100 kohm)
 // -Then it waits for BUSY pulses on the INT input, reads the 4 channel
 //  values, and keeps doing this again and again.
 // -A sample clock output is provided. This signal is low while the data
 //  is being updated. Output updates are atomic (the whole 12 bits of
 //  the outputs are written in parallel)
 //
 // I2C Details:
 // - ACK bits are ignored (there is nothing we can do if they fail, anyways)
 // - No clock stretching is allowed (this isn't a problem for the ADS7924)
 //
 // Performance:
 // - 1430 (+-20%) Samples/s. The sampling rate depends on an inaccurate 
 //   internal clock.
 // - 124 Logic cells.
 //
 // More info = https://groups.google.com/g/fpga-wars-explorando-el-lado-libre/c/9gcu-SFjloA
 
 // Clock dividers clk2 = 2*clkbit, almost square
 localparam DIVIDER = (FCLK/2)/FSCL;
 localparam NDIV = $clog2(DIVIDER);
 
 reg [NDIV-1:0]pres=0;
 always @(posedge clk) pres<= (pres==DIVIDER-1) ? 0 : pres+1;
 reg clk2=0;
 always @(posedge clk) clk2<=(pres<=(DIVIDER/2));
 
 reg clkbit=0;	// bit clock, active rising
 always @(posedge clk2) clkbit<=~clkbit;
 
 // SCL & SDA
 reg sclo1; // temp SCL output, 1/4 Tbit delay
 always @(negedge clk2) sclo1<=idle | (start&clkbit) | (stop&(~clkbit)) | clkbit;
 reg sclo;  // SCL output resampled (delayed 1 clk for equalization with respect SDA)
 always @(posedge clk) sclo<=sclo1;
 reg sdao;  // registered SDA output to avoid glitches
 always @(posedge clk) sdao <= idle | (start&clkbit) | (stop&(~clkbit)) | (datast&sh[8]) ;
 
 // Open-drain pins: SCL, SDA
 assign scl = sclo ? 1'bz : 1'b0;
 assign sda = sdao ? 1'bz : 1'b0;
 
 // bit counter (9 cycles: data + ACK)
 reg [3:0]bcnt=0;
 wire nxtinstr = (~datast)|bcnt[3];	// next instruction: after 9 cycles if in data state
 always @(posedge clkbit) bcnt<= nxtinstr ? 0 : bcnt+1;
 
 // Shift register (sda input and output)
 reg ssda;	// sampled SDA (SCL falling)
 always @(negedge scl) ssda<=sda;
 
 reg [8:0]sh; // 9-bit shift register
 always @(posedge clkbit) sh<= nxtinstr ? {ucode[7:0],ack} : {sh[7:0],ssda};
 
 /////////////////// SEQUENCER //////////////////////
 /// START / STOP / IDLE / DATA
 localparam IDL = 2'b00;
 localparam STA = 2'b01;
 localparam STP = 2'b10;
 localparam DAT = 2'b11;
 
 // instructions
 wire idle  = (ucode[10:9]==IDL);
 wire start = (ucode[10:9]==STA);
 wire stop  = (ucode[10:9]==STP);
 wire datast= (ucode[10:9]==DAT);
 
 localparam ACK = 1'b0;
 localparam NAK = 1'b1;
 wire ack =ucode[8];		// ACK bit to send
 
 wire goto=ucode[11];	// Goto to address 0
 wire wr0 =ucode[12];	// write channels #0 to #3
 wire wr1 =ucode[13];
 wire wr2 =ucode[14];
 wire wr3 =ucode[15];
 
 // address counter
 localparam ADDRST=16; 	// reset address
 reg [4:0]uaddr = ADDRST;// address counter
 
 always @(posedge clkbit or posedge reset)
 	if (reset) uaddr<=ADDRST;
 	// GOTO and IDLE with no data_av jumps to address 0
 	else uaddr<= (goto | (idle & (~data_av)))? 0 : uaddr + nxtinstr;
 	// GOTO jumps to address 0. IDLE blocks until data_av
 	//else uaddr<= goto ? 0 : uaddr + (nxtinstr & ((~idle)|data_av));
 
 // microcode ROM (asynchronous)
 //  includes control signals (write, goto) for current instruction, 
 //  and data to be loaded into the shift register for next instruction
 reg [15:0]ucode;	// not register, combinational
 always @*
 	case(uaddr)
 	// Operation loop
 	//              wr3-0  goto inst ack  data
 	5'd0 : ucode<={4'b0000,1'b0, IDL,1'bx,8'hxx};	// wait for INT edge
 	5'd1 : ucode<={4'b0000,1'b0, STA, NAK,8'h90};	// START, Slave address, write
 	5'd2 : ucode<={4'b0000,1'b0, DAT, NAK,8'h82};	// reg #2, increment address
 	5'd3 : ucode<={4'b0000,1'b0, DAT,1'bx,8'hXX};	// send last byte
 	5'd4 : ucode<={4'b0000,1'b0, STP,1'bx,8'hXX};	// STOP
 	
 	5'd5 : ucode<={4'b0000,1'b0, STA, NAK,8'h91};	// START, Slave address, read
 	5'd6 : ucode<={4'b0000,1'b0, DAT, ACK,8'hFF};	
 	5'd7 : ucode<={4'b0000,1'b0, DAT, ACK,8'hFF};	// DATA0_U
 	5'd8 : ucode<={4'b0001,1'b0, DAT, ACK,8'hFF};	// DATA0_L, write to AN0
 	5'd9 : ucode<={4'b0000,1'b0, DAT, ACK,8'hFF};	// DATA1_U
 	5'd10: ucode<={4'b0010,1'b0, DAT, ACK,8'hFF};	// DATA1_L, write to AN1
 	5'd11: ucode<={4'b0000,1'b0, DAT, ACK,8'hFF};	// DATA2_U
 	5'd12: ucode<={4'b0100,1'b0, DAT, ACK,8'hFF};	// DATA2_L, write to AN2
 	5'd13: ucode<={4'b0000,1'b0, DAT, NAK,8'hFF};	// DATA3_U
 	5'd14: ucode<={4'b1000,1'b0, DAT,1'bx,8'hXX};	// DATA3_L, write to AN3
 	5'd15: ucode<={4'b0000,1'b1, STP,1'bx,8'hXX};	// STOP, GOTO 0
 	
 	// Init: configuring ADC registers
 	5'd16: ucode<={4'b0000,1'b0, STA, NAK,8'h90};	// START, Slave address, write
 	5'd17: ucode<={4'b0000,1'b0, DAT, NAK,8'h80};	// reg #0, increment address
 	5'd18: ucode<={4'b0000,1'b0, DAT, NAK,8'hFC};	// Auto-Burst Scan with Sleep mode, ch #0
 	5'd19: ucode<={4'b0000,1'b0, DAT,1'bx,8'hXX};	// send last byte
 	5'd20: ucode<={4'b0000,1'b0, STP,1'bx,8'hXX};	// STOP
 	
 	5'd21: ucode<={4'b0000,1'b0, STA, NAK,8'h90};	// START, Slave address, write
 	5'd22: ucode<={4'b0000,1'b0, DAT, NAK,8'h92};	// reg #0x12, increment address 
 	5'd23: ucode<={4'b0000,1'b0, DAT, NAK,8'h04};	// INTCFG: INT=BUSY, active low
 	5'd24: ucode<={4'b0000,1'b0, DAT, NAK,8'h20};	// SLPCFG: Sleep: 2.5ms/4
 	5'd25: ucode<={4'b0000,1'b0, DAT, NAK,8'h04};	// ACQCFG: 4*2+6 = 14us
 	5'd26: ucode<={4'b0000,1'b0, DAT,1'bx,8'hXX};	// send last byte
 	5'd27: ucode<={4'b0000,1'b1, STP,1'bx,8'hXX};	// STOP, GOTO 0
 
 	default: ucode<=16'hxxxx;
 	endcase
 	
 // Output registers
 // notice the ACK bit hasn't been yet shifted in when 'nxtinstr' is asserted
 reg [7:0]olddat;	// previous byte
 always @(posedge clkbit) if (nxtinstr) olddat<=sh[7:0];
 reg [11:0]an0;
 reg [11:0]an1;
 reg [11:0]an2;
 reg [11:0]an3;
 always @(posedge clkbit) begin
 	if (nxtinstr & wr0) an0<={olddat,sh[7:4]};
 	if (nxtinstr & wr1) an1<={olddat,sh[7:4]};
 	if (nxtinstr & wr2) an2<={olddat,sh[7:4]};
 	if (nxtinstr & wr3) an3<={olddat,sh[7:4]};
 end
 
 // INT trigger
 // (Datasheet errata? There are 4 busy pulses, one per channel, when the datasheet
 // shows only one pulse on fig. 28 "Auto-Burst Scan With Sleep Operation Example".
 // Anyway, a workaround is implemented)
 reg [3:0]tim;	// Monostable timer (4 busy pulses -> single pulse)
 always @(posedge clkbit) tim <= int ? tim+(tim!=15) : 0;
 
 wire data_av =(tim==14); // Data Available for read
 
 // Sample Clock
 reg sampleck=0;
 always @(posedge clkbit) sampleck<= data_av ? 1'b0 :(goto ? 1'b1 : sampleck);
 
 assign sampletick = sampleck;
 assign ana0 = an0;
 assign ana1 = an1;
 assign ana2 = an2;
 assign ana3 = an3;
 
endmodule

module main_v12f9c2 (
 input [11:0] a,
 output [7:0] b
);
 assign b = a[11:4];
endmodule
