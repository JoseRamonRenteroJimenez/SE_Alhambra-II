// Code generated by Icestudio 0.12

`default_nettype none

//---- Top entity
module main #(
 parameter v82d58a = 7'b1001000
) (
 input v3c0e8e,
 input vf01f19,
 input vc8d84d,
 output [7:0] vf12791,
 output va4c9ae,
 output [0:7] vinit
);
 localparam p3 = v82d58a;
 wire w0;
 wire w1;
 wire [0:7] w2;
 wire [0:6] w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:7] w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 assign w0 = vf01f19;
 assign vf12791 = w2;
 assign va4c9ae = w5;
 assign w11 = vc8d84d;
 assign w13 = v3c0e8e;
 assign w14 = v3c0e8e;
 assign w14 = w13;
 v21cfcc vb4463f (
  .v9fb85f(w1)
 );
 va75048 #(
  .vc5c8ea(p3)
 ) vb8cae4 (
  .v659de2(w4)
 );
 main_v4950d5 v4950d5 (
  .sda(w0),
  .fast_mode(w1),
  .data_rd(w2),
  .addr(w4),
  .scl(w5),
  .rw(w6),
  .enable(w7),
  .ready(w8),
  .busy(w9),
  .data_wr(w10),
  .rst(w12),
  .clk(w13)
 );
 main_vcc0382 vcc0382 (
  .rw(w6),
  .enable(w7),
  .ready(w8),
  .busy(w9),
  .data(w10),
  .start(w11),
  .clk(w14)
 );
 v21cfcc v4c7409 (
  .v9fb85f(w12)
 );
 assign vinit = 8'b00000000;
endmodule

//---------------------------------------------------
//-- ADC0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Lectura conversor A/D 0
//---------------------------------------------------
//---- Top entity
module v21cfcc (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v21cfcc_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

//---------------------------------------------------
//-- 0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Un bit constante a 0
//---------------------------------------------------

module v21cfcc_vb2eccd (
 output q
);
 //-- Bit constante a 0
 assign q = 1'b0;
 
 
endmodule
//---- Top entity
module va75048 #(
 parameter vc5c8ea = 7'h00
) (
 output [6:0] v659de2
);
 localparam p0 = vc5c8ea;
 wire [0:6] w1;
 assign v659de2 = w1;
 va75048_v465065 #(
  .V(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- Constante-7bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor constante generico para bus de 7 bits
//---------------------------------------------------

module va75048_v465065 #(
 parameter V = 0
) (
 output [6:0] k
);
 assign k = V;
endmodule

module main_v4950d5 (
 input clk,
 input rst,
 input sda,
 input enable,
 input [6:0] addr,
 input rw,
 input [7:0] data_wr,
 input fast_mode,
 output busy,
 output ack_error,
 output [7:0] data_rd,
 output ready,
 output scl,
 output scl2,
 output sda2
);
 parameter  BUS_CLK_400  = 400_000;
 parameter  BUS_CLK_100  = 100_000;
 parameter  CLK_FREQ = 12_000_000;  //-- 100_000_000 Initial value
 localparam DIVIDER_400  = (CLK_FREQ/BUS_CLK_400/4);
 localparam DIVIDER_100  = (CLK_FREQ/BUS_CLK_100/4);
 
 localparam IDLE      = 4'b0000;
 localparam START     = 4'b0001;
 localparam COMMAND   = 4'b0010;
 localparam SLV_ACK1  = 4'b0011;
 localparam WR        = 4'b0100;
 localparam RD        = 4'b0101;
 localparam SLV_ACK2  = 4'b0110;
 localparam MSTR_ACK  = 4'b0111;
 localparam STOP      = 4'b1000;
 
 reg [3:0] state = IDLE;
 reg       stretch;
 reg [9:0] count;
 reg [9:0] pre_div;
 reg       ack_error;
 reg       data_clk;
 reg       data_clk_prev;
 wire      scl_in;
 reg       scl_clk;
 reg       scl_enable = 0;
 wire      sda_in;
 wire       sda_enable;
 reg       sda_int = 1'b1;
 reg [7:0] data_rx;
 reg [3:0] bit_cnt = 4'h7;
 reg [7:0] data_tx;
 reg [7:0] addr_rw;
 
 
 
 reg busy;
 [7:0] data_rd;
 
 
 always @ (posedge clk or posedge rst)
 begin
     if (rst) begin
         stretch <= 0;
         count <= 0;
     end else begin
         data_clk_prev <= data_clk;
 
         if (fast_mode)
             pre_div <= DIVIDER_400;
         else
             pre_div <= DIVIDER_100;
 
         if (count == pre_div*4-1) begin
             count <= 0;
         end else if (stretch == 1'b0) begin
             count <= count + 1;
         end
 
         if (count > 0 && count <= pre_div-1) begin
             scl_clk <= 1'b0;
             data_clk <= 1'b0;
         end else if (count >= pre_div && count <= pre_div*2-1) begin
             scl_clk <= 1'b0;
             data_clk <= 1'b1;
         end else if (count >= pre_div*2 && count <= pre_div*3-1) begin
             scl_clk <= 1'b1;
             if (scl_in == 1'b0)
                 stretch <= 1'b1;
             else
                 stretch <= 1'b0;
             data_clk <= 1'b1;
         end else begin
             scl_clk <= 1'b1;
             data_clk <= 1'b0;
         end
     end
 end
 
 always @ (posedge clk or posedge rst)
 begin
     if (rst) begin
         busy <= 1'b0;
         scl_enable <= 1'b0;
         sda_int <= 1'b1;
         ack_error <= 1'b0;
         bit_cnt <= 4'h7;
         state <= IDLE;
         data_rd <= 8'b00000000;
     end else begin
         if (data_clk == 1'b1 && data_clk_prev == 1'b0) begin
             case (state)
                 IDLE: begin
                     if (enable == 1'b1) begin
                         busy <= 1'b1;
                         addr_rw <= {addr, rw};
                         state <= START;
                     end else begin
                         busy <= 1'b0;
                         state <= IDLE;
                     end
                 end
 
                 START: begin
                     busy <= 1'b1;
                     sda_int <= addr_rw[bit_cnt];
                     state <= COMMAND;
                 end
 
                 COMMAND: begin
                     if (bit_cnt == 4'b0000) begin
                         sda_int <= 1'b1;
                         bit_cnt <= 4'h7;
                         state<= SLV_ACK1;
                     end else begin
                         bit_cnt <= bit_cnt - 1;
                         sda_int <= addr_rw[bit_cnt-1];
                         state <= COMMAND;
                     end
                 end
 
                 SLV_ACK1: begin
                     if (addr_rw[0] == 1'b0) begin
                         sda_int <= data_tx[bit_cnt];
                         state <= WR;
                         data_tx <= data_wr;
                     end else begin
                         sda_int <= 1'b1;
                         state <= RD;
                     end
                 end
 
                 WR: begin
                     if (bit_cnt == 4'b0000) begin
                         sda_int <= 1'b1;
                         bit_cnt <= 4'h7;
                         state <= SLV_ACK2;
                         busy <= 1'b0;
                     end else begin
                         bit_cnt <= bit_cnt - 1;
                         sda_int <= data_tx[bit_cnt-1];
                         state <= WR;
                         busy <= 1'b1;
                     end
                 end
 
                 RD: begin
                     if (bit_cnt == 4'b0000) begin
                         if (enable == 1'b1 && addr_rw == {addr, rw})
                             sda_int <= 1'b0;
                         else
                             sda_int <= 1'b1;
                         bit_cnt <= 4'h7;
                         data_rd <= data_rx;
                         state <= MSTR_ACK;
                         busy <= 1'b0;
                     end else begin
                         bit_cnt <= bit_cnt - 1;
                         state <= RD;
                         busy <= 1'b1;
                     end
                 end
 
                 SLV_ACK2: begin
                     if (enable == 1'b1) begin
                         addr_rw <= {addr, rw};
                         data_tx <= data_wr;
                         if (addr_rw == {addr, rw}) begin
                             sda_int <= data_wr[bit_cnt];
                             state <= WR;
                         end else begin
                             state <= START;
                         end
                     end else begin
                         state <= STOP;
                     end
                 end
 
                 MSTR_ACK: begin
                     if (enable == 1'b1) begin
                         addr_rw <= {addr, rw};
                         data_tx <= data_wr;
                         if (addr_rw == {addr, rw}) begin
                             sda_int <= 1'b1;
                             state <= RD;
                         end else begin
                             state <= START;
                         end
                     end else begin
                         state <= STOP;
                     end
                 end
 
                 STOP: begin
                     busy <= 1'b0;
                     state <= IDLE;
                 end
 
             endcase
         end else if (data_clk == 1'b0 && data_clk_prev == 1'b1) begin
             case (state)
                 START: begin
                     if (scl_enable == 1'b0) begin
                         scl_enable <= 1'b1;
                         ack_error <= 1'b0;
                     end
                 end
 
                 SLV_ACK1: begin
                     if (sda_in != 1'b0 || ack_error == 1'b1)
                         ack_error <= 1'b1;
                 end
 
                 RD: begin
                     data_rx[bit_cnt] <= sda_in;
                 end
 
                 SLV_ACK2: begin
                     if (sda_in != 1'b0 || ack_error == 1'b1)
                         ack_error <= 1'b1;
                 end
 
                 STOP: begin
                     scl_enable <= 1'b0;
                 end
             endcase
         end
     end
 end
 
 assign sda_enable = (state == START) ? data_clk_prev :
                     (state == STOP) ? !data_clk_prev : sda_int;
                     
 assign ready = (state == IDLE);
 
 //Tri-State buffer controll
 SB_IO # (
     .PIN_TYPE(6'b1010_01),
     .PULLUP(1'b0)
 ) scl_io (
     .PACKAGE_PIN(scl),
     .OUTPUT_ENABLE(scl_enable == 1'b1 && scl_clk == 1'b0),
     .D_OUT_0(1'b0),
     .D_IN_0(scl_in)
 );
 
 //Tri-State buffer controll
 SB_IO # (
     .PIN_TYPE(6'b1010_01),
     .PULLUP(1'b0)
 ) sda_io (
     .PACKAGE_PIN(sda),
     .OUTPUT_ENABLE(sda_enable == 1'b0),
     .D_OUT_0(1'b0),
     .D_IN_0(sda_in)
 );
 
 assign scl2 = scl_in;
 assign sda2 = sda_in;
 
 
endmodule

module main_vcc0382 (
 input clk,
 input busy,
 input ready,
 input start,
 output enable,
 output [7:0] data,
 output rw
);
 
 
 localparam IDLE = 4'b0000;
 localparam WR1 = 4'b0001;
 localparam WR2 = 4'b0010;
 localparam WR3 = 4'b0011;
 localparam RD2 = 4'b0100;
 localparam IDLE2 = 4'b0101;
 localparam s2_WR1 = 4'b0110;
 localparam s2_WR2 = 4'b0111;
 localparam s2_RD1 = 4'b1000;
 localparam s2_RD2 = 4'b1001;
 
 
 //-- Control signals
 reg enable = 0;
 reg rw = 0;
 reg [7:0] data;
 
 //-- fsm states
 reg [3:0] state = IDLE;
 reg [3:0] next_state = IDLE;
 
 //-- Transition between states
 always @(posedge clk)
     state <= next_state;
     
 //-- Control signal generation and next states
 always @(*) begin
 
   //-- Default values
   next_state = state;      //-- Stay in the same state by default
   enable = 0;
   rw = 0;
   data = 8'h00;
   
  case(state)
 
     //-- Idle state
     //-- Remain in this state until the start is activated
     IDLE: begin
         next_state = WR1;
     end
 
     //-- Writting 1 state
     //-- The writting phase is started
     //-- Remains in this state until ready is 0 
     WR1: begin
       enable = 1;
       if (busy == 1)
         next_state = WR2;
     end
 
     //-- Writting 2 phase: Seleccting the Reg 0x01 by writting 0x01
     //-- Wait until ready is 1
     WR2: begin
       enable = 1;
       
       if (busy == 0)
         next_state = WR3;
     end
 
     //-- Reading 1: Prepare for reading the reg 0x01
     //-- Wait until ready is 0
     WR3: begin
       enable = 1;
       data = 8'hC4;
       if (busy == 1)
         next_state = IDLE2;
     end
     
     //-- Idle state
     //-- Remain in this state until the start is activated
     IDLE2: begin
       data = 8'h2;
       if (start == 1)
         next_state = s2_WR1;
     end
 
     //-- Writting 1 state
     //-- The writting phase is started
     //-- Remains in this state until ready is 0 
     s2_WR1: begin
       enable = 1;
       data = 8'h2;
       rw = 0;
       if (ready == 0)
         next_state = s2_WR2;
     end
 
     //-- Writting 2 phase: Seleccting the Reg 0x01 by writting 0x01
     //-- Wait until ready is 1
     s2_WR2: begin
       data = 8'h2;
       if (ready == 1)
         next_state = s2_RD1;
     end
 
     //-- Reading 1: Prepare for reading the reg 0x01
     //-- Wait until ready is 0
     s2_RD1: begin
       enable = 1;
       rw = 1;
       data = 8'h2;
       if (ready == 0)
         next_state = s2_RD2;
     end
     
     //-- Reading 2: Read the 0x01 register
     //-- Wait until ready is 1
     s2_RD2: begin
       data = 8'h2;
       rw = 1;
       if (ready == 1)
         next_state = IDLE2;
     end
     
 
     default: begin
       enable = 0;
       rw = 0;
     end
 
   endcase 
   
   
 end
 
endmodule
