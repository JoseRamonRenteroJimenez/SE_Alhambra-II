// Code generated by Icestudio 0.12
// Wed, 20 Aug 2025 23:53:25 GMT

`default_nettype none

//---- Top entity
module main #(
 parameter vec4673 = 'h0400_0000,
 parameter vc4dd14 = 100000,
 parameter v57fab4 = 250
) (
 input v87186f,
 input v4dc0ee,
 input [31:0] v867561,
 input v8859f4,
 input [31:0] v23504b,
 input [3:0] v1c4ad8,
 input vclk,
 output vfe2384,
 output [31:0] v504d16,
 output v10383b,
 output v84b29c,
 output v6858be,
 output [6:0] vacc282,
 output va93703,
 output [3:0] vabd030,
 output va71e9d,
 output v873e47,
 output v93941f,
 output v889e40,
 output [0:7] vinit,
 inout v3e4632,
 inout v12290d,
 inout v4ecea0,
 inout v8d37ee,
 inout va45fa7,
 inout vf6b416
);
 localparam p0 = vec4673;
 localparam p1 = v57fab4;
 localparam p14 = vc4dd14;
 wire [0:6] w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire [0:3] w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 wire w29;
 wire w30;
 wire [0:31] w31;
 wire [0:31] w32;
 wire [0:31] w33;
 wire w34;
 wire w35;
 wire w36;
 wire w37;
 wire w38;
 wire [0:31] w39;
 wire [0:3] w40;
 wire w41;
 wire w42;
 wire w43;
 wire w44;
 wire w45;
 wire [0:6] w46;
 wire [0:7] w47;
 wire w48;
 wire [0:7] w49;
 wire [0:3] w50;
 wire [0:2] w51;
 assign vacc282 = w2;
 assign v4ecea0 = w3;
 assign v8d37ee = w4;
 assign va45fa7 = w5;
 assign vf6b416 = w6;
 assign vabd030 = w7;
 assign v6858be = w8;
 assign va93703 = w9;
 assign v3e4632 = w10;
 assign va71e9d = w11;
 assign v873e47 = w12;
 assign v93941f = w13;
 assign v12290d = w16;
 assign v84b29c = w17;
 assign v10383b = w18;
 assign v889e40 = w19;
 assign w20 = vclk;
 assign w21 = v87186f;
 assign w22 = v87186f;
 assign w23 = v87186f;
 assign w24 = v87186f;
 assign vfe2384 = w26;
 assign w27 = v4dc0ee;
 assign w28 = v4dc0ee;
 assign w29 = v4dc0ee;
 assign w30 = v4dc0ee;
 assign v504d16 = w31;
 assign w32 = v867561;
 assign w33 = v867561;
 assign w35 = v8859f4;
 assign w36 = v8859f4;
 assign w39 = v23504b;
 assign w40 = v1c4ad8;
 assign w22 = w21;
 assign w23 = w21;
 assign w23 = w22;
 assign w24 = w21;
 assign w24 = w22;
 assign w24 = w23;
 assign w25 = w18;
 assign w28 = w27;
 assign w29 = w27;
 assign w29 = w28;
 assign w30 = w27;
 assign w30 = w28;
 assign w30 = w29;
 assign w33 = w32;
 assign w34 = w5;
 assign w36 = w35;
 assign w37 = w6;
 assign w41 = w17;
 assign w42 = w3;
 assign w43 = w8;
 assign w44 = w4;
 assign w46 = w2;
 assign w48 = w9;
 assign w50 = w7;
 main_vadbda8 #(
  .Addr(p0)
 ) vadbda8 (
  .addr_in(w32),
  .bit_valid(w35),
  .i2c_cs(w38)
 );
 main_v6d4014 #(
  .Hz(p14)
 ) v6d4014 (
  .clk_o(w15),
  .clk(w20)
 );
 main_v6e0755 v6e0755 (
  .sda(w16),
  .sda_I(w17),
  .clk(w22),
  .resetn(w28),
  .sda_O(w42),
  .sda_T(w44)
 );
 main_v0e7a2b v0e7a2b (
  .scl(w10),
  .scl_I(w18),
  .clk(w21),
  .resetn(w27),
  .scl_O(w34),
  .scl_T(w37)
 );
 main_vd61014 #(
  .DIVIDER(p1)
 ) vd61014 (
  .sda_O(w3),
  .sda_T(w4),
  .scl_O(w5),
  .scl_T(w6),
  .states(w7),
  .busy(w9),
  .debbug_scl_clk(w11),
  .debbug_scl_ena(w12),
  .debbug_data_clk(w13),
  .i2c_clk(w15),
  .flag_debbug_signal(w19),
  .clk(w24),
  .scl_I(w25),
  .rstn(w30),
  .sda_I(w41),
  .ena(w43),
  .rw(w45),
  .slv_addr(w46),
  .data_in(w47),
  .data_rd(w49),
  .bit_cnt_signal(w51)
 );
 main_vecfcb9 vecfcb9 (
  .slv_addr(w2),
  .enable_start(w8),
  .clk(w23),
  .bus_data_enable(w26),
  .rstn(w29),
  .bus_data_out(w31),
  .Bus_addr(w33),
  .valid(w36),
  .serdat_cs(w38),
  .Bus_data(w39),
  .mem_wstrb(w40),
  .rw(w45),
  .data_write(w47),
  .I2C_Busy(w48),
  .data_out(w49),
  .I2C_State(w50),
  .I2C_bit_count(w51)
 );
 assign vinit = 8'b00000000;
endmodule

//---------------------------------------------------
//-- I2C_soc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Periférico encargado de la comunicación a través del bus I2C.
//---------------------------------------------------

module main_vadbda8 #(
 parameter Addr = 0
) (
 input [31:0] addr_in,
 input bit_valid,
 output i2c_cs
);
 assign i2c_cs = (addr_in[31:6] == Addr[31:6]) & bit_valid;
endmodule

module main_v6d4014 #(
 parameter Hz = 0
) (
 input clk,
 output clk_o
);
 //Este módulo no está en uso. 
 //Era el divisor de frecuencias antiguo
 
 //parameter HZ=1;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000/Hz;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter = 0;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- REgistro con el valor del reloj
 reg clk_out = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_out <= ~clk_out;
 
 
 assign clk_o = clk_out;  
 
endmodule

module main_v6e0755 (
 input clk,
 input resetn,
 input sda_O,
 input sda_T,
 output sda_I,
 output sda
);
 wire sda_pad_in;
 SB_IO #(
         .PIN_TYPE(6'b1010_01), 
         .PULLUP(1'b0)          
     ) sda_tri (
         .PACKAGE_PIN(sda),     
         .OUTPUT_ENABLE(~sda_T),
         .D_OUT_0(1'b0),        
         .D_IN_0(sda_pad_in)    
     );
 assign sda_I = sda_pad_in;
endmodule

module main_v0e7a2b (
 input clk,
 input resetn,
 input scl_O,
 input scl_T,
 output scl_I,
 inout scl
);
 //Copro
 wire scl_pad_in;
  
 SB_IO #(
         .PIN_TYPE(6'b1010_01), // Pin como E/S simple, sin registros internos
         .PULLUP(1'b0)          // Pull-up interno desactivado (usar resistencias externas para I²C)
     ) scl_tri(
         .PACKAGE_PIN(scl),     // Conecta al pin físico SCL
         .OUTPUT_ENABLE(~scl_T),// '1' = conduce (saca 0), '0' = Hi-Z (línea libre)
         .D_OUT_0(1'b0),        // Valor a sacar cuando conduce (siempre 0 en open-drain)
         .D_IN_0(scl_pad_in)    // Valor leído del pin SCL (estado real de la línea)
     );
 assign scl_I = scl_pad_in;
 //assign sda = (sda_T == 1'b0) ? sda_O : 1'bz;
 //assign sda_I = sda;
 
 //assign scl = (scl_T == 1'b0) ? scl_O : 1'bz;
 //assign scl_I = scl;
endmodule

module main_vd61014 #(
 parameter DIVIDER = 0
) (
 input i2c_clk,
 input clk,
 input rstn,
 input ena,
 input [6:0] slv_addr,
 input rw,
 input [7:0] data_in,
 input scl_I,
 input sda_I,
 output busy,
 output [7:0] data_rd,
 output ack_error,
 output sda_O,
 output sda_T,
 output scl_O,
 output scl_T,
 output [3:0] states,
 output [2:0] bit_cnt_signal,
 output data_clkp,
 output streetchip,
 output debbug_scl_clk,
 output debbug_scl_ena,
 output debbug_data_clk,
 output [7:0] debbug_slv_Addr,
 output flag_debbug_signal
);
 // Estados como en el VHDL
 localparam READY        = 4'd0;
 localparam START        = 4'd1;
 localparam START_HOLD   = 4'd2;
 localparam COMMAND      = 4'd3;
 localparam SLV_ACK_1    = 4'd4;
 localparam WR           = 4'd5;
 localparam RD           = 4'd6;
 localparam SLV_ACK_2    = 4'd7;
 localparam MSTR_ACK     = 4'd8;
 localparam STOP         = 4'd9;
 localparam CNT_W = $clog2(DIVIDER*4);
 
 // Registros “VHDL-like”
 reg [3:0] state = READY;
 reg [2:0] bit_cnt;
 reg       data_clk;         // 0: Q1/Q4, 1: Q2/Q3
 reg       scl_clk;          // 0: forzar 0, 1: soltar (Hi-Z via T)
 reg       scl_ena;
 reg       sda_int;          // 0=conducir 0, 1=soltar (open-drain)
 reg [7:0] data_tx, data_rx;
 reg [7:0] addr_rw;
 reg [7:0] reg_data_rd;
 reg       reg_busy;
 reg       reg_ack_error;
 reg       stretch;
 reg [CNT_W-1:0] cuenta;
 reg       reg_rw;
 
 reg flag_debbug = 1'b0;
 
 // --- Divisor y generación de clocks ---
 always @(posedge clk or negedge rstn) begin
   if (!rstn) begin
     cuenta   <= {CNT_W{1'b0}};
     data_clk <= 1'b0;
     scl_clk  <= 1'b0;
     stretch  <= 1'b0;
   end else begin
     // hold si hay stretching (solo cuando pretendemos SCL alto)
     if (cuenta == DIVIDER*4-1)        cuenta <= {CNT_W{1'b0}};
     else if (!stretch)                cuenta <= cuenta + 1'b1;
 
     // Q1: SCL=0, data_clk=0
     if (cuenta < DIVIDER) begin
       scl_clk  <= 1'b0;
       data_clk <= 1'b0;
     end
     // Q2: SCL=0, data_clk=1
     else if (cuenta < DIVIDER*2) begin
       scl_clk  <= 1'b0;
       data_clk <= 1'b1;
     end
     // Q3: SCL liberado, data_clk=1 (leer ACK/datos; detectar stretching)
     else if (cuenta < DIVIDER*3) begin
       scl_clk  <= 1'b1;   // liberar (tri-state mediante T)
       data_clk <= 1'b1;
       // stretching si intentamos alto pero el pin sigue bajo
       if (scl_I == 1'b0) stretch <= 1'b1;
       else               stretch <= 1'b0;
     end
     // Q4: SCL liberado, data_clk=0
     else begin
       scl_clk  <= 1'b1;
       data_clk <= 1'b0;
       stretch  <= 1'b0;
     end
   end
 end
 
 // --- FSM: escribir SDA con SCL bajo (posedge data_clk) ---
 always @(posedge data_clk or negedge rstn) begin
   if (!rstn) begin
     state        <= READY;
     reg_busy     <= 1'b1;
     scl_ena      <= 1'b0;
     sda_int      <= 1'b1;
     bit_cnt      <= 3'd7;
     reg_data_rd  <= 8'd0;
     addr_rw      <= 8'd0;
     data_tx      <= 8'd0;
     reg_rw       <= 1'd0;
     flag_debbug <= 1'b0;
   end else begin
     case (state)
       READY: begin
         if (ena) begin
           reg_busy <= 1'b1;
           //addr_rw[7:1] <= addr_rw[6:0]; // copiar dirección sin RW
           //addr_rw[0] <= rw; // RW=0: write, RW=1: read 
           addr_rw  <= {slv_addr, rw};
           reg_rw   <= rw;
           data_tx  <= data_in;
           sda_int  <= 1'b1;     // preparar START (SDA baja)
           state    <= START_HOLD;
         end else begin
           reg_busy <= 1'b0;
           scl_ena  <= 1'b0;
         end
       end
 
       START_HOLD: begin
         reg_busy <= 1'b1;
         scl_ena  <= 1'b1;       // habilita SCL
         sda_int  <= 1'b1;       // mantener SDA baja un cuarto
         state    <= START;
       end
 
       START: begin
         sda_int <= addr_rw[bit_cnt]; // primer bit (MSB)
         state   <= COMMAND;
       end
 
       COMMAND: begin
         reg_busy <= 1'b1;
         if (bit_cnt == 0) begin
           sda_int <= 1'b1;      // soltar para ACK del esclavo
           bit_cnt <= 3'd7;
           state   <= SLV_ACK_1;
         end else begin
           bit_cnt <= bit_cnt - 1'b1;
           sda_int <= addr_rw[bit_cnt-1]; // **ojo**: -1 como en VHDL
         end
       end
 
       SLV_ACK_1: begin
         if (!reg_rw) begin        // write
           sda_int <= data_tx[bit_cnt];
           state   <= WR;
         end else begin            // read
           sda_int <= 1'b1;        // soltar para leer
           state   <= RD;
         end
       end
 
       WR: begin
         if (bit_cnt == 0) begin
           sda_int <= 1'b1;        // soltar para ACK del esclavo
           bit_cnt <= 3'd7;
           state   <= SLV_ACK_2;
         end else begin
         reg_busy <= 1'b1;
         
           bit_cnt <= bit_cnt - 1'b1;
           sda_int <= data_tx[bit_cnt-1]; // **ojo**: -1
         end
       end
 
       RD: begin
         reg_busy <= 1'b1;
         if (bit_cnt == 0) begin
           sda_int     <= (ena && rw) ? 1'b0 : 1'b1; // ACK (0) si seguimos leyendo
           bit_cnt     <= 3'd7;
           reg_data_rd <= data_rx;
           state       <= MSTR_ACK;
         end else begin
           bit_cnt <= bit_cnt - 1'b1;
           // sda_int permanece soltada
         end
       end
 
       SLV_ACK_2: begin
         if (ena) begin
             reg_busy <= 1'b0;     // “acepta” continuar
             bit_cnt      <= 3'd7;
           data_tx  <= data_in;
           if (rw == 1 || addr_rw[7:1] != slv_addr) begin
             addr_rw <= {slv_addr, rw};
             reg_rw  <= rw;
             state   <= COMMAND;  // repeated START hacia lectura
             sda_int <= addr_rw[bit_cnt];
             
           end else begin
             flag_debbug = 1'b1;
             sda_int <= data_tx[bit_cnt];
             state   <= WR;
           end
         end else begin
           scl_ena <= 1'b0;
           state   <= STOP;
         end
       end
 
       MSTR_ACK: begin
         if (ena) begin
           reg_busy <= 1'b0;     // “acepta” continuar
           data_tx  <= data_in;
           if (rw == 0 || slv_addr != addr_rw[7:1]) begin
             addr_rw <= {slv_addr, rw};
             reg_rw  <= rw;
             state   <= START_HOLD;  // repeated START hacia escritura
           end else begin
             sda_int <= 1'b0;        // ACK para más lectura
             state   <= RD;
           end
         end else begin
           scl_ena <= 1'b0;
           state   <= STOP;
         end
       end
 
       STOP: begin
         reg_busy <= 1'b0;
         scl_ena  <= 1'b0;
         sda_int  <= 1'b1;       // STOP (SDA sube con SCL alto en Q3)
         state    <= READY;
       end
 
       default: state <= READY;
     endcase
   end
 end
 
 // --- Muestreo con SCL alto (negedge data_clk) ---
 always @(negedge data_clk or negedge rstn) begin
   if (!rstn) begin
     reg_ack_error <= 1'b0;
     data_rx       <= 8'd0;
   end else begin
     case (state)
       START:     reg_ack_error <= 1'b0;                  // limpia flag
       SLV_ACK_1: reg_ack_error <= sda_I | reg_ack_error; // 0=ACK, 1=NACK
       RD:        data_rx[bit_cnt] <= sda_I;              // lee bit
       SLV_ACK_2: reg_ack_error <= sda_I | reg_ack_error;
     endcase
   end
 end
 
 // --- Mapeo de salidas (igual filosofía al VHDL) ---
 // START/STOP forman la condición usando data_clk (Q2/Q3) 
 wire sda_ena_n = (state == START) ? data_clk :
                  (state == STOP)  ? ~data_clk :
                                      sda_int;
 
 assign scl_O = scl_clk;                          // valor “no importa” cuando T=1
 assign scl_T = ~(scl_ena & ~scl_clk);            // T=0 cuando scl_ena=1 y scl_clk=0
 assign sda_O = 1'b0;                             // open-drain puro
 assign sda_T = sda_ena_n;
 
 // debug
 assign busy           = reg_busy;
 assign data_rd        = reg_data_rd;
 assign ack_error      = reg_ack_error;
 assign states         = state;
 assign bit_cnt_signal = bit_cnt;
 assign data_clkp      = data_clk;
 assign streetchip     = stretch;
 assign debbug_scl_clk = scl_clk;
 assign debbug_scl_ena = scl_ena;
 assign debbug_data_clk= data_clk;
 assign debbug_slv_Addr= addr_rw;
 
 assign flag_debbug_signal = flag_debbug;
 
endmodule

module main_vecfcb9 (
 input clk,
 input rstn,
 input valid,
 input [3:0] mem_wstrb,
 input [31:0] Bus_addr,
 input [31:0] Bus_data,
 input serdat_cs,
 input [3:0] I2C_State,
 input I2C_Busy,
 input [7:0] data_out,
 input [2:0] I2C_bit_count,
 output enable_start,
 output rw,
 output [6:0] slv_addr,
 output [7:0] data_write,
 output [2:0] n_paquetes,
 output bus_data_enable,
 output [31:0] bus_data_out,
 output iflag_debbug_signal
);
 // Direcciones internas (como ya tenías)
 localparam READY        = 4'd0;
 localparam START        = 4'd1;
 localparam START_HOLD   = 4'd2;
 localparam COMMAND      = 4'd3;
 localparam SLV_ACK_1    = 4'd4;
 localparam WR           = 4'd5;
 localparam RD           = 4'd6;
 localparam SLV_ACK_2    = 4'd7;
 localparam MSTR_ACK     = 4'd8;
 localparam STOP         = 4'd9;
  
 localparam SLV_ADDR_REG    = 3'b000;
 localparam RW_REG          = 3'b001;
 localparam N_PQTS_REG    = 3'b010;
 localparam STATE_REG       = 3'b011;
 localparam BUSY_REG        = 3'b100;
 localparam DATA_OUT_REG    = 3'b101;
 localparam ENABLE_REG      = 3'b110;
 localparam DATA_WRITE_REG  = 3'b111;
  
 // Registros visibles + buffers
 reg [7:0]  dataArray [7:0];
 reg [31:0] buffer_data_out;
 reg [31:0] data_wr;                 
 reg        ack_r;
 
 reg [3:0] prev_i2c_state;
 reg       alreadyWritten = 1'b0; 
 
 reg flag_debbug = 1'b0;
  
 wire serdat_write = serdat_cs & |mem_wstrb; // Indicación de usuario y procesador de que podemos escribir
  
 always @(posedge clk or negedge rstn) begin
   if (!rstn) begin
     dataArray[0]     <= 8'b0;
     dataArray[1]     <= 8'b0;
     dataArray[2]     <= 8'b0;
     dataArray[3]     <= 8'b0;
     dataArray[4]     <= 8'b0;
     dataArray[5]     <= 8'b0;
     dataArray[6]     <= 8'b0;
     dataArray[7]     <= 8'b0;
     alreadyWritten   <= 1'b0; 
     buffer_data_out  <= 32'b0;
     data_wr          <= 32'b0;
     ack_r            <= 1'b0;
     prev_i2c_state <= READY;
 
     flag_debbug      <= 1'b0;
   end else begin
     
     // Datos actualizados de la máquina de estados
     dataArray[STATE_REG]    <= {4'b0, I2C_State};
     dataArray[BUSY_REG]     <= {7'b0, I2C_Busy};
     dataArray[DATA_OUT_REG] <= data_out;
 
     ack_r <= 1'b0;     
 
     //Lectura o escritura de registros desde cpu
     if (serdat_cs) begin
       ack_r <= 1'b1;
       if (serdat_write) begin
       
         // ESCRITURA
         if (Bus_addr[4:2] == DATA_WRITE_REG) begin
           //Un registro de 8 bits es menos de lo que se puede mandar. Desviamos la información a otro lugar.
           data_wr <= Bus_data;           // guarda los 4 bytes
         end else if(Bus_addr[4:2] == N_PQTS_REG) begin
           //Restamos el primer byte que ya va a ser enviado
           //Damos por hecho que aquí se cargan los bytes totales a enviar. El primero ya es implícito
           dataArray[Bus_addr[4:2]] <= Bus_data[7:0];
         end else begin
           dataArray[Bus_addr[4:2]] <= Bus_data[7:0];
         end
       end else begin
         // LECTURA
         if (Bus_addr[4:2] == DATA_WRITE_REG)
           //De igual manera, se puede leer mucho más que 8 bits
           buffer_data_out <= data_wr;
         else
           buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
       end
     end
 
     if (dataArray[N_PQTS_REG] <= 3'd0) begin 
       dataArray[ENABLE_REG] <= 8'b0;
     end
 
     if (I2C_State != WR && I2C_State != RD) begin
       alreadyWritten <= 1'b0;
     end
 
     case (I2C_State)
       WR: begin
         if (dataArray[N_PQTS_REG] > 8'b0 && !alreadyWritten) begin
           flag_debbug <= 1'b1;
           alreadyWritten <= 1'b1;
           data_wr <= {8'b0, data_wr[31:8]}; // desplaza el byte leído
           dataArray[N_PQTS_REG] <= dataArray[N_PQTS_REG] - 8'b1; 
         end
       end
       RD: begin
         if (dataArray[N_PQTS_REG] > 8'b0 && !alreadyWritten)begin
             dataArray[N_PQTS_REG] <= dataArray[N_PQTS_REG] - 8'b1;
             alreadyWritten <= 1'b1;
         end
       end
       STOP: begin
         dataArray[ENABLE_REG][0] <= 1'b0;
       end
     endcase
 
     prev_i2c_state <= I2C_State;
   end 
 end
 
 
 //Asignaciones
 assign bus_data_enable = ack_r;
 assign slv_addr[6:0] = dataArray[SLV_ADDR_REG][6:0];
 assign rw            = dataArray[RW_REG][0];
 assign n_paquetes    = dataArray[N_PQTS_REG][2:0];
 assign enable_start  = dataArray[ENABLE_REG][0];
 assign data_write    = data_wr[7:0];
 assign bus_data_out  = buffer_data_out;
 
 //assign iflag_debbug_signal = flag_debbug;
 assign iflag_debbug_signal = alreadyWritten;
 
endmodule
