// Code generated by Icestudio 0.12
// Sat, 05 Apr 2025 11:48:31 GMT

`default_nettype none

//---- Top entity
module main #(
 parameter v269dbc = 'h0210_0000
) (
 input v87186f,
 input v4dc0ee,
 input [31:0] v867561,
 input v8859f4,
 input [31:0] v23504b,
 output v9127c2,
 output vfe2384,
 output [31:0] v504d16,
 output [0:7] vinit,
 inout v1ced10,
 inout v80923c
);
 localparam p0 = v269dbc;
 wire w1;
 wire [0:6] w2;
 wire w3;
 wire [0:7] w4;
 wire [0:7] w5;
 wire [0:7] w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire [0:31] w12;
 wire w13;
 wire w14;
 wire [0:31] w15;
 assign v9127c2 = w7;
 assign v1ced10 = w8;
 assign w8 = v80923c;
 assign w9 = v80923c;
 assign w10 = v87186f;
 assign w11 = v4dc0ee;
 assign w12 = v867561;
 assign w14 = v8859f4;
 assign w15 = v23504b;
 assign w9 = w8;
 vf9bdaf #(
  .v6b316b(p0)
 ) v72f060 (
  .v18e78c(w1),
  .ve1f562(w12)
 );
 vb2090f vef47e6 (
  .v0e28cb(w1),
  .vcbab45(w13),
  .v3ca442(w14)
 );
 main_vecfcb9 vecfcb9 (
  .adc_addr(w2),
  .adc_rw(w3),
  .adc_data_write(w4),
  .adc_reg(w5),
  .Bus_data(w15)
 );
 main_vd906e1 vd906e1 (
  .addr(w2),
  .rw(w3),
  .data_wr(w4),
  .reg_obj(w5),
  .data_rd(w6),
  .ADC_SCL(w7),
  .ADC_SDA(w9),
  .clk(w10),
  .resetn(w11),
  .ena(w13)
 );
 main_v4e43a2 v4e43a2 (
  .data_tx(w6)
 );
 assign vinit = 8'b00000000;
endmodule

//---- Top entity
module vf9bdaf #(
 parameter v6b316b = 0
) (
 input [31:0] ve1f562,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = ve1f562;
 vf9bdaf_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 32 bits. Se compara si el operando es igual al parámetro
//---------------------------------------------------

module vf9bdaf_vd75681 #(
 parameter K = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a == K);
endmodule
//---- Top entity
module vb2090f (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vb2090f_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND
//---------------------------------------------------

module vb2090f_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta AND
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a & b;
 
 //-- endmodule
endmodule

module main_vecfcb9 (
 input [31:0] Bus_data,
 output [6:0] adc_addr,
 output adc_rw,
 output [15:8] adc_reg,
 output [23:16] adc_data_write
);
 // Asignación
 assign adc_addr = Bus_data[6:0];
 assign adc_rw   = Bus_data[7];
 assign adc_reg  = Bus_data[15:8];
 assign adc_data_write = Bus_data[23:16];
 
endmodule

module main_vd906e1 (
 input clk,
 input resetn,
 input ena,
 input [6:0] addr,
 input rw,
 input [7:0] reg_obj,
 input [7:0] data_wr,
 output busy,
 output ack_error,
 output [7:0] data_rd,
 output ADC_SCL,
 inout ADC_SDA
);
 // ADC I2C Master para Alhambra II compatible con IceStudio
 
 // Parámetros
 parameter INPUT_CLK = 12_000_000;
 parameter BUS_CLK   = 100_000;
 
 // Clock divider
 localparam DIVIDER = (INPUT_CLK / BUS_CLK) / 4;
 localparam NDIV = 8; // log2(375) ~= 8.5, usar 8 por seguridad
 
 //Flanco de bajada.
 reg clk_bit_prev;
 
 always @(posedge clk) begin
     clk_bit_prev <= clk_bit;
 end
 
 wire falling_edge_clk_bit = (clk_bit_prev == 1 && clk_bit == 0);
 
 // Señales internas
 reg [NDIV-1:0] clk_div = 0;
 reg clk_bit = 0;
 always @(posedge clk) begin
     clk_div <= (clk_div == DIVIDER - 1) ? 0 : clk_div + 1;
     if (clk_div == 0) clk_bit <= ~clk_bit;
 end
 
 // Estados
 localparam READY    = 4'd0;
 localparam START    = 4'd1;
 localparam COMMAND  = 4'd2;
 localparam SLV_ACK1 = 4'd3;
 localparam WR       = 4'd4;
 localparam RD       = 4'd5;
 localparam SLV_ACK2 = 4'd6;
 localparam MSTR_ACK = 4'd7;
 localparam STOP     = 4'd8;
 
 reg [3:0] state = READY;
 reg scl_en = 0;
 reg sda_int = 1;
 reg [7:0] addr_rw, data_tx, data_rx;
 reg [2:0] bit_cnt = 3'd7;
 reg [6:0] prev_addr = 7'b0;  // Addr previo
 
 // Señal interna
 reg ack_error_i;  // "i" de interna
 // Asignación a la salida generada por IceStudio
 assign ack_error = ack_error_i;
 
 assign data_rd = data_rx;
 assign busy = (state != READY);
 
 // SDA como salida Open Drain
 assign ADC_SDA = (sda_int == 0) ? 1'b0 : 1'bz;
 assign ADC_SCL = (scl_en == 1) ? clk_bit : 1'bz;
 
 always @(posedge clk_bit or negedge resetn) begin
     if (!resetn) begin
         state <= READY;
         sda_int <= 1;
         scl_en <= 0;
         bit_cnt <= 7;
     end else begin
         case (state)
             READY: begin
                 if (ena) begin
                     addr_rw <= {addr, rw};
                     data_tx <= data_wr;
                     //START
                     scl_en <= 1;
                     sda_int <= 0;
                     state <= START;
                 end
             end
             START: begin
                 sda_int <= addr_rw[bit_cnt];
                 state <= COMMAND;
             end
             COMMAND: begin
                 if (bit_cnt == 0) begin
                     sda_int <= 1;
                     bit_cnt <= 7;
                     state <= SLV_ACK1;
                 end else begin
                     bit_cnt <= bit_cnt - 1;
                     sda_int <= addr_rw[bit_cnt - 1];
                 end
             end
             SLV_ACK1: begin
                 if (rw == 0) begin
                     sda_int <= data_tx[bit_cnt];
                     state <= WR;
                 end else begin
                     sda_int <= 1;
                     state <= RD;
                 end
             end
             WR: begin
                 if (bit_cnt == 0) begin
                     sda_int <= 1;
                     bit_cnt <= 7;
                     state <= SLV_ACK2;
                 end else begin
                     bit_cnt <= bit_cnt - 1;
                     sda_int <= data_tx[bit_cnt - 1];
                 end
             end
             RD: begin
                 if (bit_cnt == 0) begin
                     bit_cnt <= 7;
                     sda_int <= 1;
                     state <= MSTR_ACK;
                 end else begin
                     bit_cnt <= bit_cnt - 1;
                     data_rx[bit_cnt] <= ADC_SDA;
                 end
             end
             SLV_ACK2: begin
                 if (ena) begin
                     addr_rw <= {addr, rw};
                     data_tx <= data_rw;
                     if (rw == 0 && addr == prev_addr) begin
                         bit_cnt <= 7;
                         sda_int <= data_rw[bit_cnt];
                         state <= WR;
                     end else begin // rw == 1 || addr != prev_addr
                         bit_cnt <= 7;
                         sda_int <= 1;
                         sda_int <= 0;
                         state <= START;
                     end 
                     prev_addr <= addr;
                 end else begin
                     scl_en <= 0;
                     sda_int <= 1;
                     state <= STOP;
                 end
             end
             MSTR_ACK: begin
                 if (ena) begin
                     addr_rw <= {addr, rw};
                     data_tx <= data_rw;
                     if (rw == 1 && addr == prev_addr) begin
                         bit_cnt <= 7;
                         sda_int <= 1;
                         state <= RD;
                     end else begin // rw == 0 || addr != prev_addr
                         sda_int <= 0;
                         state <= START;
                     end
                     prev_addr <= addr;
                 end else begin
                     scl_en <= 0;
                     sda_int <= 1;
                     state <= STOP;
                 end
             end
             STOP: begin
                 sda_int <= 1;
                 state <= READY;
             end
             default: state <= READY;
         endcase
     end
 end
 
 // Gestión del ack_error al estilo del ejemplo VHDL
 always @(posedge clk or negedge resetn) begin
     if (!resetn) begin
         ack_error_i <= 0;
     end else if (falling_edge_clk_bit) begin
         case (state)
             START:     ack_error_i <= 0;
             SLV_ACK1:  ack_error_i <= ADC_SDA | ack_error_i;
             SLV_ACK2:  ack_error_i <= ADC_SDA | ack_error_i;
             default:   ack_error_i <= ack_error_i;
         endcase
     end
 end
 
endmodule

module main_v4e43a2 (
 input [7:0] data_tx,
 output [31:0] adcData,
 output adcReady
);
 localparam zeros = 24'd0;
 assign adcData = {zeros, data_tx};
endmodule
