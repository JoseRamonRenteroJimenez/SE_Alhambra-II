// Code generated by Icestudio 0.12

`default_nettype none

//---- Top entity
module main #(
 parameter vec4673 = 'h0400_0000,
 parameter v9c4340 = 100000,
 parameter vdcbaf8 = 100000
) (
 input v87186f,
 input v4dc0ee,
 input [31:0] v867561,
 input v8859f4,
 input [31:0] v23504b,
 input [3:0] v1c4ad8,
 output v9127c2,
 output vfe2384,
 output [31:0] v504d16,
 output [7:0] v9d524f,
 output [3:0] v6c6273,
 output [0:7] vinit,
 inout v80923c
);
 localparam p0 = vec4673;
 localparam p3 = v9c4340;
 localparam p5 = vdcbaf8;
 wire [0:3] w1;
 wire [0:7] w2;
 wire w4;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire [0:31] w18;
 wire [0:31] w19;
 wire [0:31] w20;
 wire w21;
 wire w22;
 wire w23;
 wire [0:31] w24;
 wire [0:3] w25;
 wire w26;
 wire w27;
 wire w28;
 wire w29;
 wire [0:7] w30;
 wire [0:3] w31;
 wire w32;
 wire [0:31] w33;
 wire [0:2] w34;
 wire [0:7] w35;
 assign v6c6273 = w1;
 assign v9d524f = w2;
 assign w7 = v87186f;
 assign w8 = v87186f;
 assign w9 = v87186f;
 assign w10 = v87186f;
 assign v9127c2 = w11;
 assign w12 = v4dc0ee;
 assign w13 = v4dc0ee;
 assign w14 = v4dc0ee;
 assign vfe2384 = w15;
 assign w16 = v80923c;
 assign w17 = v80923c;
 assign v504d16 = w18;
 assign w19 = v867561;
 assign w20 = v867561;
 assign w21 = v8859f4;
 assign w22 = v8859f4;
 assign w24 = v23504b;
 assign w25 = v1c4ad8;
 assign w8 = w7;
 assign w9 = w7;
 assign w9 = w8;
 assign w10 = w7;
 assign w10 = w8;
 assign w10 = w9;
 assign w13 = w12;
 assign w14 = w12;
 assign w14 = w13;
 assign w17 = w16;
 assign w20 = w19;
 assign w22 = w21;
 assign w27 = w26;
 assign w29 = w28;
 assign w30 = w2;
 assign w31 = w1;
 main_vadbda8 #(
  .Addr(p0)
 ) vadbda8 (
  .addr_in(w19),
  .bit_valid(w21),
  .i2c_cs(w23)
 );
 main_v626e75 v626e75 (
  .state_out(w1),
  .clk(w4),
  .I2C_SCL(w11),
  .rstn(w13),
  .I2C_SDA(w16),
  .enable(w26),
  .rw(w28),
  .slv_addr(w30),
  .busy_out(w32),
  .data_in(w33),
  .n_paquetes(w34),
  .data_out(w35)
 );
 main_vecfcb9 vecfcb9 (
  .slv_addr(w2),
  .clk(w7),
  .rstn(w12),
  .bus_data_enable(w15),
  .bus_data_out(w18),
  .Bus_addr(w20),
  .valid(w22),
  .serdat_cs(w23),
  .Bus_data(w24),
  .mem_wstrb(w25),
  .enable_start(w26),
  .rw(w28),
  .I2C_State(w31),
  .I2C_Busy(w32),
  .data_write(w33),
  .n_paquetes(w34),
  .data_out(w35)
 );
 main_v390fcc #(
  .Frecuencia(p3)
 ) v390fcc (
  .clk_out(w4),
  .clk_in(w8)
 );
 main_vf5c265 #(
  .Frecuencia(p5)
 ) vf5c265 (
  .clk_out(w6),
  .clk_in(w9)
 );
 main_vc66ea6 vc66ea6 (
  .i2c_clk(w6),
  .clk(w10),
  .resetn(w14),
  .sda(w17),
  .ena(w27),
  .rw(w29)
 );
 assign vinit = 8'b00000000;
endmodule

//---------------------------------------------------
//-- I2C_soc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Periférico encargado de la comunicación a través del bus I2C.
//---------------------------------------------------

module main_vadbda8 #(
 parameter Addr = 0
) (
 input [31:0] addr_in,
 input bit_valid,
 output i2c_cs
);
 assign i2c_cs = (addr_in[31:6] == Addr[31:6]) & bit_valid;
endmodule

module main_v626e75 (
 input clk,
 input rstn,
 input enable,
 input rw,
 input [7:0] slv_addr,
 input [31:0] data_in,
 input [2:0] n_paquetes,
 output [3:0] state_out,
 output busy_out,
 output [7:0] data_out,
 inout I2C_SDA,
 inout I2C_SCL
);
 // -----------------------------
 // Parámetros de la máquina de estados
 // -----------------------------
 localparam READY       = 4'd0;
 localparam START       = 4'd1;
 localparam COMMAND     = 4'd2;
 localparam SLV_OBJ_ACK = 4'd3;
 localparam WRITE_DATA  = 4'd4;
 localparam WRITE_ACK   = 4'd5;
 localparam READ_DATA   = 4'd6;
 localparam READ_ACK    = 4'd7;
 localparam STOP        = 4'd8;
 
 // Bits más significativos
 localparam max_slv_Addr = 7;
 localparam max_data_wr = 31;
 
 // -----------------------------
 // Registros internos
 // -----------------------------
 reg [3:0] state = READY;            // Estado actual
 x1reg busy = 1'd0;                    // Flag de bus ocupado
 reg reg_data_ready = 1'b0;
 reg enable_reg = 1'd0;              // Latch para transición READY->START
 reg clk_enable = 1'b0;
 reg [2:0] counter = 3'd0;           // Cuenta hasta 8 bits de un envío
 reg [2:0] num_paquetes = 3'd0;      // Paquetes a enviar
 reg [31:0] wt_buffer = 32'b0;       // Buffer de escritura
 reg [7:0] rd_buffer = 8'd0;         // Buffer de lectura
 reg [7:0] slave_addr = 8'd0;        // Dirección del esclavo
 reg read_write = 1'd0;              // Lectura o escritura
 reg sda_out = 1'd0;                 // Salida de SDA
 reg write_enable = 1'd0;            // Habilitación de SDA
 reg enable_d;
 
 wire enable_edge = enable & ~enable_d;
 
 // -----------------------------
 // Asignaciones de salida
 // -----------------------------
 assign busy_out   = busy;
 assign data_out   = rd_buffer;
 assign I2C_SCL = (clk_enable && (clk == 1'b0)) ? 1'b0 : 1'bz;
 assign I2C_SDA    = (write_enable && (sda_out==1'b0)) ? 1'b0 : 1'bz; // Pin de SDA
 assign state_out  = state; // Estado actual
 
 // -----------------------------
 // Máquina de estados I2C
 // -----------------------------
 always @(posedge clk or negedge rstn) begin
     if (!rstn) begin
         // Reset global
         state          <= READY;
         busy           <= 1'd0;
         reg_data_ready <= 1'b0;
         enable_reg     <= 1'b0;
         write_enable   <= 1'd0;
         counter        <= 3'd0;
         num_paquetes   <= 3'd0;
         wt_buffer      <= 32'b0;
         rd_buffer      <= 8'd0;
         slave_addr     <= 8'd0;
         read_write     <= 1'd0;
         sda_out        <= 1'b1;
         enable_d       <= 1'b0;
     end else begin
         enable_d <= enable;
         case (state)
             READY: begin
                 // Espera comando externo
                 reg_data_ready <= 1'b0;
                 write_enable   <= 1'b0;
                 busy           <= 1'b0;
                 // Latch de enable para transición segura
                 if (enable_edge) begin
                     enable_reg <= 1'b1;
                 end
                 // Carga de datos y transición de estado
                 if (enable_reg) begin
                     num_paquetes <= n_paquetes;
                     read_write   <= rw;
                     slave_addr   <= slv_addr;
                     wt_buffer    <= data_in;
                     state        <= START;
                     sda_out      <= 1'b0; // SDA en alto
                     busy         <= 1'b1;
                     write_enable <= 1'b1;
                     clk_enable <= 1'b1;
                 end
             end
             START: begin
                 // Inicio de comunicación
                 enable_reg   <= 1'b0;
                 busy         <= 1'b1;
                 counter      <= 3'd7;
                 //sda_out      <= slave_addr[max_slv_Addr];
                 state        <= COMMAND;
             end
             COMMAND: begin
                 // En cada ciclo sacamos el bit actual
                 sda_out <= slave_addr[7];
 
                 if (counter == 3'd0) begin
                     // Último bit ya colocado; en el siguiente ciclo soltamos SDA para ACK
                     write_enable <= 1'b0;
                     state        <= SLV_OBJ_ACK;
                 end else begin
                     slave_addr   <= slave_addr << 1;
                     counter      <= counter - 1;
                 end
             end
             SLV_OBJ_ACK: begin
                 // Espera ACK del esclavo
                 if (I2C_SDA == 1'b0) begin
                     if (read_write == 1'b0) begin  // Write
                         counter      <= 3'd7;
                         write_enable <= 1'b1;
                         sda_out      <= wt_buffer[max_data_wr];
                         state        <= WRITE_DATA;
                     end else begin             // Read
                         counter      <= 3'd7;
                         state        <= READ_DATA;
                     end
                 end else begin
                     // NACK
                     state <= STOP;
                 end
             end
             WRITE_DATA: begin
                 // Envío de datos
                 busy <= 1'b1;
                 if (counter == 3'd0) begin
                     write_enable <= 1'b0;
                     num_paquetes <= num_paquetes - 1'b1;
                     sda_out      <= 1'b0;
                     state        <= WRITE_ACK;
                 end else begin
                     counter   <= counter - 1;
                     wt_buffer <= wt_buffer << 1;
                     sda_out   <= wt_buffer[max_data_wr];
                 end
             end
             READ_DATA: begin
                 // Lectura de datos
                 rd_buffer[counter] <= I2C_SDA;
                 if (counter == 3'd0) begin
                     state <= READ_ACK;
                 end else begin 
                     counter <= counter - 1;
                 end
             end
             WRITE_ACK: begin
                 // Espera ACK tras escritura
                 if (enable == 1'b1) begin
                     if (num_paquetes > 2'b0) begin
                         counter      <= 3'd7;
                         write_enable <= 1'b1;
                         sda_out      <= wt_buffer[max_data_wr];
                         state        <= WRITE_DATA;
                     end else begin
                         state <= STOP;
                     end
                 end else begin 
                     state <= STOP;
                 end
             end
             READ_ACK: begin
                 // ACK tras lectura
                 busy           <= 1'b0;
                 write_enable   <= 1'b1;
                 sda_out        <= 1'b0;
                 reg_data_ready <= 1'b1;
                 state          <= STOP;
             end
             STOP: begin
                 // Finalización de comunicación
                 write_enable <= 1'b1;
                 sda_out      <= 1'b1;
                 busy         <= 1'b0;
                 clk_enable   <= 1'b0;
                 state        <= READY;
             end
         endcase
     end
 end
 
endmodule

module main_vecfcb9 (
 input clk,
 input rstn,
 input valid,
 input [3:0] mem_wstrb,
 input [31:0] Bus_addr,
 input [31:0] Bus_data,
 input serdat_cs,
 input [3:0] I2C_State,
 input I2C_Busy,
 input [7:0] data_out,
 output enable_start,
 output rw,
 output [7:0] slv_addr,
 output [31:0] data_write,
 output [2:0] n_paquetes,
 output bus_data_enable,
 output [31:0] bus_data_out
);
 parameter W_SLV_ADDR        = 3'b000;  // 0x04000000
 parameter W_RW              = 3'b001;  // 0x04000004
 parameter W_N_PQTS          = 3'b010;  // 0x04000008
 parameter R_STATE           = 3'b011;  // 0x0400000C
 parameter R_BUSY            = 3'b100;  // 0x04000010
 parameter R_DATA_OUT        = 3'b101;  // 0x04000014
 parameter S_ENABLE          = 3'b110;  // 0x04000018
 parameter W_DATA_WRITE      = 3'b111;  // 0x0400001C
 
 // Índice en el array de registros
 parameter slv_addr_register         = 0;
 parameter rw_register               = 1;
 parameter num_pqts_register         = 2;
 parameter state_register            = 3;
 parameter busy_register             = 4;
 parameter data_out_register         = 5;
 parameter enable_register           = 6;
 
 
 //Entrada desde bus de datos
 reg [7:0] dataArray [7:0];
 reg [31:0] buffer_data_out;
 reg [31:0] data_wr = 32'b0;
 
 reg ack_r;          // pulso a CLK del bus
 assign bus_data_enable = ack_r;
 
 
 assign slv_addr[7:0] = dataArray[slv_addr_register][7:0];      
 assign rw = dataArray[rw_register][0];                   
 assign n_paquetes[2:0] = dataArray[num_pqts_register][2:0];    
 
 assign enable_start = dataArray[enable_register][0];                 
 
 assign data_write = data_wr;             
 assign bus_data_out = buffer_data_out;     
 
 wire serdat_write = serdat_cs & |mem_wstrb;     
 
 always @(posedge clk or negedge rstn) begin
     if (!rstn) begin
         // Reset completo de los registros
         dataArray[0] <= 8'b0;
         dataArray[1] <= 8'b0;
         dataArray[2] <= 8'b0;
         dataArray[3] <= 8'b0;
         dataArray[4] <= 8'b0;
         dataArray[5] <= 8'b0;
         dataArray[6] <= 8'b0;
         dataArray[7] <= 8'b0;
         buffer_data_out <= 32'b0;
         data_wr <= 32'b0;
         ack_r <= 1'b0;
     end else begin
         // Registros actualizados por hardware (FSM)
         dataArray[state_register]    <= {4'b0, I2C_State};
         dataArray[busy_register]     <= {7'b0, I2C_Busy};
         dataArray[data_out_register] <= data_out;
 
         // Interfaz externa desde CPU
         if (serdat_cs) begin
             ack_r <= 1'b1;
             if (serdat_write) begin
                 // ----------- ESCRITURA -----------
                 if (Bus_addr[4:2] == W_DATA_WRITE) begin
                     data_wr <= Bus_data;
                 end else begin
                     dataArray[Bus_addr[4:2]] <= Bus_data[7:0];
                 end
             end else begin
                 // ----------- LECTURA -----------
                 if (Bus_addr[4:2] == W_DATA_WRITE) begin
                     buffer_data_out <= data_wr;
                 end else begin
                     buffer_data_out <= {24'b0, dataArray[Bus_addr[4:2]]};
                 end
             end
             // Limpieza de registros de un solo ciclo
             //dataArray[enable_register] <= 8'b0;
         end else begin
             ack_r <= 1'b0; // al siguiente ciclo vuelve a 0
         end
     end
 end
endmodule

module main_v390fcc #(
 parameter Frecuencia = 0
) (
 input clk_in,
 output clk_out
);
 
 //parameter HZ=1;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000/HZ;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter = 0;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- REgistro con el valor del reloj
 reg clk_out = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_out <= ~clk_out;
 
 
 assign clk_o = clk_out;  
 
endmodule

module main_vf5c265 #(
 parameter Frecuencia = 0
) (
 input clk_in,
 output clk_out
);
 
 //parameter HZ=1;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000/HZ;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter = 0;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- REgistro con el valor del reloj
 reg clk_out = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_out <= ~clk_out;
 
 
 assign clk_o = clk_out;  
 
endmodule

module main_vc66ea6 (
 input clk,
 input i2c_clk,
 input resetn,
 input ena,
 input [6:0] slv_addr,
 input rw,
 input [7:0] data_in,
 input sda_I,
 input scl_I,
 output busy,
 output [7:0] data_rd,
 output ack_error,
 output sda_O,
 output sda_T,
 output scl_O,
 output scl_T,
 output [3:0] states,
 output [3:0] bit_cnts,
 output data_clkp,
 output streetchp,
 inout scl,
 inout sda
);

endmodule
