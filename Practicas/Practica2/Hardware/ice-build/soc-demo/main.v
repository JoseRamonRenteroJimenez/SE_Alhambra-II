// Code generated by Icestudio 0.12

`default_nettype none

//---- Top entity
module main #(
 parameter vafbbea = 1024,
 parameter v8c97ba = 'h0200_0000,
 parameter v9217e8 = 1024,
 parameter v9de176 = 'h0200_0008,
 parameter v051dbb = 'h03000000
) (
 input v220cec,
 input vbb831a,
 input v4922c7,
 input v013906,
 input vclk,
 output [7:0] v1e554b,
 output vc267e1,
 output v7abb98,
 output vda2c07,
 output v55f1ca,
 output v97f0aa,
 output v5ec250,
 output v5100fa
);
 localparam p6 = vafbbea;
 localparam p7 = v8c97ba;
 localparam p8 = v9217e8;
 localparam p9 = v051dbb;
 localparam p10 = v9de176;
 wire [0:31] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire [0:7] w17;
 wire [0:3] w18;
 wire [0:3] w19;
 wire [0:7] w20;
 wire w21;
 wire w22;
 wire [0:7] w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 wire w33;
 wire w34;
 wire w35;
 wire w36;
 wire w37;
 wire w38;
 wire w39;
 wire [0:31] w40;
 wire [0:31] w41;
 wire [0:31] w42;
 wire [0:31] w43;
 wire w44;
 wire w45;
 wire [0:3] w46;
 wire [0:3] w47;
 wire [0:3] w48;
 wire w49;
 wire [0:31] w50;
 wire [0:31] w51;
 wire [0:31] w52;
 wire w53;
 wire w54;
 wire [0:31] w55;
 wire [0:31] w56;
 wire [0:31] w57;
 wire [0:31] w58;
 wire w59;
 wire w60;
 wire w61;
 wire w62;
 assign w2 = v013906;
 assign v5100fa = w3;
 assign v5ec250 = w4;
 assign v97f0aa = w5;
 assign w11 = v4922c7;
 assign v55f1ca = w12;
 assign vda2c07 = w13;
 assign v7abb98 = w14;
 assign vc267e1 = w15;
 assign v1e554b = w20;
 assign w21 = v220cec;
 assign w22 = vbb831a;
 assign w24 = vclk;
 assign w25 = vclk;
 assign w26 = vclk;
 assign w27 = vclk;
 assign w28 = vclk;
 assign w29 = vclk;
 assign w30 = vclk;
 assign w31 = vclk;
 assign w23 = w17;
 assign w25 = w24;
 assign w26 = w24;
 assign w26 = w25;
 assign w27 = w24;
 assign w27 = w25;
 assign w27 = w26;
 assign w28 = w24;
 assign w28 = w25;
 assign w28 = w26;
 assign w28 = w27;
 assign w29 = w24;
 assign w29 = w25;
 assign w29 = w26;
 assign w29 = w27;
 assign w29 = w28;
 assign w30 = w24;
 assign w30 = w25;
 assign w30 = w26;
 assign w30 = w27;
 assign w30 = w28;
 assign w30 = w29;
 assign w31 = w24;
 assign w31 = w25;
 assign w31 = w26;
 assign w31 = w27;
 assign w31 = w28;
 assign w31 = w29;
 assign w31 = w30;
 assign w33 = w32;
 assign w34 = w32;
 assign w34 = w33;
 assign w35 = w32;
 assign w35 = w33;
 assign w35 = w34;
 assign w37 = w36;
 assign w38 = w36;
 assign w38 = w37;
 assign w39 = w36;
 assign w39 = w37;
 assign w39 = w38;
 assign w41 = w40;
 assign w42 = w40;
 assign w42 = w41;
 assign w43 = w40;
 assign w43 = w41;
 assign w43 = w42;
 assign w45 = w44;
 assign w47 = w46;
 assign w48 = w46;
 assign w48 = w47;
 assign w51 = w50;
 assign w52 = w50;
 assign w52 = w51;
 assign w54 = w53;
 assign w60 = w59;
 v35f267 vc8f159 (
  .v0e28cb(w1),
  .vcbab45(w32)
 );
 v725d0b vcd95a5 (
  .v9b328c(w0)
 );
 v87abc9 v7eb25a (
  .vcbab45(w44),
  .v814e6e(w49),
  .v3ca442(w53),
  .v0e28cb(w59),
  .v132c67(w61)
 );
 v604573 #(
  .v4fde05(p10)
 ) v72b9aa (
  .vb6935e(w11),
  .v2ab975(w12),
  .v34e785(w24),
  .v866d25(w34),
  .vad40e9(w38),
  .v9f8bfb(w42),
  .vd996e9(w48),
  .v0fa3a4(w52),
  .v62ea55(w58),
  .vdc4800(w61),
  .vf3ed26(w62)
 );
 vdccd52 vb4539a (
 
 );
 v73403c vbe815f (
  .v595263(w17),
  .v85accc(w18),
  .vf9119c(w19)
 );
 vaad680 v62d839 (
  .v29fe33(w0),
  .vba7c72(w25),
  .v5d0f7b(w33),
  .v006d37(w36),
  .vd67338(w40),
  .v9b0ff0(w44),
  .v83dbbe(w46),
  .ve61aa7(w50),
  .v8fd87d(w55)
 );
 v55b120 v7b9433 (
  .v47023d(w13),
  .v7aeba1(w14),
  .v92ad22(w15),
  .v1cd63b(w16),
  .v9119d0(w18),
  .v3d0cdd(w19),
  .v379e9e(w26)
 );
 v6c0c4a #(
  .vf2d743(p9)
 ) v6500fa (
  .v980561(w16),
  .v9d3deb(w17),
  .v1002e2(w27),
  .v8fadcd(w36),
  .vd5de6b(w40),
  .va57c44(w47),
  .vb21f3c(w49),
  .v6d05a9(w50)
 );
 v5242e2 v447d62 (
  .ve3469f(w54),
  .v493538(w55),
  .v918400(w56),
  .v5664d9(w57),
  .vae8a69(w58),
  .v76f74e(w60),
  .v58d02d(w62)
 );
 vaba674 #(
  .v6478b6(p8)
 ) v2bbe2d (
  .v04ad7a(w28),
  .vd7d395(w37),
  .v387cca(w41),
  .v22c516(w45),
  .vd728f0(w46),
  .v8d6432(w51),
  .v69f1ab(w53),
  .v13ce3e(w56)
 );
 v2b4233 v1314aa (
  .v6d0651(w1),
  .v4c8225(w29)
 );
 v372366 #(
  .vbce3f7(p6),
  .v386fc7(p7)
 ) v0e0ee1 (
  .v78b064(w2),
  .v40049a(w3),
  .v0da91a(w4),
  .v9b4033(w5),
  .v84763f(w30),
  .v17983a(w35),
  .vba8655(w39),
  .vbee9aa(w43),
  .v202123(w57),
  .vbe14dd(w59)
 );
 va1329e vfbae3f (
  .v0acf62(w20),
  .v6f1466(w21),
  .v8cc0d0(w22),
  .v0d6dda(w23),
  .v91de83(w31),
  .vf72f35(w32)
 );
endmodule

//---- Top entity
module v35f267 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v35f267_vd54ca1 vd54ca1 (
  .a(w0),
  .c(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta NOT
//---------------------------------------------------

module v35f267_vd54ca1 (
 input a,
 output c
);
 //-- Puerta NOT
 
 //-- module (input wire a, output wire c);
 
 
 assign c = ~a;
 
 
 //-- endmodule
 
endmodule
//---- Top entity
module v725d0b #(
 parameter vc5c8ea = 0
) (
 output [31:0] v9b328c
);
 localparam p0 = vc5c8ea;
 wire [0:31] w1;
 assign v9b328c = w1;
 v70cd06 #(
  .vc5c8ea(p0)
 ) v38acc0 (
  .v751a1b(w1)
 );
endmodule

//---------------------------------------------------
//-- Valor_00_32bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor constante 0, de 32 bits
//---------------------------------------------------
//---- Top entity
module v70cd06 #(
 parameter vc5c8ea = 0
) (
 output [31:0] v751a1b
);
 localparam p0 = vc5c8ea;
 wire [0:31] w1;
 assign v751a1b = w1;
 v70cd06_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- Constante-32bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor genérico constante, de 32 bits. Su valor se introduce como parámetro. Por defecto vale 0
//---------------------------------------------------

module v70cd06_v465065 #(
 parameter VALUE = 0
) (
 output [31:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module v87abc9 (
 input v0e28cb,
 input v3ca442,
 input v132c67,
 input v814e6e,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 assign w3 = v132c67;
 assign w4 = v814e6e;
 v87abc9_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .o(w2),
  .c(w3),
  .d(w4)
 );
endmodule

//---------------------------------------------------
//-- OR-4
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta OR de 4 entradas
//---------------------------------------------------

module v87abc9_vf4938a (
 input a,
 input b,
 input c,
 input d,
 output o
);
 //-- Puerta OR
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign o = a | b | c | d;
 
 //-- endmodule
endmodule
//---- Top entity
module v604573 #(
 parameter v4fde05 = 'h0200_0008
) (
 input v34e785,
 input v866d25,
 input vb6935e,
 input [31:0] v9f8bfb,
 input vad40e9,
 input [31:0] v0fa3a4,
 input [3:0] vd996e9,
 output v2ab975,
 output [31:0] v62ea55,
 output vdc4800,
 output vf3ed26
);
 localparam p3 = v4fde05;
 wire w0;
 wire w1;
 wire w2;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire [0:31] w8;
 wire w9;
 wire [0:3] w10;
 wire [0:31] w11;
 wire [0:3] w12;
 wire w13;
 wire w14;
 wire w15;
 wire [0:31] w16;
 wire w17;
 wire [0:31] w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 assign v2ab975 = w1;
 assign v62ea55 = w8;
 assign vdc4800 = w9;
 assign w10 = vd996e9;
 assign w13 = v34e785;
 assign w14 = v866d25;
 assign w15 = vb6935e;
 assign w16 = v9f8bfb;
 assign w17 = vad40e9;
 assign w18 = v0fa3a4;
 assign vf3ed26 = w24;
 assign w20 = w19;
 assign w22 = w21;
 assign w23 = w21;
 assign w23 = w22;
 assign w24 = w21;
 assign w24 = w22;
 assign w24 = w23;
 v35f267 v793e13 (
  .vcbab45(w0),
  .v0e28cb(w2)
 );
 vb2090f v8b2549 (
  .v0e28cb(w0),
  .vcbab45(w9),
  .v3ca442(w23)
 );
 ve4ece1 vb9eeab (
  .va76a47(w1),
  .v3c7d9a(w2),
  .v10961b(w5),
  .vfeadd9(w7),
  .vb7609f(w8),
  .v20a2cd(w11),
  .v8e9021(w12),
  .v0dfcfa(w13),
  .v19f118(w14),
  .v13457e(w15),
  .v3674d3(w18)
 );
 vf9bdaf #(
  .v6b316b(p3)
 ) va6e100 (
  .v18e78c(w4),
  .ve1f562(w16)
 );
 vb2090f vc4db0b (
  .v0e28cb(w4),
  .v3ca442(w17),
  .vcbab45(w21)
 );
 vb2090f v43be95 (
  .vcbab45(w5),
  .v3ca442(w6),
  .v0e28cb(w21)
 );
 v35f267 v2e543c (
  .vcbab45(w6),
  .v0e28cb(w20)
 );
 vb2090f v7253fb (
  .vcbab45(w7),
  .v0e28cb(w19),
  .v3ca442(w22)
 );
 v45c913 v5623aa (
  .v930b03(w10),
  .v593f43(w19)
 );
 v2c97f6 v70047a (
  .v7c9bd8(w11)
 );
 v6a0d89 vf00bfe (
  .v919d0f(w12)
 );
endmodule

//---------------------------------------------------
//-- UART-soc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- UART con la lógica de mapeo
//---------------------------------------------------
//---- Top entity
module vb2090f (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vb2090f_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND
//---------------------------------------------------

module vb2090f_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta AND
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a & b;
 
 //-- endmodule
endmodule
//---- Top entity
module ve4ece1 (
 input v0dfcfa,
 input v19f118,
 input v13457e,
 input [3:0] v8e9021,
 input vfeadd9,
 input v10961b,
 input [31:0] v3674d3,
 input [31:0] v20a2cd,
 output va76a47,
 output [31:0] vc35967,
 output [31:0] vb7609f,
 output v3c7d9a
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:3] w4;
 wire w5;
 wire w6;
 wire [0:31] w7;
 wire [0:31] w8;
 wire [0:31] w9;
 wire [0:31] w10;
 wire w11;
 assign va76a47 = w0;
 assign w1 = v13457e;
 assign w2 = v0dfcfa;
 assign w3 = v19f118;
 assign w4 = v8e9021;
 assign w5 = vfeadd9;
 assign w6 = v10961b;
 assign w7 = v3674d3;
 assign w8 = v20a2cd;
 assign vc35967 = w9;
 assign vb7609f = w10;
 assign v3c7d9a = w11;
 ve4ece1_v7323f5 v7323f5 (
  .ser_tx(w0),
  .ser_rx(w1),
  .clk(w2),
  .resetn(w3),
  .reg_div_we(w4),
  .reg_dat_we(w5),
  .reg_dat_re(w6),
  .reg_dat_di(w7),
  .reg_div_di(w8),
  .reg_div_do(w9),
  .reg_dat_do(w10),
  .reg_dat_wait(w11)
 );
endmodule

//---------------------------------------------------
//-- UART
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Uart para comunicaciones serie con el pico-riscv
//---------------------------------------------------

module ve4ece1_v7323f5 (
 input clk,
 input resetn,
 input ser_rx,
 input [3:0] reg_div_we,
 input reg_dat_we,
 input reg_dat_re,
 input [31:0] reg_dat_di,
 input [31:0] reg_div_di,
 output ser_tx,
 output [31:0] reg_div_do,
 output [31:0] reg_dat_do,
 output reg_dat_wait
);
 reg [31:0] cfg_divider=104;
 
 	reg [3:0] recv_state;
 	reg [31:0] recv_divcnt;
 	reg [7:0] recv_pattern;
 	reg [7:0] recv_buf_data;
 	reg recv_buf_valid;
 
 	reg [9:0] send_pattern;
 	reg [3:0] send_bitcnt;
 	reg [31:0] send_divcnt;
 	reg send_dummy;
 
 	assign reg_div_do = cfg_divider;
 
 	assign reg_dat_wait = reg_dat_we && (send_bitcnt || send_dummy);
 	assign reg_dat_do = recv_buf_valid ? recv_buf_data : ~0;
 /*
 	always @(posedge clk) begin
 		if (!resetn) begin
 			cfg_divider <= 1;
 		end else begin
 			if (reg_div_we[0]) cfg_divider[ 7: 0] <= reg_div_di[ 7: 0];
 			if (reg_div_we[1]) cfg_divider[15: 8] <= reg_div_di[15: 8];
 			if (reg_div_we[2]) cfg_divider[23:16] <= reg_div_di[23:16];
 			if (reg_div_we[3]) cfg_divider[31:24] <= reg_div_di[31:24];
 		end
 	end
 */
 	always @(posedge clk) begin
 		if (!resetn) begin
 			recv_state <= 0;
 			recv_divcnt <= 0;
 			recv_pattern <= 0;
 			recv_buf_data <= 0;
 			recv_buf_valid <= 0;
 		end else begin
 			recv_divcnt <= recv_divcnt + 1;
 			if (reg_dat_re)
 				recv_buf_valid <= 0;
 			case (recv_state)
 				0: begin
 					if (!ser_rx)
 						recv_state <= 1;
 					recv_divcnt <= 0;
 				end
 				1: begin
 					if (2*recv_divcnt > cfg_divider) begin
 						recv_state <= 2;
 						recv_divcnt <= 0;
 					end
 				end
 				10: begin
 					if (recv_divcnt > cfg_divider) begin
 						recv_buf_data <= recv_pattern;
 						recv_buf_valid <= 1;
 						recv_state <= 0;
 					end
 				end
 				default: begin
 					if (recv_divcnt > cfg_divider) begin
 						recv_pattern <= {ser_rx, recv_pattern[7:1]};
 						recv_state <= recv_state + 1;
 						recv_divcnt <= 0;
 					end
 				end
 			endcase
 		end
 	end
 
 	assign ser_tx = send_pattern[0];
 
 	always @(posedge clk) begin
 		if (reg_div_we)
 			send_dummy <= 1;
 		send_divcnt <= send_divcnt + 1;
 		if (!resetn) begin
 			send_pattern <= ~0;
 			send_bitcnt <= 0;
 			send_divcnt <= 0;
 			send_dummy <= 1;
 		end else begin
 			if (send_dummy && !send_bitcnt) begin
 				send_pattern <= ~0;
 				send_bitcnt <= 15;
 				send_divcnt <= 0;
 				send_dummy <= 0;
 			end else
 			if (reg_dat_we && !send_bitcnt) begin
 				send_pattern <= {1'b1, reg_dat_di[7:0], 1'b0};
 				send_bitcnt <= 10;
 				send_divcnt <= 0;
 			end else
 			if (send_divcnt > cfg_divider && send_bitcnt) begin
 				send_pattern <= {1'b1, send_pattern[9:1]};
 				send_bitcnt <= send_bitcnt - 1;
 				send_divcnt <= 0;
 			end
 		end
 	end
endmodule
//---- Top entity
module vf9bdaf #(
 parameter v6b316b = 0
) (
 input [31:0] ve1f562,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = ve1f562;
 vf9bdaf_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de un operando de 32 bits. Se compara si el operando es igual al parámetro
//---------------------------------------------------

module vf9bdaf_vd75681 #(
 parameter K = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a == K);
endmodule
//---- Top entity
module v45c913 (
 input [3:0] v930b03,
 output v5b73e8,
 output vc90115,
 output v2812a7,
 output v593f43
);
 wire [0:3] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign w0 = v930b03;
 assign v2812a7 = w1;
 assign v593f43 = w2;
 assign vc90115 = w3;
 assign v5b73e8 = w4;
 v45c913_v9a2a06 v9a2a06 (
  .i(w0),
  .o1(w1),
  .o0(w2),
  .o2(w3),
  .o3(w4)
 );
endmodule

//---------------------------------------------------
//-- Separador-bus
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 4-bits en 4 cables
//---------------------------------------------------

module v45c913_v9a2a06 (
 input [3:0] i,
 output o3,
 output o2,
 output o1,
 output o0
);
 assign o3 = i[3];
 assign o2 = i[2];
 assign o1 = i[1];
 assign o0 = i[0];
endmodule
//---- Top entity
module v2c97f6 #(
 parameter vfffc23 = 0
) (
 output [31:0] v7c9bd8
);
 localparam p0 = vfffc23;
 wire [0:31] w1;
 assign v7c9bd8 = w1;
 v959751 #(
  .vc5c8ea(p0)
 ) v9f49e7 (
  .vbc97e4(w1)
 );
endmodule

//---------------------------------------------------
//-- 32bits-Value_0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 32bits constant value: 0
//---------------------------------------------------
//---- Top entity
module v959751 #(
 parameter vc5c8ea = 0
) (
 output [31:0] vbc97e4
);
 localparam p0 = vc5c8ea;
 wire [0:31] w1;
 assign vbc97e4 = w1;
 v959751_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- 32-bits-gen-constant
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Generic: 32-bits generic constant
//---------------------------------------------------

module v959751_v465065 #(
 parameter VALUE = 0
) (
 output [31:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module v6a0d89 #(
 parameter vfffc23 = 0
) (
 output [3:0] v919d0f
);
 localparam p0 = vfffc23;
 wire [0:3] w1;
 assign v919d0f = w1;
 v9b9118 #(
  .vc5c8ea(p0)
 ) v76a485 (
  .v1ef182(w1)
 );
endmodule

//---------------------------------------------------
//-- 4bits-Value_0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 4bits constant value: 0
//---------------------------------------------------
//---- Top entity
module v9b9118 #(
 parameter vc5c8ea = 0
) (
 output [3:0] v1ef182
);
 localparam p0 = vc5c8ea;
 wire [0:3] w1;
 assign v1ef182 = w1;
 v9b9118_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- 4-bits-gen-constant
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Generic: 4-bits generic constant (0-15)
//---------------------------------------------------

module v9b9118_v465065 #(
 parameter VALUE = 0
) (
 output [3:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module vdccd52
;

endmodule

//---------------------------------------------------
//-- Smiley
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Stickers de Smiley
//---------------------------------------------------
//---- Top entity
module v73403c (
 input [7:0] v595263,
 output [3:0] vf9119c,
 output [3:0] v85accc
);
 wire [0:3] w0;
 wire [0:3] w1;
 wire [0:7] w2;
 assign vf9119c = w0;
 assign v85accc = w1;
 assign w2 = v595263;
 v73403c_v9a2a06 v9a2a06 (
  .o1(w0),
  .o0(w1),
  .i(w2)
 );
endmodule

//---------------------------------------------------
//-- Separador-bus
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 8-bits en buses de 4 bits
//---------------------------------------------------

module v73403c_v9a2a06 (
 input [7:0] i,
 output [3:0] o1,
 output [3:0] o0
);
 assign o1 = i[7:4];
 assign o0 = i[3:0];
endmodule
//---- Top entity
module vaad680 (
 input vba7c72,
 input v5d0f7b,
 input v9b0ff0,
 input [31:0] v8fd87d,
 input [31:0] v29fe33,
 output v006d37,
 output v88e319,
 output [31:0] vd67338,
 output [31:0] ve61aa7,
 output [3:0] v83dbbe
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire [0:31] w6;
 wire [0:31] w7;
 wire [0:31] w8;
 wire [0:31] w9;
 wire [0:3] w10;
 wire [0:31] w11;
 wire w12;
 wire [0:31] w13;
 wire [0:5] w14;
 wire [0:5] w15;
 wire [0:5] w16;
 wire [0:31] w17;
 assign w0 = vba7c72;
 assign w1 = vba7c72;
 assign v006d37 = w2;
 assign w3 = v5d0f7b;
 assign v88e319 = w4;
 assign w5 = v9b0ff0;
 assign vd67338 = w6;
 assign w7 = v8fd87d;
 assign ve61aa7 = w8;
 assign w9 = v29fe33;
 assign v83dbbe = w10;
 assign w1 = w0;
 vaad680_v3fb302 v3fb302 (
  .clk(w1),
  .rdata1(w11),
  .wen(w12),
  .rdata2(w13),
  .waddr(w14),
  .raddr1(w15),
  .raddr2(w16),
  .wdata(w17)
 );
 vaad680_vf1da6e vf1da6e (
  .clk(w0),
  .mem_valid(w2),
  .resetn(w3),
  .mem_instr(w4),
  .mem_ready(w5),
  .mem_addr(w6),
  .mem_rdata(w7),
  .mem_wdata(w8),
  .irq(w9),
  .mem_wstrb(w10),
  .cpuregs_rdata1(w11),
  .cpuregs_wen(w12),
  .cpuregs_rdata2(w13),
  .cpuregs_waddr(w14),
  .cpuregs_raddr1(w15),
  .cpuregs_raddr2(w16),
  .cpuregs_wrdata(w17)
 );
endmodule

//---------------------------------------------------
//-- RV32i
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Risc-v de 32Bits. Numeros enteros
//---------------------------------------------------

module vaad680_v3fb302 (
 input clk,
 input wen,
 input [5:0] waddr,
 input [5:0] raddr1,
 input [5:0] raddr2,
 input [31:0] wdata,
 output [31:0] rdata1,
 output [31:0] rdata2
);
 reg [31:0] regs [0:31];
 
 always @(posedge clk)
 	if (wen) regs[waddr[4:0]] <= wdata;
 
 assign rdata1 = regs[raddr1[4:0]];
 assign rdata2 = regs[raddr2[4:0]];
endmodule

module vaad680_vf1da6e (
 input clk,
 input resetn,
 input mem_ready,
 input [31:0] mem_rdata,
 input [31:0] irq,
 input [31:0] cpuregs_rdata1,
 input [31:0] cpuregs_rdata2,
 input pcpi_mul_wr,
 input [31:0] pcpi_mul_rd,
 input pcpi_mul_wait,
 input pcpi_mul_ready,
 input pcpi_div_wr,
 input [31:0] pcpi_div_rd,
 input pcpi_div_wait,
 input pcpi_div_ready,
 output mem_valid,
 output mem_instr,
 output [31:0] mem_addr,
 output [31:0] mem_wdata,
 output [3:0] mem_wstrb,
 output cpuregs_wen,
 output [5:0] cpuregs_waddr,
 output [5:0] cpuregs_raddr1,
 output [5:0] cpuregs_raddr2,
 output [31:0] cpuregs_wrdata,
 output pcpi_valid,
 output [31:0] pcpi_insn,
 output [31:0] pcpi_rs1,
 output [31:0] pcpi_rs2
);
 `define PICORV32_REGS picosoc_regs
 
 
 parameter integer MEM_WORDS = 256;
 
 `define PICORV32_V
 
 parameter [ 0:0] ENABLE_COUNTERS = 1;
 parameter [ 0:0] ENABLE_COUNTERS64 = 1;
 parameter [ 0:0] ENABLE_REGS_16_31 = 1;
 parameter [ 0:0] ENABLE_REGS_DUALPORT = 1;
 parameter [ 0:0] LATCHED_MEM_RDATA = 0;
 parameter [ 0:0] TWO_STAGE_SHIFT = 1;
 parameter [ 0:0] BARREL_SHIFTER = 1;
 parameter [ 0:0] TWO_CYCLE_COMPARE = 0;
 parameter [ 0:0] TWO_CYCLE_ALU = 0;
 parameter [ 0:0] COMPRESSED_ISA = 0;
 parameter [ 0:0] CATCH_MISALIGN = 1;
 parameter [ 0:0] CATCH_ILLINSN = 1;
 parameter [ 0:0] ENABLE_PCPI = 0;
 parameter [ 0:0] ENABLE_MUL = 0;
 parameter [ 0:0] ENABLE_FAST_MUL = 0;
 parameter [ 0:0] ENABLE_DIV = 0;
 parameter [ 0:0] ENABLE_IRQ = 1;
 parameter [ 0:0] ENABLE_IRQ_QREGS = 0;
 parameter [ 0:0] ENABLE_IRQ_TIMER = 1;
 parameter [ 0:0] ENABLE_TRACE = 0;
 parameter [ 0:0] REGS_INIT_ZERO = 0;
 parameter [31:0] MASKED_IRQ = 32'h 0000_0000;
 parameter [31:0] LATCHED_IRQ = 32'h ffff_ffff;
 parameter [31:0] PROGADDR_RESET = 32'h 0010_0000; // 1 MB into flash,
 parameter [31:0] PROGADDR_IRQ = 32'h 0000_0000;
 parameter [31:0] STACKADDR = (4*MEM_WORDS);       // end of memory
 
 
 reg mem_valid_i;
 assign mem_valid = mem_valid_i;
 reg mem_instr_i;
 assign mem_instr = mem_instr_i;
 reg [31:0] mem_addr_i;
 assign mem_addr = mem_addr_i;
 reg [31:0] mem_wdata_i;
 assign mem_wdata = mem_wdata_i;
 reg [ 3:0] mem_wstrb_i;
 assign mem_wstrb = mem_wstrb_i;
 reg [31:0] eoi;
 
 reg trap;
 
 
 // Pico Co-Processor Interface (PCPI)
 reg        pcpi_valid_i;
 assign pcpi_valid = pcpi_valid_i;
 reg [31:0] pcpi_insn_i;
 assign pcpi_insn = pcpi_insn_i;
 wire     pcpi_wr;
 wire [31:0] pcpi_rd;
 wire pcpi_wait;
 wire pcpi_ready;
 
 
 // Look-Ahead Interface
 wire            mem_la_read;
 wire            mem_la_write;
 wire     [31:0] mem_la_addr;
 reg [31:0] mem_la_wdata;
 reg [ 3:0] mem_la_wstrb;
 
 // Trace Interface
 reg        trace_valid;
 reg [35:0] trace_data;
 
 	localparam integer irq_timer = 0;
 	localparam integer irq_ebreak = 1;
 	localparam integer irq_buserror = 2;
 
 	localparam integer irqregs_offset = ENABLE_REGS_16_31 ? 32 : 16;
 	localparam integer regfile_size = (ENABLE_REGS_16_31 ? 32 : 16) + 4*ENABLE_IRQ*ENABLE_IRQ_QREGS;
 	localparam integer regindex_bits = (ENABLE_REGS_16_31 ? 5 : 4) + ENABLE_IRQ*ENABLE_IRQ_QREGS;
 
 	localparam WITH_PCPI = ENABLE_PCPI || ENABLE_MUL || ENABLE_FAST_MUL || ENABLE_DIV;
 
 	localparam [35:0] TRACE_BRANCH = {4'b 0001, 32'b 0};
 	localparam [35:0] TRACE_ADDR   = {4'b 0010, 32'b 0};
 	localparam [35:0] TRACE_IRQ    = {4'b 1000, 32'b 0};
 
 //-- Añadido para instanciar los registros
 assign cpuregs_wen = resetn && cpuregs_write && latched_rd;
 
 //FORMAL_KEEP:
 reg [63:0] dbg_ascii_instr;
 reg [31:0] dbg_insn_imm;
 reg [4:0] dbg_insn_rs1;
 reg [4:0] dbg_insn_rs2;
 reg [4:0] dbg_insn_rd;
 reg [31:0] dbg_rs1val;
 reg [31:0] dbg_rs2val;
 reg dbg_rs1val_valid;
 reg dbg_rs2val_valid;
 reg [127:0] dbg_ascii_state;
 
 	reg [63:0] count_cycle, count_instr;
 	reg [31:0] reg_pc, reg_next_pc, reg_op1, reg_op2, reg_out;
 	reg [4:0] reg_sh;
 
 	reg [31:0] next_insn_opcode;
 	reg [31:0] dbg_insn_opcode;
 	reg [31:0] dbg_insn_addr;
 
 	wire dbg_mem_valid = mem_valid_i;
 	wire dbg_mem_instr = mem_instr_i;
 	wire dbg_mem_ready = mem_ready;
 	wire [31:0] dbg_mem_addr  = mem_addr_i;
 	wire [31:0] dbg_mem_wdata = mem_wdata_i;
 	wire [ 3:0] dbg_mem_wstrb = mem_wstrb_i;
 	wire [31:0] dbg_mem_rdata = mem_rdata;
 
 	assign pcpi_rs1 = reg_op1;
 	assign pcpi_rs2 = reg_op2;
 
 	wire [31:0] next_pc;
 
 	reg irq_delay;
 	reg irq_active;
 	reg [31:0] irq_mask;
 	reg [31:0] irq_pending;
 	reg [31:0] timer;
 
 `ifndef PICORV32_REGS
 	reg [31:0] cpuregs [0:regfile_size-1];
 
 	integer i;
 	initial begin
 		if (REGS_INIT_ZERO) begin
 			for (i = 0; i < regfile_size; i = i+1)
 				cpuregs[i] = 0;
 		end
 	end
 `endif
 
 	task empty_statement;
 		// This task is used by the `assert directive in non-formal mode to
 		// avoid empty statement (which are unsupported by plain Verilog syntax).
 		begin end
 	endtask
 
 `ifdef DEBUGREGS
 	wire [31:0] dbg_reg_x0  = 0;
 	wire [31:0] dbg_reg_x1  = cpuregs[1];
 	wire [31:0] dbg_reg_x2  = cpuregs[2];
 	wire [31:0] dbg_reg_x3  = cpuregs[3];
 	wire [31:0] dbg_reg_x4  = cpuregs[4];
 	wire [31:0] dbg_reg_x5  = cpuregs[5];
 	wire [31:0] dbg_reg_x6  = cpuregs[6];
 	wire [31:0] dbg_reg_x7  = cpuregs[7];
 	wire [31:0] dbg_reg_x8  = cpuregs[8];
 	wire [31:0] dbg_reg_x9  = cpuregs[9];
 	wire [31:0] dbg_reg_x10 = cpuregs[10];
 	wire [31:0] dbg_reg_x11 = cpuregs[11];
 	wire [31:0] dbg_reg_x12 = cpuregs[12];
 	wire [31:0] dbg_reg_x13 = cpuregs[13];
 	wire [31:0] dbg_reg_x14 = cpuregs[14];
 	wire [31:0] dbg_reg_x15 = cpuregs[15];
 	wire [31:0] dbg_reg_x16 = cpuregs[16];
 	wire [31:0] dbg_reg_x17 = cpuregs[17];
 	wire [31:0] dbg_reg_x18 = cpuregs[18];
 	wire [31:0] dbg_reg_x19 = cpuregs[19];
 	wire [31:0] dbg_reg_x20 = cpuregs[20];
 	wire [31:0] dbg_reg_x21 = cpuregs[21];
 	wire [31:0] dbg_reg_x22 = cpuregs[22];
 	wire [31:0] dbg_reg_x23 = cpuregs[23];
 	wire [31:0] dbg_reg_x24 = cpuregs[24];
 	wire [31:0] dbg_reg_x25 = cpuregs[25];
 	wire [31:0] dbg_reg_x26 = cpuregs[26];
 	wire [31:0] dbg_reg_x27 = cpuregs[27];
 	wire [31:0] dbg_reg_x28 = cpuregs[28];
 	wire [31:0] dbg_reg_x29 = cpuregs[29];
 	wire [31:0] dbg_reg_x30 = cpuregs[30];
 	wire [31:0] dbg_reg_x31 = cpuregs[31];
 `endif
 
 	// Internal PCPI Cores
 
 	reg        pcpi_int_wr;
 	reg [31:0] pcpi_int_rd;
 	reg        pcpi_int_wait;
 	reg        pcpi_int_ready;
 
 	generate if (ENABLE_FAST_MUL) begin
 		picorv32_pcpi_fast_mul pcpi_mul (
 			.clk       (clk            ),
 			.resetn    (resetn         ),
 			.pcpi_valid(pcpi_valid_i     ),
 			.pcpi_insn (pcpi_insn_i      ),
 			.pcpi_rs1  (pcpi_rs1       ),
 			.pcpi_rs2  (pcpi_rs2       ),
 			.pcpi_wr   (pcpi_mul_wr    ),
 			.pcpi_rd   (pcpi_mul_rd    ),
 			.pcpi_wait (pcpi_mul_wait  ),
 			.pcpi_ready(pcpi_mul_ready )
 		);
 	end else if (ENABLE_MUL) begin
 		
 	end else begin
 		assign pcpi_mul_wr = 0;
 		assign pcpi_mul_rd = 32'bx;
 		assign pcpi_mul_wait = 0;
 		assign pcpi_mul_ready = 0;
 	end endgenerate
 
 	generate if (ENABLE_DIV) begin
 		
 	end else begin
 		assign pcpi_div_wr = 0;
 		assign pcpi_div_rd = 32'bx;
 		assign pcpi_div_wait = 0;
 		assign pcpi_div_ready = 0;
 	end endgenerate
 
 	always @* begin
 		pcpi_int_wr = 0;
 		pcpi_int_rd = 32'bx;
 		pcpi_int_wait  = |{ENABLE_PCPI && pcpi_wait,  (ENABLE_MUL || ENABLE_FAST_MUL) && pcpi_mul_wait,  ENABLE_DIV && pcpi_div_wait};
 		pcpi_int_ready = |{ENABLE_PCPI && pcpi_ready, (ENABLE_MUL || ENABLE_FAST_MUL) && pcpi_mul_ready, ENABLE_DIV && pcpi_div_ready};
 
 		(* parallel_case *)
 		case (1'b1)
 			ENABLE_PCPI && pcpi_ready: begin
 				pcpi_int_wr = ENABLE_PCPI ? pcpi_wr : 0;
 				pcpi_int_rd = ENABLE_PCPI ? pcpi_rd : 0;
 			end
 			(ENABLE_MUL || ENABLE_FAST_MUL) && pcpi_mul_ready: begin
 				pcpi_int_wr = pcpi_mul_wr;
 				pcpi_int_rd = pcpi_mul_rd;
 			end
 			ENABLE_DIV && pcpi_div_ready: begin
 				pcpi_int_wr = pcpi_div_wr;
 				pcpi_int_rd = pcpi_div_rd;
 			end
 		endcase
 	end
 
 
 	// Memory Interface
 
 	reg [1:0] mem_state;
 	reg [1:0] mem_wordsize;
 	reg [31:0] mem_rdata_word;
 	reg [31:0] mem_rdata_q;
 	reg mem_do_prefetch;
 	reg mem_do_rinst;
 	reg mem_do_rdata;
 	reg mem_do_wdata;
 
 	wire mem_xfer;
 	reg mem_la_secondword, mem_la_firstword_reg, last_mem_valid;
 	wire mem_la_firstword = COMPRESSED_ISA && (mem_do_prefetch || mem_do_rinst) && next_pc[1] && !mem_la_secondword;
 	wire mem_la_firstword_xfer = COMPRESSED_ISA && mem_xfer && (!last_mem_valid ? mem_la_firstword : mem_la_firstword_reg);
 
 	reg prefetched_high_word;
 	reg clear_prefetched_high_word;
 	reg [15:0] mem_16bit_buffer;
 
 	wire [31:0] mem_rdata_latched_noshuffle;
 	wire [31:0] mem_rdata_latched;
 
 	wire mem_la_use_prefetched_high_word = COMPRESSED_ISA && mem_la_firstword && prefetched_high_word && !clear_prefetched_high_word;
 	assign mem_xfer = (mem_valid_i && mem_ready) || (mem_la_use_prefetched_high_word && mem_do_rinst);
 
 	wire mem_busy = |{mem_do_prefetch, mem_do_rinst, mem_do_rdata, mem_do_wdata};
 	wire mem_done = resetn && ((mem_xfer && |mem_state && (mem_do_rinst || mem_do_rdata || mem_do_wdata)) || (&mem_state && mem_do_rinst)) &&
 			(!mem_la_firstword || (~&mem_rdata_latched[1:0] && mem_xfer));
 
 	assign mem_la_write = resetn && !mem_state && mem_do_wdata;
 	assign mem_la_read = resetn && ((!mem_la_use_prefetched_high_word && !mem_state && (mem_do_rinst || mem_do_prefetch || mem_do_rdata)) ||
 			(COMPRESSED_ISA && mem_xfer && (!last_mem_valid ? mem_la_firstword : mem_la_firstword_reg) && !mem_la_secondword && &mem_rdata_latched[1:0]));
 	assign mem_la_addr = (mem_do_prefetch || mem_do_rinst) ? {next_pc[31:2] + mem_la_firstword_xfer, 2'b00} : {reg_op1[31:2], 2'b00};
 
 	assign mem_rdata_latched_noshuffle = (mem_xfer || LATCHED_MEM_RDATA) ? mem_rdata : mem_rdata_q;
 
 	assign mem_rdata_latched = COMPRESSED_ISA && mem_la_use_prefetched_high_word ? {16'bx, mem_16bit_buffer} :
 			COMPRESSED_ISA && mem_la_secondword ? {mem_rdata_latched_noshuffle[15:0], mem_16bit_buffer} :
 			COMPRESSED_ISA && mem_la_firstword ? {16'bx, mem_rdata_latched_noshuffle[31:16]} : mem_rdata_latched_noshuffle;
 
 	always @(posedge clk) begin
 		if (!resetn) begin
 			mem_la_firstword_reg <= 0;
 			last_mem_valid <= 0;
 		end else begin
 			if (!last_mem_valid)
 				mem_la_firstword_reg <= mem_la_firstword;
 			last_mem_valid <= mem_valid_i && !mem_ready;
 		end
 	end
 
 	always @* begin
 		(* full_case *)
 		case (mem_wordsize)
 			0: begin
 				mem_la_wdata = reg_op2;
 				mem_la_wstrb = 4'b1111;
 				mem_rdata_word = mem_rdata;
 			end
 			1: begin
 				mem_la_wdata = {2{reg_op2[15:0]}};
 				mem_la_wstrb = reg_op1[1] ? 4'b1100 : 4'b0011;
 				case (reg_op1[1])
 					1'b0: mem_rdata_word = {16'b0, mem_rdata[15: 0]};
 					1'b1: mem_rdata_word = {16'b0, mem_rdata[31:16]};
 				endcase
 			end
 			2: begin
 				mem_la_wdata = {4{reg_op2[7:0]}};
 				mem_la_wstrb = 4'b0001 << reg_op1[1:0];
 				case (reg_op1[1:0])
 					2'b00: mem_rdata_word = {24'b0, mem_rdata[ 7: 0]};
 					2'b01: mem_rdata_word = {24'b0, mem_rdata[15: 8]};
 					2'b10: mem_rdata_word = {24'b0, mem_rdata[23:16]};
 					2'b11: mem_rdata_word = {24'b0, mem_rdata[31:24]};
 				endcase
 			end
 		endcase
 	end
 
 	always @(posedge clk) begin
 		if (mem_xfer) begin
 			mem_rdata_q <= COMPRESSED_ISA ? mem_rdata_latched : mem_rdata;
 			next_insn_opcode <= COMPRESSED_ISA ? mem_rdata_latched : mem_rdata;
 		end
 
 		if (COMPRESSED_ISA && mem_done && (mem_do_prefetch || mem_do_rinst)) begin
 			case (mem_rdata_latched[1:0])
 				2'b00: begin // Quadrant 0
 					case (mem_rdata_latched[15:13])
 						3'b000: begin // C.ADDI4SPN
 							mem_rdata_q[14:12] <= 3'b000;
 							mem_rdata_q[31:20] <= {2'b0, mem_rdata_latched[10:7], mem_rdata_latched[12:11], mem_rdata_latched[5], mem_rdata_latched[6], 2'b00};
 						end
 						3'b010: begin // C.LW
 							mem_rdata_q[31:20] <= {5'b0, mem_rdata_latched[5], mem_rdata_latched[12:10], mem_rdata_latched[6], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 						3'b 110: begin // C.SW
 							{mem_rdata_q[31:25], mem_rdata_q[11:7]} <= {5'b0, mem_rdata_latched[5], mem_rdata_latched[12:10], mem_rdata_latched[6], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 					endcase
 				end
 				2'b01: begin // Quadrant 1
 					case (mem_rdata_latched[15:13])
 						3'b 000: begin // C.ADDI
 							mem_rdata_q[14:12] <= 3'b000;
 							mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 						end
 						3'b 010: begin // C.LI
 							mem_rdata_q[14:12] <= 3'b000;
 							mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 						end
 						3'b 011: begin
 							if (mem_rdata_latched[11:7] == 2) begin // C.ADDI16SP
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[4:3],
 										mem_rdata_latched[5], mem_rdata_latched[2], mem_rdata_latched[6], 4'b 0000});
 							end else begin // C.LUI
 								mem_rdata_q[31:12] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 							end
 						end
 						3'b100: begin
 							if (mem_rdata_latched[11:10] == 2'b00) begin // C.SRLI
 								mem_rdata_q[31:25] <= 7'b0000000;
 								mem_rdata_q[14:12] <= 3'b 101;
 							end
 							if (mem_rdata_latched[11:10] == 2'b01) begin // C.SRAI
 								mem_rdata_q[31:25] <= 7'b0100000;
 								mem_rdata_q[14:12] <= 3'b 101;
 							end
 							if (mem_rdata_latched[11:10] == 2'b10) begin // C.ANDI
 								mem_rdata_q[14:12] <= 3'b111;
 								mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
 							end
 							if (mem_rdata_latched[12:10] == 3'b011) begin // C.SUB, C.XOR, C.OR, C.AND
 								if (mem_rdata_latched[6:5] == 2'b00) mem_rdata_q[14:12] <= 3'b000;
 								if (mem_rdata_latched[6:5] == 2'b01) mem_rdata_q[14:12] <= 3'b100;
 								if (mem_rdata_latched[6:5] == 2'b10) mem_rdata_q[14:12] <= 3'b110;
 								if (mem_rdata_latched[6:5] == 2'b11) mem_rdata_q[14:12] <= 3'b111;
 								mem_rdata_q[31:25] <= mem_rdata_latched[6:5] == 2'b00 ? 7'b0100000 : 7'b0000000;
 							end
 						end
 						3'b 110: begin // C.BEQZ
 							mem_rdata_q[14:12] <= 3'b000;
 							{ mem_rdata_q[31], mem_rdata_q[7], mem_rdata_q[30:25], mem_rdata_q[11:8] } <=
 									$signed({mem_rdata_latched[12], mem_rdata_latched[6:5], mem_rdata_latched[2],
 											mem_rdata_latched[11:10], mem_rdata_latched[4:3]});
 						end
 						3'b 111: begin // C.BNEZ
 							mem_rdata_q[14:12] <= 3'b001;
 							{ mem_rdata_q[31], mem_rdata_q[7], mem_rdata_q[30:25], mem_rdata_q[11:8] } <=
 									$signed({mem_rdata_latched[12], mem_rdata_latched[6:5], mem_rdata_latched[2],
 											mem_rdata_latched[11:10], mem_rdata_latched[4:3]});
 						end
 					endcase
 				end
 				2'b10: begin // Quadrant 2
 					case (mem_rdata_latched[15:13])
 						3'b000: begin // C.SLLI
 							mem_rdata_q[31:25] <= 7'b0000000;
 							mem_rdata_q[14:12] <= 3'b 001;
 						end
 						3'b010: begin // C.LWSP
 							mem_rdata_q[31:20] <= {4'b0, mem_rdata_latched[3:2], mem_rdata_latched[12], mem_rdata_latched[6:4], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 						3'b100: begin
 							if (mem_rdata_latched[12] == 0 && mem_rdata_latched[6:2] == 0) begin // C.JR
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:20] <= 12'b0;
 							end
 							if (mem_rdata_latched[12] == 0 && mem_rdata_latched[6:2] != 0) begin // C.MV
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:25] <= 7'b0000000;
 							end
 							if (mem_rdata_latched[12] != 0 && mem_rdata_latched[11:7] != 0 && mem_rdata_latched[6:2] == 0) begin // C.JALR
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:20] <= 12'b0;
 							end
 							if (mem_rdata_latched[12] != 0 && mem_rdata_latched[6:2] != 0) begin // C.ADD
 								mem_rdata_q[14:12] <= 3'b000;
 								mem_rdata_q[31:25] <= 7'b0000000;
 							end
 						end
 						3'b110: begin // C.SWSP
 							{mem_rdata_q[31:25], mem_rdata_q[11:7]} <= {4'b0, mem_rdata_latched[8:7], mem_rdata_latched[12:9], 2'b00};
 							mem_rdata_q[14:12] <= 3'b 010;
 						end
 					endcase
 				end
 			endcase
 		end
 	end
 /*
 	always @(posedge clk) begin
 		if (resetn && !trap) begin
 			if (mem_do_prefetch || mem_do_rinst || mem_do_rdata)
 				//`assert(!mem_do_wdata);
 
 			if (mem_do_prefetch || mem_do_rinst)
 				//`assert(!mem_do_rdata);
 
 			if (mem_do_rdata)
 				//`assert(!mem_do_prefetch && !mem_do_rinst);
 
 			if (mem_do_wdata)
 				//`assert(!(mem_do_prefetch || mem_do_rinst || mem_do_rdata));
 
 			if (mem_state == 2 || mem_state == 3)
 				//`assert(mem_valid || mem_do_prefetch);
 		end
 	end*/
 
 	always @(posedge clk) begin
 		if (!resetn || trap) begin
 			if (!resetn)
 				mem_state <= 0;
 			if (!resetn || mem_ready)
 				mem_valid_i <= 0;
 			mem_la_secondword <= 0;
 			prefetched_high_word <= 0;
 		end else begin
 			if (mem_la_read || mem_la_write) begin
 				mem_addr_i <= mem_la_addr;
 				mem_wstrb_i <= mem_la_wstrb & {4{mem_la_write}};
 			end
 			if (mem_la_write) begin
 				mem_wdata_i <= mem_la_wdata;
 			end
 			case (mem_state)
 				0: begin
 					if (mem_do_prefetch || mem_do_rinst || mem_do_rdata) begin
 						mem_valid_i <= !mem_la_use_prefetched_high_word;
 						mem_instr_i <= mem_do_prefetch || mem_do_rinst;
 						mem_wstrb_i <= 0;
 						mem_state <= 1;
 					end
 					if (mem_do_wdata) begin
 						mem_valid_i <= 1;
 						mem_instr_i <= 0;
 						mem_state <= 2;
 					end
 				end
 				1: begin
 					//`assert(mem_wstrb == 0);
 					//`assert(mem_do_prefetch || mem_do_rinst || mem_do_rdata);
 					//`assert(mem_valid == !mem_la_use_prefetched_high_word);
 					//`assert(mem_instr == (mem_do_prefetch || mem_do_rinst));
 					if (mem_xfer) begin
 						if (COMPRESSED_ISA && mem_la_read) begin
 							mem_valid_i <= 1;
 							mem_la_secondword <= 1;
 							if (!mem_la_use_prefetched_high_word)
 								mem_16bit_buffer <= mem_rdata[31:16];
 						end else begin
 							mem_valid_i <= 0;
 							mem_la_secondword <= 0;
 							if (COMPRESSED_ISA && !mem_do_rdata) begin
 								if (~&mem_rdata[1:0] || mem_la_secondword) begin
 									mem_16bit_buffer <= mem_rdata[31:16];
 									prefetched_high_word <= 1;
 								end else begin
 									prefetched_high_word <= 0;
 								end
 							end
 							mem_state <= mem_do_rinst || mem_do_rdata ? 0 : 3;
 						end
 					end
 				end
 				2: begin
 					//`assert(mem_wstrb != 0);
 					//`assert(mem_do_wdata);
 					if (mem_xfer) begin
 						mem_valid_i <= 0;
 						mem_state <= 0;
 					end
 				end
 				3: begin
 					//`assert(mem_wstrb == 0);
 					//`assert(mem_do_prefetch);
 					if (mem_do_rinst) begin
 						mem_state <= 0;
 					end
 				end
 			endcase
 		end
 
 		if (clear_prefetched_high_word)
 			prefetched_high_word <= 0;
 	end
 
 
 	// Instruction Decoder
 
 	reg instr_lui, instr_auipc, instr_jal, instr_jalr;
 	reg instr_beq, instr_bne, instr_blt, instr_bge, instr_bltu, instr_bgeu;
 	reg instr_lb, instr_lh, instr_lw, instr_lbu, instr_lhu, instr_sb, instr_sh, instr_sw;
 	reg instr_addi, instr_slti, instr_sltiu, instr_xori, instr_ori, instr_andi, instr_slli, instr_srli, instr_srai;
 	reg instr_add, instr_sub, instr_sll, instr_slt, instr_sltu, instr_xor, instr_srl, instr_sra, instr_or, instr_and;
 	reg instr_rdcycle, instr_rdcycleh, instr_rdinstr, instr_rdinstrh, instr_ecall_ebreak;
 	reg instr_getq, instr_setq, instr_retirq, instr_maskirq, instr_waitirq, instr_timer;
 	wire instr_trap;
 
 	reg [regindex_bits-1:0] decoded_rd, decoded_rs1, decoded_rs2;
 	reg [31:0] decoded_imm, decoded_imm_uj;
 	reg decoder_trigger;
 	reg decoder_trigger_q;
 	reg decoder_pseudo_trigger;
 	reg decoder_pseudo_trigger_q;
 	reg compressed_instr;
 
 	reg is_lui_auipc_jal;
 	reg is_lb_lh_lw_lbu_lhu;
 	reg is_slli_srli_srai;
 	reg is_jalr_addi_slti_sltiu_xori_ori_andi;
 	reg is_sb_sh_sw;
 	reg is_sll_srl_sra;
 	reg is_lui_auipc_jal_jalr_addi_add_sub;
 	reg is_slti_blt_slt;
 	reg is_sltiu_bltu_sltu;
 	reg is_beq_bne_blt_bge_bltu_bgeu;
 	reg is_lbu_lhu_lw;
 	reg is_alu_reg_imm;
 	reg is_alu_reg_reg;
 	reg is_compare;
 
 	assign instr_trap = (CATCH_ILLINSN || WITH_PCPI) && !{instr_lui, instr_auipc, instr_jal, instr_jalr,
 			instr_beq, instr_bne, instr_blt, instr_bge, instr_bltu, instr_bgeu,
 			instr_lb, instr_lh, instr_lw, instr_lbu, instr_lhu, instr_sb, instr_sh, instr_sw,
 			instr_addi, instr_slti, instr_sltiu, instr_xori, instr_ori, instr_andi, instr_slli, instr_srli, instr_srai,
 			instr_add, instr_sub, instr_sll, instr_slt, instr_sltu, instr_xor, instr_srl, instr_sra, instr_or, instr_and,
 			instr_rdcycle, instr_rdcycleh, instr_rdinstr, instr_rdinstrh,
 			instr_getq, instr_setq, instr_retirq, instr_maskirq, instr_waitirq, instr_timer};
 
 	wire is_rdcycle_rdcycleh_rdinstr_rdinstrh;
 	assign is_rdcycle_rdcycleh_rdinstr_rdinstrh = |{instr_rdcycle, instr_rdcycleh, instr_rdinstr, instr_rdinstrh};
 
 	reg [63:0] new_ascii_instr;
 	/*
 	`FORMAL_KEEP reg [63:0] dbg_ascii_instr;
 	`FORMAL_KEEP reg [31:0] dbg_insn_imm;
 	`FORMAL_KEEP reg [4:0] dbg_insn_rs1;
 	`FORMAL_KEEP reg [4:0] dbg_insn_rs2;
 	`FORMAL_KEEP reg [4:0] dbg_insn_rd;
 	`FORMAL_KEEP reg [31:0] dbg_rs1val;
 	`FORMAL_KEEP reg [31:0] dbg_rs2val;
 	`FORMAL_KEEP reg dbg_rs1val_valid;
 	`FORMAL_KEEP reg dbg_rs2val_valid;*/
 
 	always @* begin
 		new_ascii_instr = "";
 
 		if (instr_lui)      new_ascii_instr = "lui";
 		if (instr_auipc)    new_ascii_instr = "auipc";
 		if (instr_jal)      new_ascii_instr = "jal";
 		if (instr_jalr)     new_ascii_instr = "jalr";
 
 		if (instr_beq)      new_ascii_instr = "beq";
 		if (instr_bne)      new_ascii_instr = "bne";
 		if (instr_blt)      new_ascii_instr = "blt";
 		if (instr_bge)      new_ascii_instr = "bge";
 		if (instr_bltu)     new_ascii_instr = "bltu";
 		if (instr_bgeu)     new_ascii_instr = "bgeu";
 
 		if (instr_lb)       new_ascii_instr = "lb";
 		if (instr_lh)       new_ascii_instr = "lh";
 		if (instr_lw)       new_ascii_instr = "lw";
 		if (instr_lbu)      new_ascii_instr = "lbu";
 		if (instr_lhu)      new_ascii_instr = "lhu";
 		if (instr_sb)       new_ascii_instr = "sb";
 		if (instr_sh)       new_ascii_instr = "sh";
 		if (instr_sw)       new_ascii_instr = "sw";
 
 		if (instr_addi)     new_ascii_instr = "addi";
 		if (instr_slti)     new_ascii_instr = "slti";
 		if (instr_sltiu)    new_ascii_instr = "sltiu";
 		if (instr_xori)     new_ascii_instr = "xori";
 		if (instr_ori)      new_ascii_instr = "ori";
 		if (instr_andi)     new_ascii_instr = "andi";
 		if (instr_slli)     new_ascii_instr = "slli";
 		if (instr_srli)     new_ascii_instr = "srli";
 		if (instr_srai)     new_ascii_instr = "srai";
 
 		if (instr_add)      new_ascii_instr = "add";
 		if (instr_sub)      new_ascii_instr = "sub";
 		if (instr_sll)      new_ascii_instr = "sll";
 		if (instr_slt)      new_ascii_instr = "slt";
 		if (instr_sltu)     new_ascii_instr = "sltu";
 		if (instr_xor)      new_ascii_instr = "xor";
 		if (instr_srl)      new_ascii_instr = "srl";
 		if (instr_sra)      new_ascii_instr = "sra";
 		if (instr_or)       new_ascii_instr = "or";
 		if (instr_and)      new_ascii_instr = "and";
 
 		if (instr_rdcycle)  new_ascii_instr = "rdcycle";
 		if (instr_rdcycleh) new_ascii_instr = "rdcycleh";
 		if (instr_rdinstr)  new_ascii_instr = "rdinstr";
 		if (instr_rdinstrh) new_ascii_instr = "rdinstrh";
 
 		if (instr_getq)     new_ascii_instr = "getq";
 		if (instr_setq)     new_ascii_instr = "setq";
 		if (instr_retirq)   new_ascii_instr = "retirq";
 		if (instr_maskirq)  new_ascii_instr = "maskirq";
 		if (instr_waitirq)  new_ascii_instr = "waitirq";
 		if (instr_timer)    new_ascii_instr = "timer";
 	end
 
 	reg [63:0] q_ascii_instr;
 	reg [31:0] q_insn_imm;
 	reg [31:0] q_insn_opcode;
 	reg [4:0] q_insn_rs1;
 	reg [4:0] q_insn_rs2;
 	reg [4:0] q_insn_rd;
 	reg dbg_next;
 
 	wire launch_next_insn;
 	reg dbg_valid_insn;
 
 	reg [63:0] cached_ascii_instr;
 	reg [31:0] cached_insn_imm;
 	reg [31:0] cached_insn_opcode;
 	reg [4:0] cached_insn_rs1;
 	reg [4:0] cached_insn_rs2;
 	reg [4:0] cached_insn_rd;
 
 	always @(posedge clk) begin
 		q_ascii_instr <= dbg_ascii_instr;
 		q_insn_imm <= dbg_insn_imm;
 		q_insn_opcode <= dbg_insn_opcode;
 		q_insn_rs1 <= dbg_insn_rs1;
 		q_insn_rs2 <= dbg_insn_rs2;
 		q_insn_rd <= dbg_insn_rd;
 		dbg_next <= launch_next_insn;
 
 		if (!resetn || trap)
 			dbg_valid_insn <= 0;
 		else if (launch_next_insn)
 			dbg_valid_insn <= 1;
 
 		if (decoder_trigger_q) begin
 			cached_ascii_instr <= new_ascii_instr;
 			cached_insn_imm <= decoded_imm;
 			if (&next_insn_opcode[1:0])
 				cached_insn_opcode <= next_insn_opcode;
 			else
 				cached_insn_opcode <= {16'b0, next_insn_opcode[15:0]};
 			cached_insn_rs1 <= decoded_rs1;
 			cached_insn_rs2 <= decoded_rs2;
 			cached_insn_rd <= decoded_rd;
 		end
 
 		if (launch_next_insn) begin
 			dbg_insn_addr <= next_pc;
 		end
 	end
 
 	always @* begin
 		dbg_ascii_instr = q_ascii_instr;
 		dbg_insn_imm = q_insn_imm;
 		dbg_insn_opcode = q_insn_opcode;
 		dbg_insn_rs1 = q_insn_rs1;
 		dbg_insn_rs2 = q_insn_rs2;
 		dbg_insn_rd = q_insn_rd;
 
 		if (dbg_next) begin
 			if (decoder_pseudo_trigger_q) begin
 				dbg_ascii_instr = cached_ascii_instr;
 				dbg_insn_imm = cached_insn_imm;
 				dbg_insn_opcode = cached_insn_opcode;
 				dbg_insn_rs1 = cached_insn_rs1;
 				dbg_insn_rs2 = cached_insn_rs2;
 				dbg_insn_rd = cached_insn_rd;
 			end else begin
 				dbg_ascii_instr = new_ascii_instr;
 				if (&next_insn_opcode[1:0])
 					dbg_insn_opcode = next_insn_opcode;
 				else
 					dbg_insn_opcode = {16'b0, next_insn_opcode[15:0]};
 				dbg_insn_imm = decoded_imm;
 				dbg_insn_rs1 = decoded_rs1;
 				dbg_insn_rs2 = decoded_rs2;
 				dbg_insn_rd = decoded_rd;
 			end
 		end
 	end
 
 `ifdef DEBUGASM
 	always @(posedge clk) begin
 		if (dbg_next) begin
 			$display("debugasm %x %x %s", dbg_insn_addr, dbg_insn_opcode, dbg_ascii_instr ? dbg_ascii_instr : "*");
 		end
 	end
 `endif
 
 `ifdef DEBUG
 	always @(posedge clk) begin
 		if (dbg_next) begin
 			if (&dbg_insn_opcode[1:0])
 				$display("DECODE: 0x%08x 0x%08x %-0s", dbg_insn_addr, dbg_insn_opcode, dbg_ascii_instr ? dbg_ascii_instr : "UNKNOWN");
 			else
 				$display("DECODE: 0x%08x     0x%04x %-0s", dbg_insn_addr, dbg_insn_opcode[15:0], dbg_ascii_instr ? dbg_ascii_instr : "UNKNOWN");
 		end
 	end
 `endif
 
 	always @(posedge clk) begin
 		is_lui_auipc_jal <= |{instr_lui, instr_auipc, instr_jal};
 		is_lui_auipc_jal_jalr_addi_add_sub <= |{instr_lui, instr_auipc, instr_jal, instr_jalr, instr_addi, instr_add, instr_sub};
 		is_slti_blt_slt <= |{instr_slti, instr_blt, instr_slt};
 		is_sltiu_bltu_sltu <= |{instr_sltiu, instr_bltu, instr_sltu};
 		is_lbu_lhu_lw <= |{instr_lbu, instr_lhu, instr_lw};
 		is_compare <= |{is_beq_bne_blt_bge_bltu_bgeu, instr_slti, instr_slt, instr_sltiu, instr_sltu};
 
 		if (mem_do_rinst && mem_done) begin
 			instr_lui     <= mem_rdata_latched[6:0] == 7'b0110111;
 			instr_auipc   <= mem_rdata_latched[6:0] == 7'b0010111;
 			instr_jal     <= mem_rdata_latched[6:0] == 7'b1101111;
 			instr_jalr    <= mem_rdata_latched[6:0] == 7'b1100111 && mem_rdata_latched[14:12] == 3'b000;
 			instr_retirq  <= mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000010 && ENABLE_IRQ;
 			instr_waitirq <= mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000100 && ENABLE_IRQ;
 
 			is_beq_bne_blt_bge_bltu_bgeu <= mem_rdata_latched[6:0] == 7'b1100011;
 			is_lb_lh_lw_lbu_lhu          <= mem_rdata_latched[6:0] == 7'b0000011;
 			is_sb_sh_sw                  <= mem_rdata_latched[6:0] == 7'b0100011;
 			is_alu_reg_imm               <= mem_rdata_latched[6:0] == 7'b0010011;
 			is_alu_reg_reg               <= mem_rdata_latched[6:0] == 7'b0110011;
 
 			{ decoded_imm_uj[31:20], decoded_imm_uj[10:1], decoded_imm_uj[11], decoded_imm_uj[19:12], decoded_imm_uj[0] } <= $signed({mem_rdata_latched[31:12], 1'b0});
 
 			decoded_rd <= mem_rdata_latched[11:7];
 			decoded_rs1 <= mem_rdata_latched[19:15];
 			decoded_rs2 <= mem_rdata_latched[24:20];
 
 			if (mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000000 && ENABLE_IRQ && ENABLE_IRQ_QREGS)
 				decoded_rs1[regindex_bits-1] <= 1; // instr_getq
 
 			if (mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000010 && ENABLE_IRQ)
 				decoded_rs1 <= ENABLE_IRQ_QREGS ? irqregs_offset : 3; // instr_retirq
 
 			compressed_instr <= 0;
 			if (COMPRESSED_ISA && mem_rdata_latched[1:0] != 2'b11) begin
 				compressed_instr <= 1;
 				decoded_rd <= 0;
 				decoded_rs1 <= 0;
 				decoded_rs2 <= 0;
 
 				{ decoded_imm_uj[31:11], decoded_imm_uj[4], decoded_imm_uj[9:8], decoded_imm_uj[10], decoded_imm_uj[6],
 				  decoded_imm_uj[7], decoded_imm_uj[3:1], decoded_imm_uj[5], decoded_imm_uj[0] } <= $signed({mem_rdata_latched[12:2], 1'b0});
 
 				case (mem_rdata_latched[1:0])
 					2'b00: begin // Quadrant 0
 						case (mem_rdata_latched[15:13])
 							3'b000: begin // C.ADDI4SPN
 								is_alu_reg_imm <= |mem_rdata_latched[12:5];
 								decoded_rs1 <= 2;
 								decoded_rd <= 8 + mem_rdata_latched[4:2];
 							end
 							3'b010: begin // C.LW
 								is_lb_lh_lw_lbu_lhu <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rd <= 8 + mem_rdata_latched[4:2];
 							end
 							3'b110: begin // C.SW
 								is_sb_sh_sw <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rs2 <= 8 + mem_rdata_latched[4:2];
 							end
 						endcase
 					end
 					2'b01: begin // Quadrant 1
 						case (mem_rdata_latched[15:13])
 							3'b000: begin // C.NOP / C.ADDI
 								is_alu_reg_imm <= 1;
 								decoded_rd <= mem_rdata_latched[11:7];
 								decoded_rs1 <= mem_rdata_latched[11:7];
 							end
 							3'b001: begin // C.JAL
 								instr_jal <= 1;
 								decoded_rd <= 1;
 							end
 							3'b 010: begin // C.LI
 								is_alu_reg_imm <= 1;
 								decoded_rd <= mem_rdata_latched[11:7];
 								decoded_rs1 <= 0;
 							end
 							3'b 011: begin
 								if (mem_rdata_latched[12] || mem_rdata_latched[6:2]) begin
 									if (mem_rdata_latched[11:7] == 2) begin // C.ADDI16SP
 										is_alu_reg_imm <= 1;
 										decoded_rd <= mem_rdata_latched[11:7];
 										decoded_rs1 <= mem_rdata_latched[11:7];
 									end else begin // C.LUI
 										instr_lui <= 1;
 										decoded_rd <= mem_rdata_latched[11:7];
 										decoded_rs1 <= 0;
 									end
 								end
 							end
 							3'b100: begin
 								if (!mem_rdata_latched[11] && !mem_rdata_latched[12]) begin // C.SRLI, C.SRAI
 									is_alu_reg_imm <= 1;
 									decoded_rd <= 8 + mem_rdata_latched[9:7];
 									decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 									decoded_rs2 <= {mem_rdata_latched[12], mem_rdata_latched[6:2]};
 								end
 								if (mem_rdata_latched[11:10] == 2'b10) begin // C.ANDI
 									is_alu_reg_imm <= 1;
 									decoded_rd <= 8 + mem_rdata_latched[9:7];
 									decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								end
 								if (mem_rdata_latched[12:10] == 3'b011) begin // C.SUB, C.XOR, C.OR, C.AND
 									is_alu_reg_reg <= 1;
 									decoded_rd <= 8 + mem_rdata_latched[9:7];
 									decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 									decoded_rs2 <= 8 + mem_rdata_latched[4:2];
 								end
 							end
 							3'b101: begin // C.J
 								instr_jal <= 1;
 							end
 							3'b110: begin // C.BEQZ
 								is_beq_bne_blt_bge_bltu_bgeu <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rs2 <= 0;
 							end
 							3'b111: begin // C.BNEZ
 								is_beq_bne_blt_bge_bltu_bgeu <= 1;
 								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
 								decoded_rs2 <= 0;
 							end
 						endcase
 					end
 					2'b10: begin // Quadrant 2
 						case (mem_rdata_latched[15:13])
 							3'b000: begin // C.SLLI
 								if (!mem_rdata_latched[12]) begin
 									is_alu_reg_imm <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= mem_rdata_latched[11:7];
 									decoded_rs2 <= {mem_rdata_latched[12], mem_rdata_latched[6:2]};
 								end
 							end
 							3'b010: begin // C.LWSP
 								if (mem_rdata_latched[11:7]) begin
 									is_lb_lh_lw_lbu_lhu <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= 2;
 								end
 							end
 							3'b100: begin
 								if (mem_rdata_latched[12] == 0 && mem_rdata_latched[11:7] != 0 && mem_rdata_latched[6:2] == 0) begin // C.JR
 									instr_jalr <= 1;
 									decoded_rd <= 0;
 									decoded_rs1 <= mem_rdata_latched[11:7];
 								end
 								if (mem_rdata_latched[12] == 0 && mem_rdata_latched[6:2] != 0) begin // C.MV
 									is_alu_reg_reg <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= 0;
 									decoded_rs2 <= mem_rdata_latched[6:2];
 								end
 								if (mem_rdata_latched[12] != 0 && mem_rdata_latched[11:7] != 0 && mem_rdata_latched[6:2] == 0) begin // C.JALR
 									instr_jalr <= 1;
 									decoded_rd <= 1;
 									decoded_rs1 <= mem_rdata_latched[11:7];
 								end
 								if (mem_rdata_latched[12] != 0 && mem_rdata_latched[6:2] != 0) begin // C.ADD
 									is_alu_reg_reg <= 1;
 									decoded_rd <= mem_rdata_latched[11:7];
 									decoded_rs1 <= mem_rdata_latched[11:7];
 									decoded_rs2 <= mem_rdata_latched[6:2];
 								end
 							end
 							3'b110: begin // C.SWSP
 								is_sb_sh_sw <= 1;
 								decoded_rs1 <= 2;
 								decoded_rs2 <= mem_rdata_latched[6:2];
 							end
 						endcase
 					end
 				endcase
 			end
 		end
 
 		if (decoder_trigger && !decoder_pseudo_trigger) begin
 			pcpi_insn_i <= WITH_PCPI ? mem_rdata_q : 'bx;
 
 			instr_beq   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b000;
 			instr_bne   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b001;
 			instr_blt   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b100;
 			instr_bge   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b101;
 			instr_bltu  <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b110;
 			instr_bgeu  <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b111;
 
 			instr_lb    <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b000;
 			instr_lh    <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b001;
 			instr_lw    <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b010;
 			instr_lbu   <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b100;
 			instr_lhu   <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b101;
 
 			instr_sb    <= is_sb_sh_sw && mem_rdata_q[14:12] == 3'b000;
 			instr_sh    <= is_sb_sh_sw && mem_rdata_q[14:12] == 3'b001;
 			instr_sw    <= is_sb_sh_sw && mem_rdata_q[14:12] == 3'b010;
 
 			instr_addi  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b000;
 			instr_slti  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b010;
 			instr_sltiu <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b011;
 			instr_xori  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b100;
 			instr_ori   <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b110;
 			instr_andi  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b111;
 
 			instr_slli  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_srli  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_srai  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000;
 
 			instr_add   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b000 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_sub   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b000 && mem_rdata_q[31:25] == 7'b0100000;
 			instr_sll   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_slt   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b010 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_sltu  <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b011 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_xor   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b100 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_srl   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_sra   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000;
 			instr_or    <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b110 && mem_rdata_q[31:25] == 7'b0000000;
 			instr_and   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b111 && mem_rdata_q[31:25] == 7'b0000000;
 
 			instr_rdcycle  <= ((mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11000000000000000010) ||
 			                   (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11000000000100000010)) && ENABLE_COUNTERS;
 			instr_rdcycleh <= ((mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11001000000000000010) ||
 			                   (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11001000000100000010)) && ENABLE_COUNTERS && ENABLE_COUNTERS64;
 			instr_rdinstr  <=  (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11000000001000000010) && ENABLE_COUNTERS;
 			instr_rdinstrh <=  (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11001000001000000010) && ENABLE_COUNTERS && ENABLE_COUNTERS64;
 
 			instr_ecall_ebreak <= ((mem_rdata_q[6:0] == 7'b1110011 && !mem_rdata_q[31:21] && !mem_rdata_q[19:7]) ||
 					(COMPRESSED_ISA && mem_rdata_q[15:0] == 16'h9002));
 
 			instr_getq    <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000000 && ENABLE_IRQ && ENABLE_IRQ_QREGS;
 			instr_setq    <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000001 && ENABLE_IRQ && ENABLE_IRQ_QREGS;
 			instr_maskirq <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000011 && ENABLE_IRQ;
 			instr_timer   <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000101 && ENABLE_IRQ && ENABLE_IRQ_TIMER;
 
 			is_slli_srli_srai <= is_alu_reg_imm && |{
 				mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000
 			};
 
 			is_jalr_addi_slti_sltiu_xori_ori_andi <= instr_jalr || is_alu_reg_imm && |{
 				mem_rdata_q[14:12] == 3'b000,
 				mem_rdata_q[14:12] == 3'b010,
 				mem_rdata_q[14:12] == 3'b011,
 				mem_rdata_q[14:12] == 3'b100,
 				mem_rdata_q[14:12] == 3'b110,
 				mem_rdata_q[14:12] == 3'b111
 			};
 
 			is_sll_srl_sra <= is_alu_reg_reg && |{
 				mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000,
 				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000
 			};
 
 			is_lui_auipc_jal_jalr_addi_add_sub <= 0;
 			is_compare <= 0;
 
 			(* parallel_case *)
 			case (1'b1)
 				instr_jal:
 					decoded_imm <= decoded_imm_uj;
 				|{instr_lui, instr_auipc}:
 					decoded_imm <= mem_rdata_q[31:12] << 12;
 				|{instr_jalr, is_lb_lh_lw_lbu_lhu, is_alu_reg_imm}:
 					decoded_imm <= $signed(mem_rdata_q[31:20]);
 				is_beq_bne_blt_bge_bltu_bgeu:
 					decoded_imm <= $signed({mem_rdata_q[31], mem_rdata_q[7], mem_rdata_q[30:25], mem_rdata_q[11:8], 1'b0});
 				is_sb_sh_sw:
 					decoded_imm <= $signed({mem_rdata_q[31:25], mem_rdata_q[11:7]});
 				default:
 					decoded_imm <= 1'bx;
 			endcase
 		end
 
 		if (!resetn) begin
 			is_beq_bne_blt_bge_bltu_bgeu <= 0;
 			is_compare <= 0;
 
 			instr_beq   <= 0;
 			instr_bne   <= 0;
 			instr_blt   <= 0;
 			instr_bge   <= 0;
 			instr_bltu  <= 0;
 			instr_bgeu  <= 0;
 
 			instr_addi  <= 0;
 			instr_slti  <= 0;
 			instr_sltiu <= 0;
 			instr_xori  <= 0;
 			instr_ori   <= 0;
 			instr_andi  <= 0;
 
 			instr_add   <= 0;
 			instr_sub   <= 0;
 			instr_sll   <= 0;
 			instr_slt   <= 0;
 			instr_sltu  <= 0;
 			instr_xor   <= 0;
 			instr_srl   <= 0;
 			instr_sra   <= 0;
 			instr_or    <= 0;
 			instr_and   <= 0;
 		end
 	end
 
 
 	// Main State Machine
 
 	localparam cpu_state_trap   = 8'b10000000;
 	localparam cpu_state_fetch  = 8'b01000000;
 	localparam cpu_state_ld_rs1 = 8'b00100000;
 	localparam cpu_state_ld_rs2 = 8'b00010000;
 	localparam cpu_state_exec   = 8'b00001000;
 	localparam cpu_state_shift  = 8'b00000100;
 	localparam cpu_state_stmem  = 8'b00000010;
 	localparam cpu_state_ldmem  = 8'b00000001;
 
 	reg [7:0] cpu_state;
 	reg [1:0] irq_state;
 
 	//`FORMAL_KEEP reg [127:0] dbg_ascii_state;
 
 	always @* begin
 		dbg_ascii_state = "";
 		if (cpu_state == cpu_state_trap)   dbg_ascii_state = "trap";
 		if (cpu_state == cpu_state_fetch)  dbg_ascii_state = "fetch";
 		if (cpu_state == cpu_state_ld_rs1) dbg_ascii_state = "ld_rs1";
 		if (cpu_state == cpu_state_ld_rs2) dbg_ascii_state = "ld_rs2";
 		if (cpu_state == cpu_state_exec)   dbg_ascii_state = "exec";
 		if (cpu_state == cpu_state_shift)  dbg_ascii_state = "shift";
 		if (cpu_state == cpu_state_stmem)  dbg_ascii_state = "stmem";
 		if (cpu_state == cpu_state_ldmem)  dbg_ascii_state = "ldmem";
 	end
 
 	reg set_mem_do_rinst;
 	reg set_mem_do_rdata;
 	reg set_mem_do_wdata;
 
 	reg latched_store;
 	reg latched_stalu;
 	reg latched_branch;
 	reg latched_compr;
 	reg latched_trace;
 	reg latched_is_lu;
 	reg latched_is_lh;
 	reg latched_is_lb;
 	reg [regindex_bits-1:0] latched_rd;
 
 	reg [31:0] current_pc;
 	assign next_pc = latched_store && latched_branch ? reg_out & ~1 : reg_next_pc;
 
 	reg [3:0] pcpi_timeout_counter;
 	reg pcpi_timeout;
 
 	reg [31:0] next_irq_pending;
 	reg do_waitirq;
 
 	reg [31:0] alu_out, alu_out_q;
 	reg alu_out_0, alu_out_0_q;
 	reg alu_wait, alu_wait_2;
 
 	reg [31:0] alu_add_sub;
 	reg [31:0] alu_shl, alu_shr;
 	reg alu_eq, alu_ltu, alu_lts;
 
 	generate if (TWO_CYCLE_ALU) begin
 		always @(posedge clk) begin
 			alu_add_sub <= instr_sub ? reg_op1 - reg_op2 : reg_op1 + reg_op2;
 			alu_eq <= reg_op1 == reg_op2;
 			alu_lts <= $signed(reg_op1) < $signed(reg_op2);
 			alu_ltu <= reg_op1 < reg_op2;
 			alu_shl <= reg_op1 << reg_op2[4:0];
 			alu_shr <= $signed({instr_sra || instr_srai ? reg_op1[31] : 1'b0, reg_op1}) >>> reg_op2[4:0];
 		end
 	end else begin
 		always @* begin
 			alu_add_sub = instr_sub ? reg_op1 - reg_op2 : reg_op1 + reg_op2;
 			alu_eq = reg_op1 == reg_op2;
 			alu_lts = $signed(reg_op1) < $signed(reg_op2);
 			alu_ltu = reg_op1 < reg_op2;
 			alu_shl = reg_op1 << reg_op2[4:0];
 			alu_shr = $signed({instr_sra || instr_srai ? reg_op1[31] : 1'b0, reg_op1}) >>> reg_op2[4:0];
 		end
 	end endgenerate
 
 	always @* begin
 		alu_out_0 = 'bx;
 		(* parallel_case, full_case *)
 		case (1'b1)
 			instr_beq:
 				alu_out_0 = alu_eq;
 			instr_bne:
 				alu_out_0 = !alu_eq;
 			instr_bge:
 				alu_out_0 = !alu_lts;
 			instr_bgeu:
 				alu_out_0 = !alu_ltu;
 			is_slti_blt_slt && (!TWO_CYCLE_COMPARE || !{instr_beq,instr_bne,instr_bge,instr_bgeu}):
 				alu_out_0 = alu_lts;
 			is_sltiu_bltu_sltu && (!TWO_CYCLE_COMPARE || !{instr_beq,instr_bne,instr_bge,instr_bgeu}):
 				alu_out_0 = alu_ltu;
 		endcase
 
 		alu_out = 'bx;
 		(* parallel_case, full_case *)
 		case (1'b1)
 			is_lui_auipc_jal_jalr_addi_add_sub:
 				alu_out = alu_add_sub;
 			is_compare:
 				alu_out = alu_out_0;
 			instr_xori || instr_xor:
 				alu_out = reg_op1 ^ reg_op2;
 			instr_ori || instr_or:
 				alu_out = reg_op1 | reg_op2;
 			instr_andi || instr_and:
 				alu_out = reg_op1 & reg_op2;
 			BARREL_SHIFTER && (instr_sll || instr_slli):
 				alu_out = alu_shl;
 			BARREL_SHIFTER && (instr_srl || instr_srli || instr_sra || instr_srai):
 				alu_out = alu_shr;
 		endcase
 
 `ifdef RISCV_FORMAL_BLACKBOX_ALU
 		alu_out_0 = $anyseq;
 		alu_out = $anyseq;
 `endif
 	end
 
 	reg clear_prefetched_high_word_q;
 	always @(posedge clk) clear_prefetched_high_word_q <= clear_prefetched_high_word;
 
 	always @* begin
 		clear_prefetched_high_word = clear_prefetched_high_word_q;
 		if (!prefetched_high_word)
 			clear_prefetched_high_word = 0;
 		if (latched_branch || irq_state || !resetn)
 			clear_prefetched_high_word = COMPRESSED_ISA;
 	end
 
 	reg cpuregs_write;
 	reg [31:0] cpuregs_wrdata_i;
     assign cpuregs_wrdata = cpuregs_wrdata_i;
 	reg [31:0] cpuregs_rs1;
 	reg [31:0] cpuregs_rs2;
 	reg [regindex_bits-1:0] decoded_rs;
 
 	always @* begin
 		cpuregs_write = 0;
 		cpuregs_wrdata_i = 'bx;
 
 		if (cpu_state == cpu_state_fetch) begin
 			(* parallel_case *)
 			case (1'b1)
 				latched_branch: begin
 					cpuregs_wrdata_i = reg_pc + (latched_compr ? 2 : 4);
 					cpuregs_write = 1;
 				end
 				latched_store && !latched_branch: begin
 					cpuregs_wrdata_i = latched_stalu ? alu_out_q : reg_out;
 					cpuregs_write = 1;
 				end
 				ENABLE_IRQ && irq_state[0]: begin
 					cpuregs_wrdata_i = reg_next_pc | latched_compr;
 					cpuregs_write = 1;
 				end
 				ENABLE_IRQ && irq_state[1]: begin
 					cpuregs_wrdata_i = irq_pending & ~irq_mask;
 					cpuregs_write = 1;
 				end
 			endcase
 		end
 	end
 
 `ifndef PICORV32_REGS
 	always @(posedge clk) begin
 		if (resetn && cpuregs_write && latched_rd)
 			cpuregs[latched_rd] <= cpuregs_wrdata_i;
 	end
 
 	always @* begin
 		decoded_rs = 'bx;
 		if (ENABLE_REGS_DUALPORT) begin
 `ifndef RISCV_FORMAL_BLACKBOX_REGS
 			cpuregs_rs1 = decoded_rs1 ? cpuregs[decoded_rs1] : 0;
 			cpuregs_rs2 = decoded_rs2 ? cpuregs[decoded_rs2] : 0;
 `else
 			cpuregs_rs1 = decoded_rs1 ? $anyseq : 0;
 			cpuregs_rs2 = decoded_rs2 ? $anyseq : 0;
 `endif
 		end else begin
 			decoded_rs = (cpu_state == cpu_state_ld_rs2) ? decoded_rs2 : decoded_rs1;
 `ifndef RISCV_FORMAL_BLACKBOX_REGS
 			cpuregs_rs1 = decoded_rs ? cpuregs[decoded_rs] : 0;
 `else
 			cpuregs_rs1 = decoded_rs ? $anyseq : 0;
 `endif
 			cpuregs_rs2 = cpuregs_rs1;
 		end
 	end
 `else
 
 	assign cpuregs_waddr = latched_rd;
 	assign cpuregs_raddr1 = ENABLE_REGS_DUALPORT ? decoded_rs1 : decoded_rs;
 	assign cpuregs_raddr2 = ENABLE_REGS_DUALPORT ? decoded_rs2 : 0;
 
 	always @* begin
 		decoded_rs = 'bx;
 		if (ENABLE_REGS_DUALPORT) begin
 			cpuregs_rs1 = decoded_rs1 ? cpuregs_rdata1 : 0;
 			cpuregs_rs2 = decoded_rs2 ? cpuregs_rdata2 : 0;
 		end else begin
 			decoded_rs = (cpu_state == cpu_state_ld_rs2) ? decoded_rs2 : decoded_rs1;
 			cpuregs_rs1 = decoded_rs ? cpuregs_rdata1 : 0;
 			cpuregs_rs2 = cpuregs_rs1;
 		end
 	end
 `endif
 
 	assign launch_next_insn = cpu_state == cpu_state_fetch && decoder_trigger && (!ENABLE_IRQ || irq_delay || irq_active || !(irq_pending & ~irq_mask));
 
 	always @(posedge clk) begin
 		trap <= 0;
 		reg_sh <= 'bx;
 		reg_out <= 'bx;
 		set_mem_do_rinst = 0;
 		set_mem_do_rdata = 0;
 		set_mem_do_wdata = 0;
 
 		alu_out_0_q <= alu_out_0;
 		alu_out_q <= alu_out;
 
 		alu_wait <= 0;
 		alu_wait_2 <= 0;
 
 		if (launch_next_insn) begin
 			dbg_rs1val <= 'bx;
 			dbg_rs2val <= 'bx;
 			dbg_rs1val_valid <= 0;
 			dbg_rs2val_valid <= 0;
 		end
 
 		if (WITH_PCPI && CATCH_ILLINSN) begin
 			if (resetn && pcpi_valid_i && !pcpi_int_wait) begin
 				if (pcpi_timeout_counter)
 					pcpi_timeout_counter <= pcpi_timeout_counter - 1;
 			end else
 				pcpi_timeout_counter <= ~0;
 			pcpi_timeout <= !pcpi_timeout_counter;
 		end
 
 		if (ENABLE_COUNTERS) begin
 			count_cycle <= resetn ? count_cycle + 1 : 0;
 			if (!ENABLE_COUNTERS64) count_cycle[63:32] <= 0;
 		end else begin
 			count_cycle <= 'bx;
 			count_instr <= 'bx;
 		end
 
 		next_irq_pending = ENABLE_IRQ ? irq_pending & LATCHED_IRQ : 'bx;
 
 		if (ENABLE_IRQ && ENABLE_IRQ_TIMER && timer) begin
 			if (timer - 1 == 0)
 				next_irq_pending[irq_timer] = 1;
 			timer <= timer - 1;
 		end
 
 		if (ENABLE_IRQ) begin
 			next_irq_pending = next_irq_pending | irq;
 		end
 
 		decoder_trigger <= mem_do_rinst && mem_done;
 		decoder_trigger_q <= decoder_trigger;
 		decoder_pseudo_trigger <= 0;
 		decoder_pseudo_trigger_q <= decoder_pseudo_trigger;
 		do_waitirq <= 0;
 
 		trace_valid <= 0;
 
 		if (!ENABLE_TRACE)
 			trace_data <= 'bx;
 
 		if (!resetn) begin
 			reg_pc <= PROGADDR_RESET;
 			reg_next_pc <= PROGADDR_RESET;
 			if (ENABLE_COUNTERS)
 				count_instr <= 0;
 			latched_store <= 0;
 			latched_stalu <= 0;
 			latched_branch <= 0;
 			latched_trace <= 0;
 			latched_is_lu <= 0;
 			latched_is_lh <= 0;
 			latched_is_lb <= 0;
 			pcpi_valid_i <= 0;
 			pcpi_timeout <= 0;
 			irq_active <= 0;
 			irq_delay <= 0;
 			irq_mask <= ~0;
 			next_irq_pending = 0;
 			irq_state <= 0;
 			eoi <= 0;
 			timer <= 0;
 			if (~STACKADDR) begin
 				latched_store <= 1;
 				latched_rd <= 2;
 				reg_out <= STACKADDR;
 			end
 			cpu_state <= cpu_state_fetch;
 		end else
 		(* parallel_case, full_case *)
 		case (cpu_state)
 			cpu_state_trap: begin
 				trap <= 1;
 			end
 
 			cpu_state_fetch: begin
 				mem_do_rinst <= !decoder_trigger && !do_waitirq;
 				mem_wordsize <= 0;
 
 				current_pc = reg_next_pc;
 
 				(* parallel_case *)
 				case (1'b1)
 					latched_branch: begin
 						current_pc = latched_store ? (latched_stalu ? alu_out_q : reg_out) & ~1 : reg_next_pc;
 						//`debug($display("ST_RD:  %2d 0x%08x, BRANCH 0x%08x", latched_rd, reg_pc + (latched_compr ? 2 : 4), current_pc);)
 					end
 					latched_store && !latched_branch: begin
 						//`debug($display("ST_RD:  %2d 0x%08x", latched_rd, latched_stalu ? alu_out_q : reg_out);)
 					end
 					ENABLE_IRQ && irq_state[0]: begin
 						current_pc = PROGADDR_IRQ;
 						irq_active <= 1;
 						mem_do_rinst <= 1;
 					end
 					ENABLE_IRQ && irq_state[1]: begin
 						eoi <= irq_pending & ~irq_mask;
 						next_irq_pending = next_irq_pending & irq_mask;
 					end
 				endcase
 
 				if (ENABLE_TRACE && latched_trace) begin
 					latched_trace <= 0;
 					trace_valid <= 1;
 					if (latched_branch)
 						trace_data <= (irq_active ? TRACE_IRQ : 0) | TRACE_BRANCH | (current_pc & 32'hfffffffe);
 					else
 						trace_data <= (irq_active ? TRACE_IRQ : 0) | (latched_stalu ? alu_out_q : reg_out);
 				end
 
 				reg_pc <= current_pc;
 				reg_next_pc <= current_pc;
 
 				latched_store <= 0;
 				latched_stalu <= 0;
 				latched_branch <= 0;
 				latched_is_lu <= 0;
 				latched_is_lh <= 0;
 				latched_is_lb <= 0;
 				latched_rd <= decoded_rd;
 				latched_compr <= compressed_instr;
 
 				if (ENABLE_IRQ && ((decoder_trigger && !irq_active && !irq_delay && |(irq_pending & ~irq_mask)) || irq_state)) begin
 					irq_state <=
 						irq_state == 2'b00 ? 2'b01 :
 						irq_state == 2'b01 ? 2'b10 : 2'b00;
 					latched_compr <= latched_compr;
 					if (ENABLE_IRQ_QREGS)
 						latched_rd <= irqregs_offset | irq_state[0];
 					else
 						latched_rd <= irq_state[0] ? 4 : 3;
 				end else
 				if (ENABLE_IRQ && (decoder_trigger || do_waitirq) && instr_waitirq) begin
 					if (irq_pending) begin
 						latched_store <= 1;
 						reg_out <= irq_pending;
 						reg_next_pc <= current_pc + (compressed_instr ? 2 : 4);
 						mem_do_rinst <= 1;
 					end else
 						do_waitirq <= 1;
 				end else
 				if (decoder_trigger) begin
 					//`debug($display("-- %-0t", $time);)
 					irq_delay <= irq_active;
 					reg_next_pc <= current_pc + (compressed_instr ? 2 : 4);
 					if (ENABLE_TRACE)
 						latched_trace <= 1;
 					if (ENABLE_COUNTERS) begin
 						count_instr <= count_instr + 1;
 						if (!ENABLE_COUNTERS64) count_instr[63:32] <= 0;
 					end
 					if (instr_jal) begin
 						mem_do_rinst <= 1;
 						reg_next_pc <= current_pc + decoded_imm_uj;
 						latched_branch <= 1;
 					end else begin
 						mem_do_rinst <= 0;
 						mem_do_prefetch <= !instr_jalr && !instr_retirq;
 						cpu_state <= cpu_state_ld_rs1;
 					end
 				end
 			end
 
 			cpu_state_ld_rs1: begin
 				reg_op1 <= 'bx;
 				reg_op2 <= 'bx;
 
 				(* parallel_case *)
 				case (1'b1)
 					(CATCH_ILLINSN || WITH_PCPI) && instr_trap: begin
 						if (WITH_PCPI) begin
 							//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 							reg_op1 <= cpuregs_rs1;
 							dbg_rs1val <= cpuregs_rs1;
 							dbg_rs1val_valid <= 1;
 							if (ENABLE_REGS_DUALPORT) begin
 								pcpi_valid_i <= 1;
 								//`debug($display("LD_RS2: %2d 0x%08x", decoded_rs2, cpuregs_rs2);)
 								reg_sh <= cpuregs_rs2;
 								reg_op2 <= cpuregs_rs2;
 								dbg_rs2val <= cpuregs_rs2;
 								dbg_rs2val_valid <= 1;
 								if (pcpi_int_ready) begin
 									mem_do_rinst <= 1;
 									pcpi_valid_i <= 0;
 									reg_out <= pcpi_int_rd;
 									latched_store <= pcpi_int_wr;
 									cpu_state <= cpu_state_fetch;
 								end else
 								if (CATCH_ILLINSN && (pcpi_timeout || instr_ecall_ebreak)) begin
 									pcpi_valid_i <= 0;
 									//`debug($display("EBREAK OR UNSUPPORTED INSN AT 0x%08x", reg_pc);)
 									if (ENABLE_IRQ && !irq_mask[irq_ebreak] && !irq_active) begin
 										next_irq_pending[irq_ebreak] = 1;
 										cpu_state <= cpu_state_fetch;
 									end else
 										cpu_state <= cpu_state_trap;
 								end
 							end else begin
 								cpu_state <= cpu_state_ld_rs2;
 							end
 						end else begin
 							//`debug($display("EBREAK OR UNSUPPORTED INSN AT 0x%08x", reg_pc);)
 							if (ENABLE_IRQ && !irq_mask[irq_ebreak] && !irq_active) begin
 								next_irq_pending[irq_ebreak] = 1;
 								cpu_state <= cpu_state_fetch;
 							end else
 								cpu_state <= cpu_state_trap;
 						end
 					end
 					ENABLE_COUNTERS && is_rdcycle_rdcycleh_rdinstr_rdinstrh: begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							instr_rdcycle:
 								reg_out <= count_cycle[31:0];
 							instr_rdcycleh && ENABLE_COUNTERS64:
 								reg_out <= count_cycle[63:32];
 							instr_rdinstr:
 								reg_out <= count_instr[31:0];
 							instr_rdinstrh && ENABLE_COUNTERS64:
 								reg_out <= count_instr[63:32];
 						endcase
 						latched_store <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					is_lui_auipc_jal: begin
 						reg_op1 <= instr_lui ? 0 : reg_pc;
 						reg_op2 <= decoded_imm;
 						if (TWO_CYCLE_ALU)
 							alu_wait <= 1;
 						else
 							mem_do_rinst <= mem_do_prefetch;
 						cpu_state <= cpu_state_exec;
 					end
 					ENABLE_IRQ && ENABLE_IRQ_QREGS && instr_getq: begin
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_out <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						latched_store <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && ENABLE_IRQ_QREGS && instr_setq: begin
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_out <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						latched_rd <= latched_rd | irqregs_offset;
 						latched_store <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && instr_retirq: begin
 						//eoi <= 0;
 						irq_active <= 0;
 						latched_branch <= 1;
 						latched_store <= 1;
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_out <= CATCH_MISALIGN ? (cpuregs_rs1 & 32'h fffffffe) : cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && instr_maskirq: begin
 						latched_store <= 1;
 						reg_out <= irq_mask;
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						irq_mask <= cpuregs_rs1 | MASKED_IRQ;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					ENABLE_IRQ && ENABLE_IRQ_TIMER && instr_timer: begin
 						latched_store <= 1;
 						reg_out <= timer;
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						timer <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 					is_lb_lh_lw_lbu_lhu && !instr_trap: begin
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						cpu_state <= cpu_state_ldmem;
 						mem_do_rinst <= 1;
 					end
 					is_slli_srli_srai && !BARREL_SHIFTER: begin
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						reg_sh <= decoded_rs2;
 						cpu_state <= cpu_state_shift;
 					end
 					is_jalr_addi_slti_sltiu_xori_ori_andi, is_slli_srli_srai && BARREL_SHIFTER: begin
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						reg_op2 <= is_slli_srli_srai && BARREL_SHIFTER ? decoded_rs2 : decoded_imm;
 						if (TWO_CYCLE_ALU)
 							alu_wait <= 1;
 						else
 							mem_do_rinst <= mem_do_prefetch;
 						cpu_state <= cpu_state_exec;
 					end
 					default: begin
 						//`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
 						reg_op1 <= cpuregs_rs1;
 						//dbg_rs1val <= cpuregs_rs1;
 						//dbg_rs1val_valid <= 1;
 						if (ENABLE_REGS_DUALPORT) begin
 							//`debug($display("LD_RS2: %2d 0x%08x", decoded_rs2, cpuregs_rs2);)
 							reg_sh <= cpuregs_rs2;
 							reg_op2 <= cpuregs_rs2;
 							dbg_rs2val <= cpuregs_rs2;
 							dbg_rs2val_valid <= 1;
 							(* parallel_case *)
 							case (1'b1)
 								is_sb_sh_sw: begin
 									cpu_state <= cpu_state_stmem;
 									mem_do_rinst <= 1;
 								end
 								is_sll_srl_sra && !BARREL_SHIFTER: begin
 									cpu_state <= cpu_state_shift;
 								end
 								default: begin
 									if (TWO_CYCLE_ALU || (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu)) begin
 										alu_wait_2 <= TWO_CYCLE_ALU && (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu);
 										alu_wait <= 1;
 									end else
 										mem_do_rinst <= mem_do_prefetch;
 									cpu_state <= cpu_state_exec;
 								end
 							endcase
 						end else
 							cpu_state <= cpu_state_ld_rs2;
 					end
 				endcase
 			end
 
 			cpu_state_ld_rs2: begin
 				//`debug($display("LD_RS2: %2d 0x%08x", decoded_rs2, cpuregs_rs2);)
 				reg_sh <= cpuregs_rs2;
 				reg_op2 <= cpuregs_rs2;
 				dbg_rs2val <= cpuregs_rs2;
 				dbg_rs2val_valid <= 1;
 
 				(* parallel_case *)
 				case (1'b1)
 					WITH_PCPI && instr_trap: begin
 						pcpi_valid_i <= 1;
 						if (pcpi_int_ready) begin
 							mem_do_rinst <= 1;
 							pcpi_valid_i <= 0;
 							reg_out <= pcpi_int_rd;
 							latched_store <= pcpi_int_wr;
 							cpu_state <= cpu_state_fetch;
 						end else
 						if (CATCH_ILLINSN && (pcpi_timeout || instr_ecall_ebreak)) begin
 							pcpi_valid_i <= 0;
 							//`debug($display("EBREAK OR UNSUPPORTED INSN AT 0x%08x", reg_pc);)
 							if (ENABLE_IRQ && !irq_mask[irq_ebreak] && !irq_active) begin
 								next_irq_pending[irq_ebreak] = 1;
 								cpu_state <= cpu_state_fetch;
 							end else
 								cpu_state <= cpu_state_trap;
 						end
 					end
 					is_sb_sh_sw: begin
 						cpu_state <= cpu_state_stmem;
 						mem_do_rinst <= 1;
 					end
 					is_sll_srl_sra && !BARREL_SHIFTER: begin
 						cpu_state <= cpu_state_shift;
 					end
 					default: begin
 						if (TWO_CYCLE_ALU || (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu)) begin
 							alu_wait_2 <= TWO_CYCLE_ALU && (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu);
 							alu_wait <= 1;
 						end else
 							mem_do_rinst <= mem_do_prefetch;
 						cpu_state <= cpu_state_exec;
 					end
 				endcase
 			end
 
 			cpu_state_exec: begin
 				reg_out <= reg_pc + decoded_imm;
 				if ((TWO_CYCLE_ALU || TWO_CYCLE_COMPARE) && (alu_wait || alu_wait_2)) begin
 					mem_do_rinst <= mem_do_prefetch && !alu_wait_2;
 					alu_wait <= alu_wait_2;
 				end else
 				if (is_beq_bne_blt_bge_bltu_bgeu) begin
 					latched_rd <= 0;
 					latched_store <= TWO_CYCLE_COMPARE ? alu_out_0_q : alu_out_0;
 					latched_branch <= TWO_CYCLE_COMPARE ? alu_out_0_q : alu_out_0;
 					if (mem_done)
 						cpu_state <= cpu_state_fetch;
 					if (TWO_CYCLE_COMPARE ? alu_out_0_q : alu_out_0) begin
 						decoder_trigger <= 0;
 						set_mem_do_rinst = 1;
 					end
 				end else begin
 					latched_branch <= instr_jalr;
 					latched_store <= 1;
 					latched_stalu <= 1;
 					cpu_state <= cpu_state_fetch;
 				end
 			end
 
 			cpu_state_shift: begin
 				latched_store <= 1;
 				if (reg_sh == 0) begin
 					reg_out <= reg_op1;
 					mem_do_rinst <= mem_do_prefetch;
 					cpu_state <= cpu_state_fetch;
 				end else if (TWO_STAGE_SHIFT && reg_sh >= 4) begin
 					(* parallel_case, full_case *)
 					case (1'b1)
 						instr_slli || instr_sll: reg_op1 <= reg_op1 << 4;
 						instr_srli || instr_srl: reg_op1 <= reg_op1 >> 4;
 						instr_srai || instr_sra: reg_op1 <= $signed(reg_op1) >>> 4;
 					endcase
 					reg_sh <= reg_sh - 4;
 				end else begin
 					(* parallel_case, full_case *)
 					case (1'b1)
 						instr_slli || instr_sll: reg_op1 <= reg_op1 << 1;
 						instr_srli || instr_srl: reg_op1 <= reg_op1 >> 1;
 						instr_srai || instr_sra: reg_op1 <= $signed(reg_op1) >>> 1;
 					endcase
 					reg_sh <= reg_sh - 1;
 				end
 			end
 
 			cpu_state_stmem: begin
 				if (ENABLE_TRACE)
 					reg_out <= reg_op2;
 				if (!mem_do_prefetch || mem_done) begin
 					if (!mem_do_wdata) begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							instr_sb: mem_wordsize <= 2;
 							instr_sh: mem_wordsize <= 1;
 							instr_sw: mem_wordsize <= 0;
 						endcase
 						if (ENABLE_TRACE) begin
 							trace_valid <= 1;
 							trace_data <= (irq_active ? TRACE_IRQ : 0) | TRACE_ADDR | ((reg_op1 + decoded_imm) & 32'hffffffff);
 						end
 						reg_op1 <= reg_op1 + decoded_imm;
 						set_mem_do_wdata = 1;
 					end
 					if (!mem_do_prefetch && mem_done) begin
 						cpu_state <= cpu_state_fetch;
 						decoder_trigger <= 1;
 						decoder_pseudo_trigger <= 1;
 					end
 				end
 			end
 
 			cpu_state_ldmem: begin
 				latched_store <= 1;
 				if (!mem_do_prefetch || mem_done) begin
 					if (!mem_do_rdata) begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							instr_lb || instr_lbu: mem_wordsize <= 2;
 							instr_lh || instr_lhu: mem_wordsize <= 1;
 							instr_lw: mem_wordsize <= 0;
 						endcase
 						latched_is_lu <= is_lbu_lhu_lw;
 						latched_is_lh <= instr_lh;
 						latched_is_lb <= instr_lb;
 						if (ENABLE_TRACE) begin
 							trace_valid <= 1;
 							trace_data <= (irq_active ? TRACE_IRQ : 0) | TRACE_ADDR | ((reg_op1 + decoded_imm) & 32'hffffffff);
 						end
 						reg_op1 <= reg_op1 + decoded_imm;
 						set_mem_do_rdata = 1;
 					end
 					if (!mem_do_prefetch && mem_done) begin
 						(* parallel_case, full_case *)
 						case (1'b1)
 							latched_is_lu: reg_out <= mem_rdata_word;
 							latched_is_lh: reg_out <= $signed(mem_rdata_word[15:0]);
 							latched_is_lb: reg_out <= $signed(mem_rdata_word[7:0]);
 						endcase
 						decoder_trigger <= 1;
 						decoder_pseudo_trigger <= 1;
 						cpu_state <= cpu_state_fetch;
 					end
 				end
 			end
 		endcase
 
 		if (CATCH_MISALIGN && resetn && (mem_do_rdata || mem_do_wdata)) begin
 			if (mem_wordsize == 0 && reg_op1[1:0] != 0) begin
 				//`debug($display("MISALIGNED WORD: 0x%08x", reg_op1);)
 				if (ENABLE_IRQ && !irq_mask[irq_buserror] && !irq_active) begin
 					next_irq_pending[irq_buserror] = 1;
 				end else
 					cpu_state <= cpu_state_trap;
 			end
 			if (mem_wordsize == 1 && reg_op1[0] != 0) begin
 				//`debug($display("MISALIGNED HALFWORD: 0x%08x", reg_op1);)
 				if (ENABLE_IRQ && !irq_mask[irq_buserror] && !irq_active) begin
 					next_irq_pending[irq_buserror] = 1;
 				end else
 					cpu_state <= cpu_state_trap;
 			end
 		end
 		if (CATCH_MISALIGN && resetn && mem_do_rinst && (COMPRESSED_ISA ? reg_pc[0] : |reg_pc[1:0])) begin
 			//`debug($display("MISALIGNED INSTRUCTION: 0x%08x", reg_pc);)
 			if (ENABLE_IRQ && !irq_mask[irq_buserror] && !irq_active) begin
 				next_irq_pending[irq_buserror] = 1;
 			end else
 				cpu_state <= cpu_state_trap;
 		end
 		if (!CATCH_ILLINSN && decoder_trigger_q && !decoder_pseudo_trigger_q && instr_ecall_ebreak) begin
 			cpu_state <= cpu_state_trap;
 		end
 
 		if (!resetn || mem_done) begin
 			mem_do_prefetch <= 0;
 			mem_do_rinst <= 0;
 			mem_do_rdata <= 0;
 			mem_do_wdata <= 0;
 		end
 
 		if (set_mem_do_rinst)
 			mem_do_rinst <= 1;
 		if (set_mem_do_rdata)
 			mem_do_rdata <= 1;
 		if (set_mem_do_wdata)
 			mem_do_wdata <= 1;
 
 		irq_pending <= next_irq_pending & ~MASKED_IRQ;
 
 		if (!CATCH_MISALIGN) begin
 			if (COMPRESSED_ISA) begin
 				reg_pc[0] <= 0;
 				reg_next_pc[0] <= 0;
 			end else begin
 				reg_pc[1:0] <= 0;
 				reg_next_pc[1:0] <= 0;
 			end
 		end
 		current_pc = 'bx;
 	end
 
 `ifdef RISCV_FORMAL
 	reg dbg_irq_call;
 	reg dbg_irq_enter;
 	reg [31:0] dbg_irq_ret;
 	always @(posedge clk) begin
 		rvfi_valid <= resetn && (launch_next_insn || trap) && dbg_valid_insn;
 		rvfi_order <= resetn ? rvfi_order + rvfi_valid : 0;
 
 		rvfi_insn <= dbg_insn_opcode;
 		rvfi_rs1_addr <= dbg_rs1val_valid ? dbg_insn_rs1 : 0;
 		rvfi_rs2_addr <= dbg_rs2val_valid ? dbg_insn_rs2 : 0;
 		rvfi_pc_rdata <= dbg_insn_addr;
 		rvfi_rs1_rdata <= dbg_rs1val_valid ? dbg_rs1val : 0;
 		rvfi_rs2_rdata <= dbg_rs2val_valid ? dbg_rs2val : 0;
 		rvfi_trap <= trap;
 		rvfi_halt <= trap;
 		rvfi_intr <= dbg_irq_enter;
 		rvfi_mode <= 3;
 
 		if (!resetn) begin
 			dbg_irq_call <= 0;
 			dbg_irq_enter <= 0;
 		end else
 		if (rvfi_valid) begin
 			dbg_irq_call <= 0;
 			dbg_irq_enter <= dbg_irq_call;
 		end else
 		if (irq_state == 1) begin
 			dbg_irq_call <= 1;
 			dbg_irq_ret <= next_pc;
 		end
 
 		if (!resetn) begin
 			rvfi_rd_addr <= 0;
 			rvfi_rd_wdata <= 0;
 		end else
 		if (cpuregs_write && !irq_state) begin
 			rvfi_rd_addr <= latched_rd;
 			rvfi_rd_wdata <= latched_rd ? cpuregs_wrdata_i : 0;
 		end else
 		if (rvfi_valid) begin
 			rvfi_rd_addr <= 0;
 			rvfi_rd_wdata <= 0;
 		end
 
 		casez (dbg_insn_opcode)
 			32'b 0000000_?????_000??_???_?????_0001011: begin // getq
 				rvfi_rs1_addr <= 0;
 				rvfi_rs1_rdata <= 0;
 			end
 			32'b 0000001_?????_?????_???_000??_0001011: begin // setq
 				rvfi_rd_addr <= 0;
 				rvfi_rd_wdata <= 0;
 			end
 			32'b 0000010_?????_00000_???_00000_0001011: begin // retirq
 				rvfi_rs1_addr <= 0;
 				rvfi_rs1_rdata <= 0;
 			end
 		endcase
 
 		if (!dbg_irq_call) begin
 			if (dbg_mem_instr) begin
 				rvfi_mem_addr <= 0;
 				rvfi_mem_rmask <= 0;
 				rvfi_mem_wmask <= 0;
 				rvfi_mem_rdata <= 0;
 				rvfi_mem_wdata <= 0;
 			end else
 			if (dbg_mem_valid && dbg_mem_ready) begin
 				rvfi_mem_addr <= dbg_mem_addr;
 				rvfi_mem_rmask <= dbg_mem_wstrb ? 0 : ~0;
 				rvfi_mem_wmask <= dbg_mem_wstrb;
 				rvfi_mem_rdata <= dbg_mem_rdata;
 				rvfi_mem_wdata <= dbg_mem_wdata;
 			end
 		end
 	end
 
 	always @* begin
 		rvfi_pc_wdata = dbg_irq_call ? dbg_irq_ret : dbg_insn_addr;
 	end
 `endif
 
 	// Formal Verification
 `ifdef FORMAL
 	reg [3:0] last_mem_nowait;
 	always @(posedge clk)
 		last_mem_nowait <= {last_mem_nowait, mem_ready || !mem_valid_i};
 
 	// stall the memory interface for max 4 cycles
 	restrict property (|last_mem_nowait || mem_ready || !mem_valid_i);
 
 	// resetn low in first cycle, after that resetn high
 	restrict property (resetn != $initstate);
 
 	// this just makes it much easier to read traces. uncomment as needed.
 	// assume property (mem_valid || !mem_ready);
 
 	reg ok;
 	always @* begin
 		if (resetn) begin
 			// instruction fetches are read-only
 			if (mem_valid_i && mem_instr_i)
 				assert (mem_wstrb_i == 0);
 
 			// cpu_state must be valid
 			ok = 0;
 			if (cpu_state == cpu_state_trap)   ok = 1;
 			if (cpu_state == cpu_state_fetch)  ok = 1;
 			if (cpu_state == cpu_state_ld_rs1) ok = 1;
 			if (cpu_state == cpu_state_ld_rs2) ok = !ENABLE_REGS_DUALPORT;
 			if (cpu_state == cpu_state_exec)   ok = 1;
 			if (cpu_state == cpu_state_shift)  ok = 1;
 			if (cpu_state == cpu_state_stmem)  ok = 1;
 			if (cpu_state == cpu_state_ldmem)  ok = 1;
 			assert (ok);
 		end
 	end
 
 	reg last_mem_la_read = 0;
 	reg last_mem_la_write = 0;
 	reg [31:0] last_mem_la_addr;
 	reg [31:0] last_mem_la_wdata;
 	reg [3:0] last_mem_la_wstrb = 0;
 
 	always @(posedge clk) begin
 		last_mem_la_read <= mem_la_read;
 		last_mem_la_write <= mem_la_write;
 		last_mem_la_addr <= mem_la_addr;
 		last_mem_la_wdata <= mem_la_wdata;
 		last_mem_la_wstrb <= mem_la_wstrb;
 
 		if (last_mem_la_read) begin
 			assert(mem_valid_i);
 			assert(mem_addr_i == last_mem_la_addr);
 			assert(mem_wstrb_i == 0);
 		end
 		if (last_mem_la_write) begin
 			assert(mem_valid_i);
 			assert(mem_addr_i == last_mem_la_addr);
 			assert(mem_wdata_i == last_mem_la_wdata);
 			assert(mem_wstrb_i == last_mem_la_wstrb);
 		end
 		if (mem_la_read || mem_la_write) begin
 			assert(!mem_valid_i || mem_ready);
 		end
 	end
 `endif
 
endmodule
//---- Top entity
module v55b120 #(
 parameter v9b0b95 = 5,
 parameter v1ab793 = 'h76,
 parameter v498463 = 1,
 parameter v1ff51b = 8
) (
 input v379e9e,
 input [3:0] veea9f4,
 input [3:0] vda0d16,
 input [3:0] v3d0cdd,
 input [3:0] v9119d0,
 input v1cd63b,
 output v92ad22,
 output v7aeba1,
 output v47023d,
 output v265b49,
 output vfe95a2
);
 localparam p2 = v1ff51b;
 localparam p3 = v9b0b95;
 localparam p6 = v1ab793;
 localparam p27 = v498463;
 wire w0;
 wire w1;
 wire w4;
 wire w5;
 wire [0:7] w7;
 wire [0:3] w8;
 wire [0:3] w9;
 wire [0:2] w10;
 wire [0:7] w11;
 wire [0:3] w12;
 wire [0:3] w13;
 wire [0:3] w14;
 wire [0:3] w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire [0:3] w20;
 wire [0:3] w21;
 wire [0:3] w22;
 wire [0:3] w23;
 wire [0:3] w24;
 wire [0:3] w25;
 wire w26;
 wire w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 wire w33;
 wire w34;
 wire w35;
 wire w36;
 wire [0:7] w37;
 wire w38;
 wire w39;
 wire w40;
 wire [0:7] w41;
 wire [0:7] w42;
 wire [0:7] w43;
 assign v92ad22 = w0;
 assign v7aeba1 = w1;
 assign w12 = v9119d0;
 assign w13 = v3d0cdd;
 assign w14 = vda0d16;
 assign w15 = veea9f4;
 assign w16 = v1cd63b;
 assign w17 = v1cd63b;
 assign w18 = v1cd63b;
 assign w19 = v1cd63b;
 assign v47023d = w26;
 assign w28 = v379e9e;
 assign w29 = v379e9e;
 assign w30 = v379e9e;
 assign w31 = v379e9e;
 assign w32 = v379e9e;
 assign w33 = v379e9e;
 assign w34 = v379e9e;
 assign vfe95a2 = w36;
 assign w38 = v1cd63b;
 assign w39 = v1cd63b;
 assign v265b49 = w40;
 assign w9 = w8;
 assign w17 = w16;
 assign w18 = w16;
 assign w18 = w17;
 assign w19 = w16;
 assign w19 = w17;
 assign w19 = w18;
 assign w22 = w8;
 assign w22 = w9;
 assign w23 = w8;
 assign w23 = w9;
 assign w23 = w22;
 assign w29 = w28;
 assign w30 = w28;
 assign w30 = w29;
 assign w31 = w28;
 assign w31 = w29;
 assign w31 = w30;
 assign w32 = w28;
 assign w32 = w29;
 assign w32 = w30;
 assign w32 = w31;
 assign w33 = w28;
 assign w33 = w29;
 assign w33 = w30;
 assign w33 = w31;
 assign w33 = w32;
 assign w34 = w28;
 assign w34 = w29;
 assign w34 = w30;
 assign w34 = w31;
 assign w34 = w32;
 assign w34 = w33;
 assign w36 = w35;
 assign w38 = w16;
 assign w38 = w17;
 assign w38 = w18;
 assign w38 = w19;
 assign w39 = w16;
 assign w39 = w17;
 assign w39 = w18;
 assign w39 = w19;
 assign w39 = w38;
 v5ad97e #(
  .vc5c8ea(p6)
 ) vec171a (
  .v26dbdb(w11)
 );
 v76e9bf v386d4b (
  .v3fb88b(w7),
  .v97d40b(w10),
  .v3d1227(w11),
  .v062092(w37),
  .v30db33(w41),
  .v21e136(w42),
  .vbdd51f(w43)
 );
 v917222 v45c2db (
  .v285646(w8),
  .v766044(w21),
  .va191ad(w42)
 );
 va0b8df vec6754 (
  .va50a91(w8)
 );
 v917222 v50448f (
  .v285646(w9),
  .v766044(w20),
  .va191ad(w37)
 );
 v917222 v3cc599 (
  .v285646(w23),
  .v766044(w24),
  .va191ad(w41)
 );
 v917222 v05a94e (
  .v285646(w22),
  .v766044(w25),
  .va191ad(w43)
 );
 v07facf #(
  .vc20cea(p2)
 ) v0fb61d (
  .v97d6b9(w0),
  .v0b8191(w1),
  .vab2972(w4),
  .vd03772(w5),
  .vdae213(w7),
  .v9c4682(w30)
 );
 vd42255 #(
  .vaceb8f(p3)
 ) ve70865 (
  .v69602e(w4),
  .v87e8cb(w5),
  .v8b9e30(w10),
  .v192615(w33),
  .v8314fa(w35),
  .vbdbcb4(w39),
  .v680136(w40)
 );
 vef2764 #(
  .v573b2a(p27)
 ) vb0493a (
  .v4642b6(w26),
  .v6dda25(w28),
  .v27dec4(w35),
  .v92a149(w38)
 );
 vd72027 v79330b (
  .v8e4159(w15),
  .v23125b(w19),
  .ve6fa88(w20),
  .v9e41c3(w29)
 );
 vd72027 vf1da33 (
  .v8e4159(w14),
  .v23125b(w18),
  .ve6fa88(w21),
  .v9e41c3(w31)
 );
 vd72027 v1ac4cf (
  .v8e4159(w13),
  .v23125b(w17),
  .ve6fa88(w25),
  .v9e41c3(w32)
 );
 vd72027 v45980d (
  .v8e4159(w12),
  .v23125b(w16),
  .ve6fa88(w24),
  .v9e41c3(w34)
 );
endmodule

//---------------------------------------------------
//-- digitos-4
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Controlador para display SPI de 4 digitos modelo COM-1129 de SparkFun
//---------------------------------------------------
//---- Top entity
module v5ad97e #(
 parameter vc5c8ea = 0
) (
 output [7:0] v26dbdb
);
 localparam p0 = vc5c8ea;
 wire [0:7] w1;
 assign v26dbdb = w1;
 v5ad97e_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- Constante-8bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor genérico constante, de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0
//---------------------------------------------------

module v5ad97e_v465065 #(
 parameter VALUE = 0
) (
 output [7:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module v76e9bf (
 input [7:0] v71c62f,
 input [7:0] va541fd,
 input [7:0] v9b8a50,
 input [7:0] v30db33,
 input [7:0] vbdd51f,
 input [7:0] v21e136,
 input [7:0] v062092,
 input [7:0] v3d1227,
 input [2:0] v97d40b,
 output [7:0] v3fb88b
);
 wire [0:7] w0;
 wire [0:7] w1;
 wire [0:2] w2;
 wire [0:7] w3;
 wire [0:7] w4;
 wire [0:7] w5;
 wire [0:7] w6;
 wire [0:7] w7;
 wire [0:7] w8;
 wire [0:7] w9;
 assign v3fb88b = w0;
 assign w1 = v062092;
 assign w2 = v97d40b;
 assign w3 = v3d1227;
 assign w4 = v21e136;
 assign w5 = vbdd51f;
 assign w6 = v30db33;
 assign w7 = v71c62f;
 assign w8 = va541fd;
 assign w9 = v9b8a50;
 v76e9bf_ve4e0df ve4e0df (
  .o(w0),
  .i1(w1),
  .s(w2),
  .i0(w3),
  .i2(w4),
  .i3(w5),
  .i4(w6),
  .i7(w7),
  .i6(w8),
  .i5(w9)
 );
endmodule

//---------------------------------------------------
//-- Mux 8 a 1 de 8 bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Multiplexor de 8 a 1 de 8 bits
//---------------------------------------------------

module v76e9bf_ve4e0df (
 input [7:0] i7,
 input [7:0] i6,
 input [7:0] i5,
 input [7:0] i4,
 input [7:0] i3,
 input [7:0] i2,
 input [7:0] i1,
 input [7:0] i0,
 input [2:0] s,
 output [7:0] o
);
 //-- Multiplexor de 8 a 1, 
 //-- de 8 bits
 
 assign o = (s == 3'h0) ? i0 :
            (s == 3'h1) ? i1 :
            (s == 3'h2) ? i2 : 
            (s == 3'h3) ? i3 :
            (s == 3'h4) ? i4 :
            (s == 3'h5) ? i5 :
            (s == 3'h6) ? i6 :
            (s == 3'h7) ? i7 : 
            3'h0;
            
 
 
endmodule
//---- Top entity
module v917222 (
 input [3:0] v285646,
 input [3:0] v766044,
 output [7:0] va191ad
);
 wire [0:3] w0;
 wire [0:3] w1;
 wire [0:7] w2;
 assign w0 = v766044;
 assign w1 = v285646;
 assign va191ad = w2;
 v917222_v9a2a06 v9a2a06 (
  .i0(w0),
  .i1(w1),
  .o(w2)
 );
endmodule

//---------------------------------------------------
//-- Agregador-bus
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Agregador de 2 buses de 4-bits a bus de 8-bits
//---------------------------------------------------

module v917222_v9a2a06 (
 input [3:0] i1,
 input [3:0] i0,
 output [7:0] o
);
 assign o = {i1, i0};
 
endmodule
//---- Top entity
module va0b8df #(
 parameter vfffc23 = 0
) (
 output [3:0] va50a91
);
 localparam p0 = vfffc23;
 wire [0:3] w1;
 assign va50a91 = w1;
 v9274d3 #(
  .vc5c8ea(p0)
 ) v8800c6 (
  .v00a92d(w1)
 );
endmodule

//---------------------------------------------------
//-- Valor_0_4bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor constante 0 para bus de 4 bits
//---------------------------------------------------
//---- Top entity
module v9274d3 #(
 parameter vc5c8ea = 0
) (
 output [3:0] v00a92d
);
 localparam p1 = vc5c8ea;
 wire [0:3] w0;
 assign v00a92d = w0;
 v9274d3_v465065 #(
  .VALUE(p1)
 ) v465065 (
  .k(w0)
 );
endmodule

//---------------------------------------------------
//-- Constante-4bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor genérico constante, de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0
//---------------------------------------------------

module v9274d3_v465065 #(
 parameter VALUE = 0
) (
 output [3:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module v07facf #(
 parameter vc20cea = 1,
 parameter vdb812c = 1
) (
 input v9c4682,
 input v234035,
 input [7:0] vdae213,
 input vab2972,
 output v97d6b9,
 output v0b8191,
 output v66de83,
 output [7:0] v735089,
 output vd56c7f,
 output vd03772
);
 localparam p1 = vdb812c;
 localparam p15 = vc20cea;
 wire w0;
 wire [0:7] w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire [0:7] w12;
 wire w13;
 wire [0:7] w14;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 assign v66de83 = w0;
 assign v735089 = w2;
 assign w3 = vab2972;
 assign vd03772 = w4;
 assign vd56c7f = w5;
 assign w6 = v9c4682;
 assign w9 = v9c4682;
 assign w10 = v234035;
 assign w12 = vdae213;
 assign v97d6b9 = w13;
 assign w16 = v9c4682;
 assign w17 = v9c4682;
 assign w18 = v9c4682;
 assign w19 = v9c4682;
 assign w20 = v9c4682;
 assign v0b8191 = w22;
 assign w23 = vab2972;
 assign w24 = vab2972;
 assign w9 = w6;
 assign w16 = w6;
 assign w16 = w9;
 assign w17 = w6;
 assign w17 = w9;
 assign w17 = w16;
 assign w18 = w6;
 assign w18 = w9;
 assign w18 = w16;
 assign w18 = w17;
 assign w19 = w6;
 assign w19 = w9;
 assign w19 = w16;
 assign w19 = w17;
 assign w19 = w18;
 assign w20 = w6;
 assign w20 = w9;
 assign w20 = w16;
 assign w20 = w17;
 assign w20 = w18;
 assign w20 = w19;
 assign w23 = w3;
 assign w24 = w3;
 assign w24 = w23;
 assign w27 = w26;
 assign w28 = w26;
 assign w28 = w27;
 v21cfcc v8f020a (
  .v9fb85f(w8)
 );
 v58ed2b v97c59c (
  .ve8318d(w4),
  .va4102a(w20),
  .vf54559(w28)
 );
 vef2764 #(
  .v573b2a(p1)
 ) v2408dd (
  .v4642b6(w0),
  .v6dda25(w18),
  .v92a149(w24),
  .v27dec4(w27)
 );
 vaaa99e v1399d2 (
  .v27dec4(w7),
  .vcd5251(w8),
  .ve4a668(w9),
  .v4642b6(w11),
  .vd793aa(w21)
 );
 v0705a6 v24bc5f (
  .v717e81(w6),
  .v3c12b5(w7),
  .ve7f5e6(w10)
 );
 v8d6618 v61e6ec (
  .ve6fa88(w2),
  .v8e4159(w14),
  .v9e41c3(w17),
  .v23125b(w26)
 );
 vda3384 va4e38c (
  .vff2be1(w11),
  .vd21667(w12),
  .v677807(w13),
  .v4db459(w14),
  .v6dda25(w16),
  .v9e7459(w23),
  .v1624bf(w25)
 );
 vf12fd8 #(
  .v684e9b(p15)
 ) vedba67 (
  .v8567d2(w3),
  .vf2804a(w5),
  .ve91b66(w19),
  .v2b4e0e(w21),
  .v38596d(w22),
  .v0fe16d(w25),
  .v432f8e(w26)
 );
endmodule

//---------------------------------------------------
//-- spi-master
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- SPI master. Realiza una transacción
//---------------------------------------------------
//---- Top entity
module v21cfcc (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v21cfcc_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

//---------------------------------------------------
//-- 0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Un bit constante a 0
//---------------------------------------------------

module v21cfcc_vb2eccd (
 output q
);
 //-- Bit constante a 0
 assign q = 1'b0;
 
 
endmodule
//---- Top entity
module v58ed2b #(
 parameter v71e305 = 0
) (
 input va4102a,
 input vf54559,
 output va58c5b,
 output ve8318d
);
 localparam p2 = v71e305;
 wire w0;
 wire w1;
 wire w3;
 assign w0 = va4102a;
 assign ve8318d = w1;
 assign w3 = vf54559;
 v58ed2b_vb8adf8 #(
  .INI(p2)
 ) vb8adf8 (
  .clk(w0),
  .q(w1),
  .d(w3)
 );
endmodule

//---------------------------------------------------
//-- sys-DFF-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- System - D Flip-flop. Capture data every system clock cycle. Verilog implementation
//---------------------------------------------------

module v58ed2b_vb8adf8 #(
 parameter INI = 0
) (
 input clk,
 input d,
 output q
);
 //-- Initial value
 reg qi = INI;
 
 //-- Capture the input data  
 //-- on the rising edge of  
 //-- the system clock
 always @(posedge clk)
   qi <= d;
   
 //-- Connect the register with the
 //-- output
 assign q = qi;
endmodule
//---- Top entity
module vef2764 #(
 parameter v573b2a = 0
) (
 input v6dda25,
 input v27dec4,
 input v92a149,
 output v4642b6
);
 localparam p3 = v573b2a;
 wire w0;
 wire w1;
 wire w2;
 wire w4;
 assign w0 = v27dec4;
 assign w1 = v92a149;
 assign w2 = v6dda25;
 assign v4642b6 = w4;
 vef2764_v56c60e #(
  .INI(p3)
 ) v56c60e (
  .set(w0),
  .reset(w1),
  .clk(w2),
  .q(w4)
 );
endmodule

//---------------------------------------------------
//-- RS-FF-set-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- RS-FF-set-verilog. RS Flip-flop with priority set. Implementation in verilog
//---------------------------------------------------

module vef2764_v56c60e #(
 parameter INI = 0
) (
 input clk,
 input set,
 input reset,
 output q
);
 //-- Initial value
 reg qi = INI;
 
 always @(posedge clk)
 begin
 
   //-- Priority on set
   //-- It is first checked
   if (set == 1'b1) 
     qi <= 1'b1;
     
   //-- Second: check reset
   else if (reset == 1'b1)
     qi <= 1'b0;
     
   //-- In any other case the FF
   //-- remains in its current 
   //-- state (no change)
 end
 
 //-- Connect the register with the
 //-- output
 assign q = qi;
 
endmodule
//---- Top entity
module vaaa99e #(
 parameter v5462c0 = 0
) (
 input ve4a668,
 input vcd5251,
 input v27dec4,
 input vd793aa,
 output vfe2b86,
 output v13c7f2,
 output v4642b6,
 output v785874
);
 localparam p1 = v5462c0;
 wire w0;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign v4642b6 = w0;
 assign w2 = ve4a668;
 assign w3 = vcd5251;
 assign w4 = v27dec4;
 assign w5 = vd793aa;
 vaaa99e_vf7e02c #(
  .INI(p1)
 ) vf7e02c (
  .q(w0),
  .clk(w2),
  .rst(w3),
  .d(w4),
  .load(w5)
 );
endmodule

//---------------------------------------------------
//-- DFF-rst-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- DFF-rst. D Flip-Flop with load and reset. Implemented in verilog
//---------------------------------------------------

module vaaa99e_vf7e02c #(
 parameter INI = 0
) (
 input clk,
 input rst,
 input d,
 input load,
 output q
);
 //-- Initial value
 reg qi = INI;
 
 always @(posedge clk)
 begin
  
  //-- Priority for rst
  if (rst == 1'b1)
    qi <=INI;
    
  //-- Load input data
  else if (load == 1'b1)
    qi <= d;
  
 end
 
 //-- Connect the register with the
 //-- output
 assign q = qi;
 
endmodule
//---- Top entity
module v0705a6 (
 input v717e81,
 input ve7f5e6,
 output v994965,
 output v3c12b5
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v717e81;
 assign w1 = ve7f5e6;
 assign v3c12b5 = w2;
 v0705a6_ve03af9 ve03af9 (
  .clk(w0),
  .d(w1),
  .q(w2)
 );
endmodule

//---------------------------------------------------
//-- Sync-x01-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Sync-x01: 1-bit input with the system clock domain (Verilog implementation)
//---------------------------------------------------

module v0705a6_ve03af9 (
 input clk,
 input d,
 output q
);
 //-- Two D flip-flops
 //-- connected in cascade
 
 reg q1 = 0;
 reg q2 = 0;
 
 always @(posedge clk) 
 begin
   //-- First D Flip-Flop
   q1 <= d;
   
   //-- Secondo D Flip-flop
   q2 <= q1;
 end
 
 //-- Assign the output
 assign q = q2;
endmodule
//---- Top entity
module v8d6618 #(
 parameter v438624 = 0
) (
 input v9e41c3,
 input [7:0] v8e4159,
 input v23125b,
 output [7:0] ve6fa88
);
 localparam p0 = v438624;
 wire w1;
 wire w2;
 wire [0:7] w3;
 wire [0:7] w4;
 assign w1 = v9e41c3;
 assign w2 = v23125b;
 assign w3 = v8e4159;
 assign ve6fa88 = w4;
 v8d6618_vd976a7 #(
  .INI(p0)
 ) vd976a7 (
  .clk(w1),
  .load(w2),
  .d(w3),
  .q(w4)
 );
endmodule

//---------------------------------------------------
//-- 08-Reg
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 08-Reg: 8 bits Register. Verilog implementation
//---------------------------------------------------

module v8d6618_vd976a7 #(
 parameter INI = 0
) (
 input clk,
 input [7:0] d,
 input load,
 output [7:0] q
);
 //-- Generic register
 //-- Number of bits
 localparam N = 8;
 
 //-- Initial value
 reg [N-1:0] qi = INI;
 
 always @(posedge clk)
 
   //-- The value is load only if  
   //-- load is 1
   if (load == 1'b1)
     qi <= d;
   
 //-- Connect the register with the
 //-- output
 assign q = qi;
endmodule
//---- Top entity
module vda3384 #(
 parameter v4636b4 = 0
) (
 input v6dda25,
 input vff2be1,
 input [7:0] vd21667,
 input v9e7459,
 input v1624bf,
 output va90362,
 output v677807,
 output [7:0] v4db459,
 output v5edb51,
 output v4d234c
);
 localparam p2 = v4636b4;
 wire w0;
 wire w1;
 wire [0:7] w3;
 wire w4;
 wire w5;
 wire w6;
 wire [0:7] w7;
 assign w0 = v6dda25;
 assign w1 = vff2be1;
 assign v4db459 = w3;
 assign v677807 = w4;
 assign w5 = v1624bf;
 assign w6 = v9e7459;
 assign w7 = vd21667;
 vda3384_vd6f051 #(
  .INI(p2)
 ) vd6f051 (
  .clk(w0),
  .sin(w1),
  .q(w3),
  .sout(w4),
  .shift(w5),
  .load(w6),
  .din(w7)
 );
endmodule

//---------------------------------------------------
//-- 08-SL-ld
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 08-SL-ld: 8 bits shift left register with load. Verilog implementation
//---------------------------------------------------

module vda3384_vd6f051 #(
 parameter INI = 0
) (
 input clk,
 input sin,
 input [7:0] din,
 input load,
 input shift,
 output sout,
 output [7:0] q
);
 //-- Generic Shift Left register
 //-- With reset input
 //-- Number of bits
 localparam N = 8;
 
 //-- Initial value
 reg [N-1:0] qi = INI;
 
 always @(posedge clk)
 begin
 
   //-- Load
   if (load == 1)
     qi <= din[7:0];
     
   else
     //-- Shift to the right when the
     //-- shift iput is 1
     if (shift == 1)
 
       //-- Shift to the left
       qi <= {qi[N-2:0], sin};
 end
 
 //-- Serial out: 
 //-- It is the most significant bit
 assign sout = qi[N-1];
 
 //-- Paralell out
 assign q = qi;
endmodule
//---- Top entity
module vf12fd8 #(
 parameter v7b40c5 = 16,
 parameter v684e9b = 1
) (
 input ve91b66,
 input v8567d2,
 output vf2804a,
 output v38596d,
 output v2b4e0e,
 output v0fe16d,
 output v432f8e
);
 localparam p2 = v7b40c5;
 localparam p3 = v684e9b;
 wire w0;
 wire w1;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 assign v38596d = w0;
 assign v432f8e = w7;
 assign w8 = v8567d2;
 assign vf2804a = w11;
 assign v0fe16d = w14;
 assign v2b4e0e = w15;
 assign w16 = ve91b66;
 assign w17 = ve91b66;
 assign w18 = ve91b66;
 assign w19 = ve91b66;
 assign w20 = ve91b66;
 assign w21 = ve91b66;
 assign w22 = ve91b66;
 assign w23 = ve91b66;
 assign w1 = w0;
 assign w12 = w5;
 assign w13 = w0;
 assign w13 = w1;
 assign w17 = w16;
 assign w18 = w16;
 assign w18 = w17;
 assign w19 = w16;
 assign w19 = w17;
 assign w19 = w18;
 assign w20 = w16;
 assign w20 = w17;
 assign w20 = w18;
 assign w20 = w19;
 assign w21 = w16;
 assign w21 = w17;
 assign w21 = w18;
 assign w21 = w19;
 assign w21 = w20;
 assign w22 = w16;
 assign w22 = w17;
 assign w22 = w18;
 assign w22 = w19;
 assign w22 = w20;
 assign w22 = w21;
 assign w23 = w16;
 assign w23 = w17;
 assign w23 = w18;
 assign w23 = w19;
 assign w23 = w20;
 assign w23 = w21;
 assign w23 = w22;
 vb05aa7 #(
  .v9152e7(p3)
 ) vc04a45 (
  .v207fd0(w4),
  .va9e2af(w5),
  .v5688a8(w21)
 );
 vb7f713 v2d7428 (
  .v4642b6(w0),
  .vb5e8cd(w12),
  .v6dda25(w17)
 );
 v58ed2b v301d66 (
  .vf54559(w6),
  .ve8318d(w7),
  .va4102a(w23)
 );
 v58ed2b vdc2d30 (
  .vf54559(w8),
  .ve8318d(w9),
  .va4102a(w18)
 );
 v58ed2b ve0b3ea (
  .vf54559(w10),
  .ve8318d(w11),
  .va4102a(w16)
 );
 vae13be v73dcd3 (
  .ve78ab8(w1),
  .v3487af(w15),
  .ved8395(w19)
 );
 v3ae3bb vb7231e (
  .ve78ab8(w13),
  .v3487af(w14),
  .ved8395(w22)
 );
 vd1a4f5 #(
  .vaceb8f(p2)
 ) v3c84bd (
  .v69602e(w4),
  .v87e8cb(w5),
  .v8314fa(w6),
  .vbdbcb4(w9),
  .v680136(w10),
  .v192615(w20)
 );
endmodule

//---------------------------------------------------
//-- SPI-heart-2Mhz-div
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Señal de reloj de 8 pulsos, a 2MHZ / DIV (con divisor) 
//---------------------------------------------------
//---- Top entity
module vb05aa7 #(
 parameter v9152e7 = 1
) (
 input v5688a8,
 input v207fd0,
 output veabfb2,
 output va9e2af
);
 localparam p4 = v9152e7;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign veabfb2 = w0;
 assign va9e2af = w1;
 assign w2 = v5688a8;
 assign w3 = v207fd0;
 vb05aa7_v8b4ac8 #(
  .DIV(p4)
 ) v8b4ac8 (
  .p(w0),
  .tic(w1),
  .clk(w2),
  .start(w3)
 );
endmodule

//---------------------------------------------------
//-- timer-system-spi
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Temporizador en tics. La señal p está activa durante los tics indicados. ov se emite un tic al finalizar
//---------------------------------------------------

module vb05aa7_v8b4ac8 #(
 parameter DIV = 0
) (
 input clk,
 input start,
 output p,
 output tic
);
 //--------------------------------------------
 //-- Contador de tics
 //--------------------------------------------
 
 //-- Bloque timer-system especifico para usar
 //-- con el SPI. Se combina en serie con una
 //-- maquina de contar, de forma que con DIV=1
 //-- se produce una señal de reloj de 2Mhz
 //-- DIV=2  ---> 1Mhz
 //-- DIV=4 ----> 500Khz
 //-- DIV=5 ----> 250Khz
 
 //-- Añadido con respecto al timer-system normal
 localparam TICS = 3 * DIV -1;
 
 //-- Calcular el numero de bits para almacenar US tics
 localparam CB = $clog2(TICS);
 
 reg [CB-1:0] counter = 0;
 
 //-- Overflow del contador
 wire ov;
 
 //-- Señal de reset del contador
 wire rst;
 
 always @(posedge clk)
   if (rst)
     counter <= 0;
   else
     counter <= counter + 1;
       
 //-- Comprobar overflow
 assign ov = (counter == TICS-1);
     
 //---------------------------------------
 //-- Biestable de estado del timer
 //-- 0: Apagado  
 //-- 1: Funcionando
 reg q = 0;
 
 always @(posedge clk)
   if (start)
     q <= 1'b1;
   else if (rst)
     q<=1'b0;
     
 //-- Lógica de reset
 //En función de la entrada, el estado y  
 // el overflow se inicializa el contador y 
 // se habilita el corazón de tics
 assign rst = ~q | ov | start;
 
 //-- Salida de pulso
 assign p = q;
 
 //-- Salida de tic
 //-- Saca un tic cuando ha finalizado la cuenta
 assign tic = ov;
     
 
endmodule
//---- Top entity
module vb7f713 #(
 parameter v8bcde4 = 0
) (
 input v6dda25,
 input vb5e8cd,
 output v4642b6
);
 localparam p0 = v8bcde4;
 wire w1;
 wire w2;
 wire w3;
 assign w1 = v6dda25;
 assign w2 = vb5e8cd;
 assign v4642b6 = w3;
 vb7f713_v4a32dd #(
  .INI(p0)
 ) v4a32dd (
  .clk(w1),
  .t(w2),
  .q(w3)
 );
endmodule

//---------------------------------------------------
//-- TFF-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- TFF-verilog. System TFF with toggle input: It toogles on every system cycle if the input is active. Verilog implementation
//---------------------------------------------------

module vb7f713_v4a32dd #(
 parameter INI = 0
) (
 input clk,
 input t,
 output q
);
 //-- Initial value
 reg qi = INI;
 
 always @(posedge clk)
 begin
  
  //-- check the toogle input
  if (t == 1'b1)
    qi <= ~ qi;
  
 end
 
 //-- Connect the register with the
 //-- output
 assign q = qi;
 
endmodule
//---- Top entity
module vae13be (
 input ved8395,
 input ve78ab8,
 output v1c9ba2,
 output v3487af
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign w0 = ve78ab8;
 assign w1 = ved8395;
 assign w4 = ve78ab8;
 assign v3487af = w5;
 assign w4 = w0;
 v3676a0 v9d4cda (
  .v0e28cb(w2),
  .vcbab45(w3)
 );
 vba518e v57aa83 (
  .v0e28cb(w3),
  .v3ca442(w4),
  .vcbab45(w5)
 );
 v58ed2b v4953b3 (
  .vf54559(w0),
  .va4102a(w1),
  .ve8318d(w2)
 );
endmodule

//---------------------------------------------------
//-- Rising-edge-detector
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Rising-edge detector. It generates a 1-period pulse (tic) when a rising edge is detected on the input. Block implementation
//---------------------------------------------------
//---- Top entity
module v3676a0 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v3676a0_vd54ca1 vd54ca1 (
  .a(w0),
  .q(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- NOT gate (Verilog implementation)
//---------------------------------------------------

module v3676a0_vd54ca1 (
 input a,
 output q
);
 //-- NOT Gate
 assign q = ~a;
 
 
endmodule
//---- Top entity
module vba518e (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vba518e_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Two bits input And gate
//---------------------------------------------------

module vba518e_vf4938a (
 input a,
 input b,
 output c
);
 //-- AND gate
 //-- Verilog implementation
 
 assign c = a & b;
 
endmodule
//---- Top entity
module v3ae3bb (
 input ved8395,
 input ve78ab8,
 output v76dfe9,
 output v3487af
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign w0 = ve78ab8;
 assign w1 = ved8395;
 assign v3487af = w2;
 assign w3 = ve78ab8;
 assign w3 = w0;
 vba518e v6bfca1 (
  .vcbab45(w2),
  .v0e28cb(w4),
  .v3ca442(w5)
 );
 v3676a0 v84ca43 (
  .v0e28cb(w3),
  .vcbab45(w5)
 );
 v58ed2b vc2c6cf (
  .vf54559(w0),
  .va4102a(w1),
  .ve8318d(w4)
 );
endmodule

//---------------------------------------------------
//-- Falling-edge-detector CLONE
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Falling-edge detector. It generates a 1-period pulse (tic) when a falling edge is detected on the input
//---------------------------------------------------
//---- Top entity
module vd1a4f5 #(
 parameter vaceb8f = 8,
 parameter vc633fb = 1,
 parameter vd99aad = 0
) (
 input v192615,
 input vbdbcb4,
 input v87e8cb,
 output v680136,
 output [3:0] ve7048f,
 output v69602e,
 output v8314fa
);
 localparam p0 = vd99aad;
 localparam p1 = vc633fb;
 localparam p6 = vaceb8f;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w7;
 wire w8;
 wire [0:3] w9;
 wire [0:3] w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire [0:3] w18;
 wire [0:3] w19;
 wire [0:3] w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 assign w7 = vbdbcb4;
 assign w8 = v87e8cb;
 assign w11 = v192615;
 assign w12 = v192615;
 assign w13 = v192615;
 assign v680136 = w14;
 assign ve7048f = w19;
 assign v8314fa = w25;
 assign v69602e = w26;
 assign w12 = w11;
 assign w13 = w11;
 assign w13 = w12;
 assign w15 = w14;
 assign w16 = w14;
 assign w16 = w15;
 assign w19 = w18;
 assign w20 = w18;
 assign w20 = w19;
 assign w23 = w5;
 assign w24 = w5;
 assign w24 = w23;
 vb2090f v91590d (
  .vcbab45(w5),
  .v3ca442(w8),
  .v0e28cb(w16)
 );
 vb2090f vffa799 (
  .v3ca442(w2),
  .v0e28cb(w5),
  .vcbab45(w22)
 );
 vb2090f v234ec4 (
  .vcbab45(w3),
  .v3ca442(w4),
  .v0e28cb(w15)
 );
 v816138 v1cb7f5 (
  .v0e28cb(w3),
  .v3ca442(w21),
  .vcbab45(w26)
 );
 v04dced #(
  .v8d305c(p1)
 ) ve73b5c (
  .vbfafa4(w10),
  .v56adce(w18)
 );
 v2e6917 v95f509 (
  .v18e78c(w2),
  .v7b3e89(w9),
  .v6c4cc1(w20)
 );
 v33e7c0 #(
  .vc5c8ea(p6)
 ) v065438 (
  .vfc34be(w9)
 );
 v58ed2b vec7a64 (
  .ve8318d(w4),
  .va4102a(w13),
  .vf54559(w24)
 );
 v3c296a #(
  .v4800df(p0)
 ) vd0f700 (
  .v9406e4(w10),
  .v6dda25(w11),
  .va5013b(w17),
  .v4db459(w18),
  .v23125b(w23)
 );
 vaec21d vf48149 (
  .v143ae2(w7),
  .v68780b(w12),
  .v078fce(w14),
  .v3525a9(w17),
  .vf2d070(w21),
  .vb414d8(w22),
  .vd82121(w25)
 );
endmodule

//---------------------------------------------------
//-- count-4bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Máquina de contar, de 4 bits
//---------------------------------------------------
//---- Top entity
module v816138 (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 v816138_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- OR
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta OR
//---------------------------------------------------

module v816138_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta OR
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a | b;
 
 //-- endmodule
endmodule
//---- Top entity
module v04dced #(
 parameter v8d305c = 1
) (
 input [3:0] v56adce,
 output [3:0] vbfafa4
);
 localparam p0 = v8d305c;
 wire [0:3] w1;
 wire [0:3] w2;
 assign w1 = v56adce;
 assign vbfafa4 = w2;
 v04dced_va0c26a #(
  .k(p0)
 ) va0c26a (
  .a(w1),
  .s(w2)
 );
endmodule

//---------------------------------------------------
//-- sum-1op-4bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Sumador de un operando de 4 bits con una constante pasada como parámetro (No hay accarreo)
//---------------------------------------------------

module v04dced_va0c26a #(
 parameter k = 0
) (
 input [3:0] a,
 output [3:0] s
);
 assign s = a + k;
endmodule
//---- Top entity
module v2e6917 (
 input [3:0] v7b3e89,
 input [3:0] v6c4cc1,
 output v18e78c
);
 wire w0;
 wire [0:3] w1;
 wire [0:3] w2;
 assign v18e78c = w0;
 assign w1 = v6c4cc1;
 assign w2 = v7b3e89;
 v2e6917_vd75681 vd75681 (
  .eq(w0),
  .b(w1),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador de dos operandos
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de dos operandos de 4 bits
//---------------------------------------------------

module v2e6917_vd75681 (
 input [3:0] a,
 input [3:0] b,
 output eq
);
 assign eq = (a == b);
endmodule
//---- Top entity
module v33e7c0 #(
 parameter vc5c8ea = 1
) (
 output [3:0] vfc34be
);
 localparam p0 = vc5c8ea;
 wire [0:3] w1;
 assign vfc34be = w1;
 v33e7c0_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- Constante-4bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor genérico constante (menos 1), de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0
//---------------------------------------------------

module v33e7c0_v465065 #(
 parameter VALUE = 0
) (
 output [3:0] k
);
 assign k = VALUE-1;
endmodule
//---- Top entity
module v3c296a #(
 parameter v4800df = 0
) (
 input v6dda25,
 input va5013b,
 input [3:0] v9406e4,
 input v23125b,
 output ve74064,
 output v0c9980,
 output [3:0] v4db459,
 output v8c0d77
);
 localparam p0 = v4800df;
 wire [0:3] w1;
 wire w2;
 wire [0:3] w3;
 wire w4;
 wire w5;
 assign v4db459 = w1;
 assign w2 = v6dda25;
 assign w3 = v9406e4;
 assign w4 = va5013b;
 assign w5 = v23125b;
 v3c296a_vb9285f #(
  .INI(p0)
 ) vb9285f (
  .q(w1),
  .clk(w2),
  .d(w3),
  .rst(w4),
  .load(w5)
 );
endmodule

//---------------------------------------------------
//-- 04-Reg-rst
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 04-Reg-rst: 4 bits Register with reset. Verilog implementation
//---------------------------------------------------

module v3c296a_vb9285f #(
 parameter INI = 0
) (
 input clk,
 input rst,
 input [3:0] d,
 input load,
 output [3:0] q
);
 //-- Generic register with reset
 //-- Number of bits
 localparam N = 4;
 
 //-- Initial value
 reg [N-1:0] qi = INI;
 
 always @(posedge clk)
 begin
 
   //-- Reset has the priority
   if (rst == 1'b1)
     qi <= INI;
     
   else
     //-- The value is load only if  
     //-- load is 1
     if (load == 1'b1)
       qi <= d;
       
   //-- In any other case the reg
   //-- keeps its value
 end
 
 //-- Connect the register with the
 //-- output
 assign q = qi;
 
endmodule
//---- Top entity
module vaec21d (
 input v68780b,
 input v143ae2,
 input vb414d8,
 output v078fce,
 output v3525a9,
 output vf2d070,
 output vd82121
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 assign v078fce = w1;
 assign v3525a9 = w3;
 assign w4 = v143ae2;
 assign w5 = vb414d8;
 assign vf2d070 = w6;
 assign vd82121 = w8;
 assign w9 = v68780b;
 assign w10 = v68780b;
 assign w11 = v68780b;
 assign w1 = w0;
 assign w2 = w0;
 assign w2 = w1;
 assign w7 = w0;
 assign w7 = w1;
 assign w7 = w2;
 assign w10 = w9;
 assign w11 = w9;
 assign w11 = w10;
 v35f267 v719db6 (
  .v0e28cb(w2),
  .vcbab45(w3)
 );
 vef2764 vf3a8f7 (
  .v4642b6(w0),
  .v27dec4(w4),
  .v92a149(w5),
  .v6dda25(w9)
 );
 vae13be v896900 (
  .ve78ab8(w0),
  .v3487af(w6),
  .ved8395(w10)
 );
 v3ae3bb vee821f (
  .ve78ab8(w7),
  .v3487af(w8),
  .ved8395(w11)
 );
endmodule

//---------------------------------------------------
//-- Machine-state
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Biestable de almacenamiento del estado de la máquina
//---------------------------------------------------
//---- Top entity
module vd42255 #(
 parameter vaceb8f = 8,
 parameter vc633fb = 1,
 parameter vd99aad = 0
) (
 input v192615,
 input vbdbcb4,
 input v87e8cb,
 output v680136,
 output [2:0] v8b9e30,
 output v69602e,
 output v8314fa
);
 localparam p0 = vd99aad;
 localparam p1 = vc633fb;
 localparam p6 = vaceb8f;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w7;
 wire w8;
 wire [0:2] w9;
 wire [0:2] w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire [0:2] w18;
 wire [0:2] w19;
 wire [0:2] w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 assign w7 = vbdbcb4;
 assign w8 = v87e8cb;
 assign w11 = v192615;
 assign w12 = v192615;
 assign w13 = v192615;
 assign v680136 = w14;
 assign v8b9e30 = w19;
 assign v8314fa = w25;
 assign v69602e = w26;
 assign w12 = w11;
 assign w13 = w11;
 assign w13 = w12;
 assign w15 = w14;
 assign w16 = w14;
 assign w16 = w15;
 assign w19 = w18;
 assign w20 = w18;
 assign w20 = w19;
 assign w23 = w5;
 assign w24 = w5;
 assign w24 = w23;
 vb2090f v91590d (
  .vcbab45(w5),
  .v3ca442(w8),
  .v0e28cb(w16)
 );
 vb2090f vffa799 (
  .v3ca442(w2),
  .v0e28cb(w5),
  .vcbab45(w22)
 );
 vb2090f v234ec4 (
  .vcbab45(w3),
  .v3ca442(w4),
  .v0e28cb(w15)
 );
 v816138 v1cb7f5 (
  .v0e28cb(w3),
  .v3ca442(w21),
  .vcbab45(w26)
 );
 vb40da6 v8f26c8 (
  .v18e78c(w2),
  .v2e7398(w9),
  .v2af1cd(w20)
 );
 ve81274 #(
  .vc5c8ea(p6)
 ) v03d8cb (
  .v95ded6(w9)
 );
 v46aa41 #(
  .v8d305c(p1)
 ) v44f396 (
  .v6f3450(w10),
  .vba2ef8(w18)
 );
 vaec21d vb4cbbf (
  .v143ae2(w7),
  .v68780b(w12),
  .v078fce(w14),
  .v3525a9(w17),
  .vf2d070(w21),
  .vb414d8(w22),
  .vd82121(w25)
 );
 v94f5ce #(
  .v4800df(p0)
 ) vbedb28 (
  .v9406e4(w10),
  .v6dda25(w11),
  .va5013b(w17),
  .v4db459(w18),
  .v23125b(w23)
 );
 v58ed2b vfc9f0b (
  .ve8318d(w4),
  .va4102a(w13),
  .vf54559(w24)
 );
endmodule

//---------------------------------------------------
//-- count-04-3bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Máquina de contar, de 2 bits (cuenta hasta 4 ciclos)
//---------------------------------------------------
//---- Top entity
module vb40da6 (
 input [2:0] v2e7398,
 input [2:0] v2af1cd,
 output v18e78c
);
 wire w0;
 wire [0:2] w1;
 wire [0:2] w2;
 assign v18e78c = w0;
 assign w1 = v2af1cd;
 assign w2 = v2e7398;
 vb40da6_vd75681 vd75681 (
  .eq(w0),
  .b(w1),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Comparador de dos operandos
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de dos operandos de 3 bits
//---------------------------------------------------

module vb40da6_vd75681 (
 input [2:0] a,
 input [2:0] b,
 output eq
);
 assign eq = (a == b);
endmodule
//---- Top entity
module ve81274 #(
 parameter vc5c8ea = 1
) (
 output [2:0] v95ded6
);
 localparam p0 = vc5c8ea;
 wire [0:2] w1;
 assign v95ded6 = w1;
 ve81274_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- Constante-3bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor genérico constante (menos 1), de 3 bits. Su valor se introduce como parámetro. Por defecto vale 0
//---------------------------------------------------

module ve81274_v465065 #(
 parameter VALUE = 0
) (
 output [2:0] k
);
 assign k = VALUE-1;
endmodule
//---- Top entity
module v46aa41 #(
 parameter v8d305c = 1
) (
 input [2:0] vba2ef8,
 output [2:0] v6f3450
);
 localparam p0 = v8d305c;
 wire [0:2] w1;
 wire [0:2] w2;
 assign w1 = vba2ef8;
 assign v6f3450 = w2;
 v46aa41_va0c26a #(
  .k(p0)
 ) va0c26a (
  .a(w1),
  .s(w2)
 );
endmodule

//---------------------------------------------------
//-- sum-1op-3bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Sumador de un operando de 3 bits con una constante pasada como parámetro (No hay accarreo)
//---------------------------------------------------

module v46aa41_va0c26a #(
 parameter k = 0
) (
 input [2:0] a,
 output [2:0] s
);
 assign s = a + k;
endmodule
//---- Top entity
module v94f5ce #(
 parameter v4800df = 0
) (
 input v6dda25,
 input va5013b,
 input [2:0] v9406e4,
 input v23125b,
 output ve74064,
 output v0c9980,
 output [2:0] v4db459,
 output v8c0d77
);
 localparam p0 = v4800df;
 wire [0:2] w1;
 wire w2;
 wire [0:2] w3;
 wire w4;
 wire w5;
 assign v4db459 = w1;
 assign w2 = v6dda25;
 assign w3 = v9406e4;
 assign w4 = va5013b;
 assign w5 = v23125b;
 v94f5ce_vb9285f #(
  .INI(p0)
 ) vb9285f (
  .q(w1),
  .clk(w2),
  .d(w3),
  .rst(w4),
  .load(w5)
 );
endmodule

//---------------------------------------------------
//-- 03-Reg-rst
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 03-Reg-rst: 3 bits Register with reset. Verilog implementation
//---------------------------------------------------

module v94f5ce_vb9285f #(
 parameter INI = 0
) (
 input clk,
 input rst,
 input [2:0] d,
 input load,
 output [2:0] q
);
 //-- Generic register with reset
 //-- Number of bits
 localparam N = 3;
 
 //-- Initial value
 reg [N-1:0] qi = INI;
 
 always @(posedge clk)
 begin
 
   //-- Reset has the priority
   if (rst == 1'b1)
     qi <= INI;
     
   else
     //-- The value is load only if  
     //-- load is 1
     if (load == 1'b1)
       qi <= d;
       
   //-- In any other case the reg
   //-- keeps its value
 end
 
 //-- Connect the register with the
 //-- output
 assign q = qi;
 
endmodule
//---- Top entity
module vd72027 #(
 parameter v438624 = 0
) (
 input v9e41c3,
 input [3:0] v8e4159,
 input v23125b,
 output [3:0] ve6fa88
);
 localparam p0 = v438624;
 wire w1;
 wire w2;
 wire [0:3] w3;
 wire [0:3] w4;
 assign w1 = v9e41c3;
 assign w2 = v23125b;
 assign w3 = v8e4159;
 assign ve6fa88 = w4;
 vd72027_vd976a7 #(
  .INI(p0)
 ) vd976a7 (
  .clk(w1),
  .load(w2),
  .d(w3),
  .q(w4)
 );
endmodule

//---------------------------------------------------
//-- 04-Reg
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 04-Reg: 4 bits Register. Verilog implementation
//---------------------------------------------------

module vd72027_vd976a7 #(
 parameter INI = 0
) (
 input clk,
 input [3:0] d,
 input load,
 output [3:0] q
);
 //-- Generic register
 //-- Number of bits
 localparam N = 4;
 
 //-- Initial value
 reg [N-1:0] qi = INI;
 
 always @(posedge clk)
 
   //-- The value is load only if  
   //-- load is 1
   if (load == 1'b1)
     qi <= d;
   
 //-- Connect the register with the
 //-- output
 assign q = qi;
endmodule
//---- Top entity
module v6c0c4a #(
 parameter vf2d743 = 'h03000000
) (
 input v1002e2,
 input v8fadcd,
 input [31:0] vd5de6b,
 input [31:0] v6d05a9,
 input [3:0] va57c44,
 output [7:0] v9d3deb,
 output vb21f3c,
 output v980561
);
 localparam p4 = vf2d743;
 wire [0:7] w0;
 wire [0:7] w1;
 wire w2;
 wire w3;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:3] w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire [0:31] w15;
 wire [0:31] w16;
 wire w17;
 assign v9d3deb = w0;
 assign vb21f3c = w9;
 assign w10 = va57c44;
 assign v980561 = w11;
 assign w12 = v1002e2;
 assign w13 = v1002e2;
 assign w14 = v8fadcd;
 assign w15 = vd5de6b;
 assign w16 = v6d05a9;
 assign w6 = w5;
 assign w7 = w5;
 assign w7 = w6;
 assign w11 = w2;
 assign w13 = w12;
 v6f058b va3b7f3 (
  .vd65308(w1),
  .v2ebc76(w16)
 );
 vb2090f v42ed31 (
  .vcbab45(w2),
  .v3ca442(w5),
  .v0e28cb(w17)
 );
 vb2090f v023908 (
  .v0e28cb(w3),
  .v3ca442(w7),
  .vcbab45(w9)
 );
 vf9bdaf #(
  .v6b316b(p4)
 ) v671bed (
  .v18e78c(w8),
  .ve1f562(w15)
 );
 vb2090f v076142 (
  .vcbab45(w5),
  .v0e28cb(w8),
  .v3ca442(w14)
 );
 v45c913 v8e2000 (
  .v930b03(w10),
  .v593f43(w17)
 );
 v8d6618 v2244d8 (
  .ve6fa88(w0),
  .v8e4159(w1),
  .v23125b(w2),
  .v9e41c3(w12)
 );
 v58ed2b v54a510 (
  .ve8318d(w3),
  .vf54559(w6),
  .va4102a(w13)
 );
endmodule

//---------------------------------------------------
//-- IO
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerto de salida
//---------------------------------------------------
//---- Top entity
module v6f058b (
 input [31:0] v2ebc76,
 output [7:0] v4a41db,
 output [7:0] v0d81e4,
 output [7:0] v6b375c,
 output [7:0] vd65308
);
 wire [0:31] w0;
 wire [0:7] w1;
 wire [0:7] w2;
 wire [0:7] w3;
 wire [0:7] w4;
 assign w0 = v2ebc76;
 assign vd65308 = w1;
 assign v6b375c = w2;
 assign v0d81e4 = w3;
 assign v4a41db = w4;
 v6f058b_v9a2a06 v9a2a06 (
  .i(w0),
  .o0(w1),
  .o1(w2),
  .o2(w3),
  .o3(w4)
 );
endmodule

//---------------------------------------------------
//-- Separador-bus
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 32-bits en 4 buses de 8 bits
//---------------------------------------------------

module v6f058b_v9a2a06 (
 input [31:0] i,
 output [7:0] o3,
 output [7:0] o2,
 output [7:0] o1,
 output [7:0] o0
);
 assign o3 = i[31:24];
 assign o2 = i[23:16];
 assign o1 = i[15:8];
 assign o0 = i[7:0];
endmodule
//---- Top entity
module v5242e2 (
 input [31:0] v917e97,
 input [31:0] v5664d9,
 input [31:0] v918400,
 input [31:0] vae8a69,
 input vec88a9,
 input v76f74e,
 input ve3469f,
 input v58d02d,
 output [31:0] v493538
);
 wire [0:1] w0;
 wire w1;
 wire [0:31] w2;
 wire [0:31] w3;
 wire [0:31] w4;
 wire [0:31] w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:31] w10;
 wire [0:31] w11;
 wire [0:31] w12;
 assign w2 = v917e97;
 assign w3 = v5664d9;
 assign w4 = v918400;
 assign w5 = vae8a69;
 assign w6 = vec88a9;
 assign w7 = v76f74e;
 assign w8 = v58d02d;
 assign w9 = ve3469f;
 assign v493538 = w10;
 v6835fc ve38aa0 (
  .ved33bc(w0),
  .v2828a2(w2),
  .v86e1b9(w3),
  .v010aaa(w4),
  .v930664(w5),
  .v242732(w11)
 );
 veecece vfd598f (
  .vfd29cc(w0),
  .v5a4b06(w1),
  .v78af34(w6),
  .v78ff37(w7),
  .v44b9b7(w8),
  .v259301(w9)
 );
 vad96c0 v4b1d09 (
  .ve50a7b(w1),
  .v9960f4(w10),
  .v231daa(w11),
  .v95bea5(w12)
 );
 v2c97f6 vde5edd (
  .v7c9bd8(w12)
 );
endmodule

//---------------------------------------------------
//-- Bus-4
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bus de 32 bits de 4 canales
//---------------------------------------------------
//---- Top entity
module v6835fc (
 input [31:0] v2828a2,
 input [31:0] v86e1b9,
 input [31:0] v010aaa,
 input [31:0] v930664,
 input [1:0] ved33bc,
 output [31:0] v242732
);
 wire [0:31] w0;
 wire [0:31] w1;
 wire [0:31] w2;
 wire [0:31] w3;
 wire [0:31] w4;
 wire [0:1] w5;
 assign w0 = v2828a2;
 assign w1 = v86e1b9;
 assign w2 = v010aaa;
 assign w3 = v930664;
 assign v242732 = w4;
 assign w5 = ved33bc;
 v6835fc_ve4e0df ve4e0df (
  .i3(w0),
  .i2(w1),
  .i1(w2),
  .i0(w3),
  .o(w4),
  .s(w5)
 );
endmodule

//---------------------------------------------------
//-- Mux-4-1-32bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Multiplexor de 4 a 1 de 32 bits
//---------------------------------------------------

module v6835fc_ve4e0df (
 input [31:0] i3,
 input [31:0] i2,
 input [31:0] i1,
 input [31:0] i0,
 input [1:0] s,
 output [31:0] o
);
 //-- Multiplexor de 4 a 1, 
 //-- de 32 bits
 
 assign o = (s == 3'h0) ? i0 :
            (s == 3'h1) ? i1 :
            (s == 3'h2) ? i2 : 
            (s == 3'h3) ? i3 :
            32'h0;
            
 
 
endmodule
//---- Top entity
module veecece (
 input v78af34,
 input v78ff37,
 input v259301,
 input v44b9b7,
 output [1:0] vfd29cc,
 output v5a4b06
);
 wire [0:1] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign vfd29cc = w0;
 assign v5a4b06 = w1;
 assign w2 = v78af34;
 assign w3 = v78ff37;
 assign w4 = v259301;
 assign w5 = v44b9b7;
 veecece_v4407ca v4407ca (
  .y(w0),
  .zero(w1),
  .i3(w2),
  .i2(w3),
  .i1(w4),
  .i0(w5)
 );
endmodule

//---------------------------------------------------
//-- Codificador-4-2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Codificador de 4 a 2, con prioridad. La salida zero se activa cuando ninguna entrada está activad
//---------------------------------------------------

module veecece_v4407ca (
 input i3,
 input i2,
 input i1,
 input i0,
 output [1:0] y,
 output zero
);
 //-- Codificador de 4 a 1
 
 //-- Señalizar que todos son ceros
 assign zero = ({i3,i2,i1,i0}==4'b00);
 
 
 assign y = (i3 == 1) ? 2'h3 :
            (i2 == 1) ? 2'h2 :
            (i1 == 1) ? 2'h1 : 0;
           
 
endmodule
//---- Top entity
module vad96c0 (
 input [31:0] v95bea5,
 input [31:0] v231daa,
 input ve50a7b,
 output [31:0] v9960f4
);
 wire w0;
 wire [0:31] w1;
 wire [0:31] w2;
 wire [0:31] w3;
 assign w0 = ve50a7b;
 assign v9960f4 = w1;
 assign w2 = v231daa;
 assign w3 = v95bea5;
 vad96c0_v4d0636 v4d0636 (
  .sel(w0),
  .o(w1),
  .i0(w2),
  .i1(w3)
 );
endmodule

//---------------------------------------------------
//-- 32-bits-Mux-2-1-verilog
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 2-to-1 Multplexer (32-bit channels). Verilog implementation
//---------------------------------------------------

module vad96c0_v4d0636 (
 input [31:0] i1,
 input [31:0] i0,
 input sel,
 output [31:0] o
);
 //-- 2-to-1 Multiplexer 
 
 assign o = sel ? i1 : i0;
endmodule
//---- Top entity
module vaba674 #(
 parameter v6478b6 = 1024
) (
 input v04ad7a,
 input [3:0] vd728f0,
 input v22c516,
 input vd7d395,
 input [31:0] v387cca,
 input [31:0] v8d6432,
 output v69f1ab,
 output [31:0] v13ce3e
);
 localparam p2 = v6478b6;
 wire [0:21] w0;
 wire [0:23] w1;
 wire w3;
 wire [0:3] w4;
 wire w5;
 wire w6;
 wire w7;
 wire [0:31] w8;
 wire [0:31] w9;
 wire w10;
 wire w11;
 wire [0:3] w12;
 wire [0:31] w13;
 wire w14;
 wire [0:31] w15;
 wire w16;
 wire w17;
 assign w8 = v387cca;
 assign w9 = v387cca;
 assign w10 = v22c516;
 assign w11 = vd7d395;
 assign w12 = vd728f0;
 assign w13 = v8d6432;
 assign v69f1ab = w14;
 assign v13ce3e = w15;
 assign w16 = v04ad7a;
 assign w17 = v04ad7a;
 assign w5 = w3;
 assign w9 = w8;
 assign w17 = w16;
 vf0a7c1 v00b15c (
  .vd903fe(w1),
  .v2ebc76(w9)
 );
 v359d9b v2b0874 (
  .vc5ea70(w0),
  .v84d8ec(w1)
 );
 vf6999a vaf52fa (
  .v7b40f2(w3),
  .vfa6171(w6),
  .v76af38(w7),
  .v7cacc4(w11)
 );
 v127665 #(
  .v16d6b8(p2)
 ) v9d2eb0 (
  .v18e78c(w7),
  .v229966(w8)
 );
 v35f267 v19c0ab (
  .vcbab45(w6),
  .v0e28cb(w10)
 );
 v13d09a vc5282a (
  .ve2642f(w4),
  .v76af38(w5),
  .vd317b3(w12)
 );
 v58ed2b ve2ae4f (
  .vf54559(w3),
  .ve8318d(w14),
  .va4102a(w16)
 );
 v33720b v13b1f8 (
  .va79cbd(w0),
  .vc52d9a(w4),
  .v72eed5(w13),
  .v02f96f(w15),
  .vfa6941(w17)
 );
endmodule

//---------------------------------------------------
//-- RAM-1KB-soc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- RAM block (1KB) with logic
//---------------------------------------------------
//---- Top entity
module vf0a7c1 (
 input [31:0] v2ebc76,
 output [7:0] v87715f,
 output [23:0] vd903fe
);
 wire [0:31] w0;
 wire [0:23] w1;
 wire [0:7] w2;
 assign w0 = v2ebc76;
 assign vd903fe = w1;
 assign v87715f = w2;
 vf0a7c1_v9a2a06 v9a2a06 (
  .i(w0),
  .o0(w1),
  .o1(w2)
 );
endmodule

//---------------------------------------------------
//-- Separador-8-24
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 32-bits en buses de 8 y 24 bits
//---------------------------------------------------

module vf0a7c1_v9a2a06 (
 input [31:0] i,
 output [7:0] o1,
 output [23:0] o0
);
 assign o1 = i[31:24];
 assign o0 = i[23:0];
endmodule
//---- Top entity
module v359d9b (
 input [23:0] v84d8ec,
 output [21:0] vc5ea70,
 output [1:0] v47f12b
);
 wire [0:21] w0;
 wire [0:1] w1;
 wire [0:23] w2;
 assign vc5ea70 = w0;
 assign v47f12b = w1;
 assign w2 = v84d8ec;
 v359d9b_v9a2a06 v9a2a06 (
  .o1(w0),
  .o0(w1),
  .i(w2)
 );
endmodule

//---------------------------------------------------
//-- Separador-22-2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 24-bits en dos buses de 22 y 2 bits
//---------------------------------------------------

module v359d9b_v9a2a06 (
 input [23:0] i,
 output [21:0] o1,
 output [1:0] o0
);
 assign o1 = i[23:2];
 assign o0 = i[1:0];
endmodule
//---- Top entity
module vf6999a (
 input vfa6171,
 input v7cacc4,
 input v76af38,
 output v7b40f2
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign v7b40f2 = w1;
 assign w2 = vfa6171;
 assign w3 = v7cacc4;
 assign w4 = v76af38;
 vb2090f v85500b (
  .vcbab45(w0),
  .v0e28cb(w2),
  .v3ca442(w3)
 );
 vb2090f v241483 (
  .v0e28cb(w0),
  .vcbab45(w1),
  .v3ca442(w4)
 );
endmodule

//---------------------------------------------------
//-- AND3
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND de 3 entradas
//---------------------------------------------------
//---- Top entity
module v127665 #(
 parameter v16d6b8 = 1
) (
 input [31:0] v229966,
 output v18e78c
);
 localparam p1 = v16d6b8;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = v229966;
 v127665_vd75681 #(
  .B(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Menor-que-1-op
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador menor que, de un operando de 32 bits
//---------------------------------------------------

module v127665_vd75681 #(
 parameter B = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a < B);
endmodule
//---- Top entity
module v13d09a (
 input [3:0] vd317b3,
 input v76af38,
 output [3:0] ve2642f
);
 wire w0;
 wire [0:3] w1;
 wire [0:3] w2;
 assign w0 = v76af38;
 assign w1 = vd317b3;
 assign ve2642f = w2;
 v13d09a_vce9fab vce9fab (
  .b(w0),
  .a(w1),
  .o(w2)
 );
endmodule

//---------------------------------------------------
//-- AND-4-1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Puerta AND de dos operandos, de 1 y 4 bits
//---------------------------------------------------

module v13d09a_vce9fab (
 input [3:0] a,
 input b,
 output [3:0] o
);
 assign o[3] = a[3] & b;
 assign o[2] = a[2] & b;
 assign o[1] = a[1] & b;
 assign o[0] = a[0] & b;
endmodule
//---- Top entity
module v33720b (
 input vfa6941,
 input [3:0] vc52d9a,
 input [21:0] va79cbd,
 input [31:0] v72eed5,
 output [31:0] v02f96f
);
 wire [0:3] w0;
 wire [0:21] w1;
 wire [0:31] w2;
 wire [0:31] w3;
 wire w4;
 assign w0 = vc52d9a;
 assign w1 = va79cbd;
 assign w2 = v72eed5;
 assign v02f96f = w3;
 assign w4 = vfa6941;
 v33720b_v0ae20e v0ae20e (
  .wen(w0),
  .addr(w1),
  .wdata(w2),
  .rdata(w3),
  .clk(w4)
 );
endmodule

//---------------------------------------------------
//-- RAM-1KB
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Memoria ram de 1KB (256x32bits)
//---------------------------------------------------

module v33720b_v0ae20e (
 input clk,
 input [3:0] wen,
 input [21:0] addr,
 input [31:0] wdata,
 output [31:0] rdata
);
 localparam integer WORDS = 256;
 
 reg [31:0] mem [0:WORDS-1];
 reg [31:0] rdata_i;
 assign rdata = rdata_i;
 
 	always @(posedge clk) begin
 		rdata_i <= mem[addr];
 		if (wen[0]) mem[addr][ 7: 0] <= wdata[ 7: 0];
 		if (wen[1]) mem[addr][15: 8] <= wdata[15: 8];
 		if (wen[2]) mem[addr][23:16] <= wdata[23:16];
 		if (wen[3]) mem[addr][31:24] <= wdata[31:24];
 	end
endmodule
//---- Top entity
module v2b4233 #(
 parameter v55b764 = 1
) (
 input v4c8225,
 output v6d0651
);
 localparam p1 = v55b764;
 wire w0;
 wire w2;
 wire [0:5] w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 assign v6d0651 = w5;
 assign w7 = v4c8225;
 assign w8 = v4c8225;
 assign w9 = v4c8225;
 assign w6 = w2;
 assign w8 = w7;
 assign w9 = w7;
 assign w9 = w8;
 v21cfcc v3023dc (
  .v9fb85f(w4)
 );
 v2814a1 vf701ed (
  .vc7a3dc(w2),
  .v1c1141(w3)
 );
 vef2764 #(
  .v573b2a(p1)
 ) v9d4f65 (
  .v4642b6(w0),
  .v27dec4(w4),
  .v92a149(w6),
  .v6dda25(w8)
 );
 v192520 v2efe33 (
  .v65c173(w0),
  .v15fb32(w3),
  .vdd729a(w9)
 );
 vae13be vb7abdc (
  .ve78ab8(w2),
  .v3487af(w5),
  .ved8395(w7)
 );
endmodule

//---------------------------------------------------
//-- Init-tic
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Emitir un tic inicial al arrancar, y nunca más. Se esperan 32 tics antes de emitir el tic de inicialización
//---------------------------------------------------
//---- Top entity
module v2814a1 (
 input [5:0] v1c1141,
 output vc7a3dc,
 output [4:0] vaa52cb
);
 wire [0:5] w0;
 wire [0:4] w1;
 wire w2;
 assign w0 = v1c1141;
 assign vaa52cb = w1;
 assign vc7a3dc = w2;
 v2814a1_v9a2a06 v9a2a06 (
  .i(w0),
  .o0(w1),
  .o1(w2)
 );
endmodule

//---------------------------------------------------
//-- Separador-bus-1-5
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Separador de bus de 6-bits en 1 bit y bus de 5 bits
//---------------------------------------------------

module v2814a1_v9a2a06 (
 input [5:0] i,
 output o1,
 output [4:0] o0
);
 assign o1 = i[5];
 assign o0 = i[4:0];
 
endmodule
//---- Top entity
module v192520 (
 input vdd729a,
 input v65c173,
 output [5:0] v15fb32
);
 wire w0;
 wire [0:5] w1;
 wire w2;
 assign w0 = vdd729a;
 assign v15fb32 = w1;
 assign w2 = v65c173;
 v192520_ve444b7 ve444b7 (
  .clk(w0),
  .q(w1),
  .ena(w2)
 );
endmodule

//---------------------------------------------------
//-- Contador-6bits-up-system-ena
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Contador del sistema, ascendente, de 6 bits, con enable 
//---------------------------------------------------

module v192520_ve444b7 (
 input clk,
 input ena,
 output [5:0] q
);
 reg [5:0] q_i;
 assign q = q_i;
 
 always @(posedge clk)
 begin
   if (ena)
     q_i <= q_i + 1;
 end
endmodule
//---- Top entity
module v372366 #(
 parameter vbce3f7 = 1024,
 parameter v386fc7 = 'h0200_0000
) (
 input v84763f,
 input v17983a,
 input [31:0] vbee9aa,
 input vba8655,
 input v78b064,
 output vbe14dd,
 output [31:0] v202123,
 output v9b4033,
 output v0da91a,
 output v40049a
);
 localparam p0 = vbce3f7;
 localparam p1 = v386fc7;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire [0:23] w7;
 wire w8;
 wire w9;
 wire w10;
 wire [0:31] w11;
 wire w12;
 wire w13;
 wire [0:31] w14;
 wire [0:31] w15;
 wire [0:31] w16;
 wire w17;
 assign v40049a = w4;
 assign v0da91a = w5;
 assign v9b4033 = w6;
 assign w9 = v78b064;
 assign vbe14dd = w10;
 assign v202123 = w11;
 assign w12 = v84763f;
 assign w13 = v17983a;
 assign w14 = vbee9aa;
 assign w15 = vbee9aa;
 assign w16 = vbee9aa;
 assign w17 = vba8655;
 assign w15 = w14;
 assign w16 = w14;
 assign w16 = w15;
 vf0a7c1 v3c7e19 (
  .vd903fe(w7),
  .v2ebc76(w16)
 );
 v65879d #(
  .v16d6b8(p0)
 ) vba8cb0 (
  .v18e78c(w2),
  .v3d8056(w14)
 );
 v127665 #(
  .v16d6b8(p1)
 ) v3beedf (
  .v18e78c(w3),
  .v229966(w15)
 );
 vf6999a v1797a3 (
  .vfa6171(w2),
  .v7cacc4(w3),
  .v7b40f2(w8),
  .v76af38(w17)
 );
 va7f020 v285423 (
  .v8c9980(w4),
  .v8593fa(w5),
  .vf34c0c(w6),
  .v5d7746(w7),
  .v3d9a95(w8),
  .vad115e(w9),
  .v5f2c67(w10),
  .v1de298(w11),
  .vc1deab(w12),
  .v5b0577(w13)
 );
endmodule

//---------------------------------------------------
//-- Flash-soc
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Memoria flash con lógica para su mapeo
//---------------------------------------------------
//---- Top entity
module v65879d #(
 parameter v16d6b8 = 1
) (
 input [31:0] v3d8056,
 output v18e78c
);
 localparam p1 = v16d6b8;
 wire w0;
 wire [0:31] w2;
 assign v18e78c = w0;
 assign w2 = v3d8056;
 v65879d_vd75681 #(
  .B(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Mayor-igual-que-1-op
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador mayor o igual que, de un operando de 32 bits
//---------------------------------------------------

module v65879d_vd75681 #(
 parameter B = 0
) (
 input [31:0] a,
 output eq
);
 assign eq = (a >= B);
endmodule
//---- Top entity
module va7f020 (
 input vc1deab,
 input v5b0577,
 input v3d9a95,
 input [23:0] v5d7746,
 input vad115e,
 output v5f2c67,
 output [31:0] v1de298,
 output vf34c0c,
 output v8593fa,
 output v8c9980
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:3] w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire [0:31] w9;
 wire w10;
 wire [0:23] w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire [0:7] w22;
 wire [0:7] w23;
 wire w24;
 wire [0:3] w25;
 wire w26;
 wire [0:3] w27;
 wire w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 wire w33;
 wire w34;
 wire w35;
 wire w36;
 wire w37;
 wire w38;
 assign vf34c0c = w0;
 assign v8593fa = w1;
 assign w2 = vad115e;
 assign v8c9980 = w3;
 assign w5 = vc1deab;
 assign w6 = vc1deab;
 assign v5f2c67 = w7;
 assign w8 = v5b0577;
 assign v1de298 = w9;
 assign w10 = v3d9a95;
 assign w11 = v5d7746;
 assign w6 = w5;
 assign w17 = w16;
 assign w21 = w20;
 va7f020_v5dc4ea v5dc4ea (
  .flash_csb(w0),
  .flash_clk(w1),
  .cfgreg_we(w4),
  .clk(w5),
  .ready(w7),
  .resetn(w8),
  .rdata(w9),
  .valid(w10),
  .addr(w11),
  .din_ready(w12),
  .xfer_resetn(w13),
  .dout_valid(w14),
  .flash_io0_oe(w15),
  .flash_io0_di(w16),
  .din_valid(w18),
  .flash_io1_oe(w19),
  .flash_io1_di(w20),
  .dout_data(w22),
  .din_data(w23),
  .flash_io0_do(w24),
  .dout_tag(w25),
  .flash_io1_do(w26),
  .din_tag(w27),
  .xfer_csb(w28),
  .din_cont(w29),
  .xfer_dspi(w30),
  .xfer_clk(w31),
  .din_qspi(w32),
  .xfer_io0_oe(w33),
  .xfer_ddr(w34),
  .xfer_io1_oe(w35),
  .din_rd(w36),
  .xfer_io0_do(w37),
  .xfer_io1_do(w38)
 );
 va7f020_v216dc9 v216dc9 (
  .clk(w6),
  .din_ready(w12),
  .resetn(w13),
  .dout_valid(w14),
  .flash_io0_di(w17),
  .din_valid(w18),
  .flash_io1_di(w21),
  .dout_data(w22),
  .din_data(w23),
  .dout_tag(w25),
  .din_tag(w27),
  .flash_csb(w28),
  .din_cont(w29),
  .din_dspi(w30),
  .flash_clk(w31),
  .din_qspi(w32),
  .flash_io0_oe(w33),
  .din_ddr(w34),
  .flash_io1_oe(w35),
  .din_rd(w36),
  .flash_io0_do(w37),
  .flash_io1_do(w38)
 );
 vbb787c v23c4c4 (
  .v6b2a2c(w2),
  .v248807(w19),
  .v790e82(w20),
  .vba979e(w26)
 );
 vd7e6ff v64ca2e (
  .v341fc3(w3),
  .v248807(w15),
  .v790e82(w16),
  .vba979e(w24)
 );
 va0b8df v610d99 (
  .va50a91(w4)
 );
endmodule

//---------------------------------------------------
//-- spi-flash
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Acceso a la memoria flash spi
//---------------------------------------------------

module va7f020_v5dc4ea (
 input clk,
 input resetn,
 input valid,
 input [23:0] addr,
 input flash_io0_di,
 input flash_io1_di,
 input [3:0] cfgreg_we,
 input [31:0] cfgreg_di,
 input din_ready,
 input dout_valid,
 input [7:0] dout_data,
 input [3:0] dout_tag,
 input xfer_csb,
 input xfer_clk,
 input xfer_io0_oe,
 input xfer_io1_oe,
 input xfer_io0_do,
 input xfer_io1_do,
 output ready,
 output [31:0] rdata,
 output flash_csb,
 output flash_clk,
 output flash_io0_oe,
 output flash_io1_oe,
 output flash_io0_do,
 output flash_io1_do,
 output [31:0] cfgreg_do,
 output xfer_resetn,
 output din_valid,
 output [7:0] din_data,
 output [3:0] din_tag,
 output din_cont,
 output xfer_dspi,
 output din_qspi,
 output xfer_ddr,
 output din_rd
);
 reg [31:0] rdata_i;
 assign rdata = rdata_i;
 reg        xfer_resetn_i;
 assign xfer_resetn = xfer_resetn_i;
 	reg        din_valid_i;
     assign din_valid = din_valid_i;
 	reg  [7:0] din_data_i;
     assign din_data = din_data_i;
 	reg  [3:0] din_tag_i;
     assign din_tag = din_tag_i;
 	reg        din_cont_i;
     assign din_tag = din_tag_i;
 	reg        din_qspi_i;
     assign din_qspi = din_qspi_i;
 	reg        din_ddr;
 	reg        din_rd_i;
     assign din_rd = din_rd_i;
 
 wire       dout_valid_i;
 assign dout_valid = dout_valid_i;
 	wire [7:0] dout_data_i;
     assign dout_data = dout_data_i;
 	wire [3:0] dout_tag_i;
     assign dout_tag = dout_tag_i;
 
 	reg [23:0] buffer;
 
 	reg [23:0] rd_addr;
 	reg rd_valid;
 	reg rd_wait;
 	reg rd_inc;
 
 	assign ready = valid && (addr == rd_addr) && rd_valid;
 	wire jump = valid && !ready && (addr != rd_addr+4) && rd_valid;
 
 	reg softreset;
 
 	reg       config_en;      // cfgreg[31]
 	reg       config_ddr;     // cfgreg[22]
 	reg       config_qspi;    // cfgreg[21]
 	reg       config_cont;    // cfgreg[20]
 	reg [3:0] config_dummy;   // cfgreg[19:16]
 	reg [3:0] config_oe;      // cfgreg[11:8]
 	reg       config_csb;     // cfgreg[5]
 	reg       config_clk;     // cfgref[4]
 	reg [3:0] config_do;      // cfgreg[3:0]
 
 	assign cfgreg_do[31] = config_en;
 	assign cfgreg_do[30:23] = 0;
 	assign cfgreg_do[22] = config_ddr;
 	assign cfgreg_do[21] = config_qspi;
 	assign cfgreg_do[20] = config_cont;
 	assign cfgreg_do[19:16] = config_dummy;
 	assign cfgreg_do[15:12] = 0;
 	assign cfgreg_do[11:8] = {1'b0, 1'b0, flash_io1_oe, flash_io0_oe};
 	assign cfgreg_do[7:6] = 0;
 	assign cfgreg_do[5] = flash_csb;
 	assign cfgreg_do[4] = flash_clk;
 	assign cfgreg_do[3:0] = {1'b0, 1'b0, flash_io1_di, flash_io0_di};
 
 	always @(posedge clk) begin
 		softreset <= !config_en || cfgreg_we;
 		if (!resetn) begin
 			softreset <= 1;
 			config_en <= 1;
 			config_csb <= 0;
 			config_clk <= 0;
 			config_oe <= 0;
 			config_do <= 0;
 			config_ddr <= 0;
 			config_qspi <= 0;
 			config_cont <= 0;
 			config_dummy <= 8;
 		end else begin
 			if (cfgreg_we[0]) begin
 				config_csb <= cfgreg_di[5];
 				config_clk <= cfgreg_di[4];
 				config_do <= cfgreg_di[3:0];
 			end
 			if (cfgreg_we[1]) begin
 				config_oe <= cfgreg_di[11:8];
 			end
 			if (cfgreg_we[2]) begin
 				config_ddr <= cfgreg_di[22];
 				config_qspi <= cfgreg_di[21];
 				config_cont <= cfgreg_di[20];
 				config_dummy <= cfgreg_di[19:16];
 			end
 			if (cfgreg_we[3]) begin
 				config_en <= cfgreg_di[31];
 			end
 		end
 	end
 
 	
 	wire xfer_io2_oe;
 	wire xfer_io3_oe;
 
 	
 	wire xfer_io2_do;
 	wire xfer_io3_do;
 
 	reg xfer_io0_90;
 	reg xfer_io1_90;
 	reg xfer_io2_90;
 	reg xfer_io3_90;
 
 	always @(negedge clk) begin
 		xfer_io0_90 <= xfer_io0_do;
 		xfer_io1_90 <= xfer_io1_do;
 		xfer_io2_90 <= xfer_io2_do;
 		xfer_io3_90 <= xfer_io3_do;
 	end
 
 	assign flash_csb = config_en ? xfer_csb : config_csb;
 	assign flash_clk = config_en ? xfer_clk : config_clk;
 
 	assign flash_io0_oe = config_en ? xfer_io0_oe : config_oe[0];
 	assign flash_io1_oe = config_en ? xfer_io1_oe : config_oe[1];
 	//assign flash_io2_oe = config_en ? xfer_io2_oe : config_oe[2];
 	//assign flash_io3_oe = config_en ? xfer_io3_oe : config_oe[3];
 
 	assign flash_io0_do = config_en ? (config_ddr ? xfer_io0_90 : xfer_io0_do) : config_do[0];
 	assign flash_io1_do = config_en ? (config_ddr ? xfer_io1_90 : xfer_io1_do) : config_do[1];
 	//assign flash_io2_do = config_en ? (config_ddr ? xfer_io2_90 : xfer_io2_do) : config_do[2];
 	//assign flash_io3_do = config_en ? (config_ddr ? xfer_io3_90 : xfer_io3_do) : config_do[3];
 
 	wire xfer_dspi_i = din_ddr && !din_qspi_i;
     assign xfer_dspi = xfer_dspi_i;
 	wire xfer_ddr_i = din_ddr && din_qspi_i;
     assign xfer_ddr = xfer_ddr_i;
 
 	reg [3:0] state;
 
 	always @(posedge clk) begin
 		xfer_resetn_i <= 1;
 		din_valid_i <= 0;
 
 		if (!resetn || softreset) begin
 			state <= 0;
 			xfer_resetn_i <= 0;
 			rd_valid <= 0;
 			din_tag_i <= 0;
 			din_cont_i <= 0;
 			din_qspi_i <= 0;
 			din_ddr <= 0;
 			din_rd_i <= 0;
 		end else begin
 			if (dout_valid_i && dout_tag_i == 1) buffer[ 7: 0] <= dout_data_i;
 			if (dout_valid_i && dout_tag_i == 2) buffer[15: 8] <= dout_data_i;
 			if (dout_valid_i && dout_tag_i == 3) buffer[23:16] <= dout_data_i;
 			if (dout_valid_i && dout_tag_i == 4) begin
 				rdata_i <= {dout_data_i, buffer};
 				rd_addr <= rd_inc ? rd_addr + 4 : addr;
 				rd_valid <= 1;
 				rd_wait <= rd_inc;
 				rd_inc <= 1;
 			end
 
 			if (valid)
 				rd_wait <= 0;
 
 			case (state)
 				0: begin
 					din_valid_i <= 1;
 					din_data_i <= 8'h ff;
 					din_tag_i <= 0;
 					if (din_ready) begin
 						din_valid_i <= 0;
 						state <= 1;
 					end
 				end
 				1: begin
 					if (dout_valid_i) begin
 						xfer_resetn_i <= 0;
 						state <= 2;
 					end
 				end
 				2: begin
 					din_valid_i <= 1;
 					din_data_i <= 8'h ab;
 					din_tag_i <= 0;
 					if (din_ready) begin
 						din_valid_i <= 0;
 						state <= 3;
 					end
 				end
 				3: begin
 					if (dout_valid_i) begin
 						xfer_resetn_i <= 0;
 						state <= 4;
 					end
 				end
 				4: begin
 					rd_inc <= 0;
 					din_valid_i <= 1;
 					din_tag_i <= 0;
 					case ({config_ddr, config_qspi})
 						2'b11: din_data_i <= 8'h ED;
 						2'b01: din_data_i <= 8'h EB;
 						2'b10: din_data_i <= 8'h BB;
 						2'b00: din_data_i <= 8'h 03;
 					endcase
 					if (din_ready) begin
 						din_valid_i <= 0;
 						state <= 5;
 					end
 				end
 				5: begin
 					if (valid && !ready) begin
 						din_valid_i <= 1;
 						din_tag_i <= 0;
 						din_data_i <= addr[23:16];
 						din_qspi_i <= config_qspi;
 						din_ddr <= config_ddr;
 						if (din_ready) begin
 							din_valid_i <= 0;
 							state <= 6;
 						end
 					end
 				end
 				6: begin
 					din_valid_i <= 1;
 					din_tag_i <= 0;
 					din_data_i <= addr[15:8];
 					if (din_ready) begin
 						din_valid_i <= 0;
 						state <= 7;
 					end
 				end
 				7: begin
 					din_valid_i <= 1;
 					din_tag_i <= 0;
 					din_data_i <= addr[7:0];
 					if (din_ready) begin
 						din_valid_i <= 0;
 						din_data_i <= 0;
 						state <= config_qspi || config_ddr ? 8 : 9;
 					end
 				end
 				8: begin
 					din_valid_i <= 1;
 					din_tag_i <= 0;
 					din_data_i <= config_cont ? 8'h A5 : 8'h FF;
 					if (din_ready) begin
 						din_rd_i <= 1;
 						din_data_i <= config_dummy;
 						din_valid_i <= 0;
 						state <= 9;
 					end
 				end
 				9: begin
 					din_valid_i <= 1;
 					din_tag_i <= 1;
 					if (din_ready) begin
 						din_valid_i <= 0;
 						state <= 10;
 					end
 				end
 				10: begin
 					din_valid_i <= 1;
 					din_data_i <= 8'h 00;
 					din_tag_i <= 2;
 					if (din_ready) begin
 						din_valid_i <= 0;
 						state <= 11;
 					end
 				end
 				11: begin
 					din_valid_i <= 1;
 					din_tag_i <= 3;
 					if (din_ready) begin
 						din_valid_i <= 0;
 						state <= 12;
 					end
 				end
 				12: begin
 					if (!rd_wait || valid) begin
 						din_valid_i <= 1;
 						din_tag_i <= 4;
 						if (din_ready) begin
 							din_valid_i <= 0;
 							state <= 9;
 						end
 					end
 				end
 			endcase
 
 			if (jump) begin
 				rd_inc <= 0;
 				rd_valid <= 0;
 				xfer_resetn_i <= 0;
 				if (config_cont) begin
 					state <= 5;
 				end else begin
 					state <= 4;
 					din_qspi_i <= 0;
 					din_ddr <= 0;
 				end
 				din_rd_i <= 0;
 			end
 		end
 	end
endmodule

module va7f020_v216dc9 (
 input clk,
 input resetn,
 input din_valid,
 input [7:0] din_data,
 input [3:0] din_tag,
 input din_cont,
 input din_dspi,
 input din_qspi,
 input din_ddr,
 input din_rd,
 input flash_io0_di,
 input flash_io1_di,
 output din_ready,
 output dout_valid,
 output [7:0] dout_data,
 output [3:0] dout_tag,
 output flash_csb,
 output flash_clk,
 output flash_io0_oe,
 output flash_io1_oe,
 output flash_io0_do,
 output flash_io1_do
);
 reg [7:0] obuffer;
 	reg [7:0] ibuffer;
 
 	reg [3:0] count;
 	reg [3:0] dummy_count;
 
 	reg xfer_cont;
 	reg xfer_dspi;
 	reg xfer_qspi;
 	reg xfer_ddr;
 	reg xfer_ddr_q;
 	reg xfer_rd;
 	reg [3:0] xfer_tag;
 	reg [3:0] xfer_tag_q;
 
 	reg [7:0] next_obuffer;
 	reg [7:0] next_ibuffer;
 	reg [3:0] next_count;
 
 	reg fetch;
 	reg next_fetch;
 	reg last_fetch;
 	
 	
 	reg flash_csb_i;
     assign flash_csb = flash_csb_i;
 	reg flash_clk_i;
     assign flash_clk = flash_clk_i;
 
 	reg flash_io0_oe_i;
     assign flash_io0_oe = flash_io0_oe_i;
 	reg flash_io1_oe_i;
     assign flash_io1_oe = flash_io1_oe_i;
 	
 
 	reg flash_io0_do_i;
     assign flash_io0_do = flash_io0_do_i;
 	reg flash_io1_do_i;
     assign flash_io1_do = flash_io1_do_i;
 	
 
 	always @(posedge clk) begin
 		xfer_ddr_q <= xfer_ddr;
 		xfer_tag_q <= xfer_tag;
 	end
 
 	assign din_ready = din_valid && resetn && next_fetch;
 
 	assign dout_valid = (xfer_ddr_q ? fetch && !last_fetch : next_fetch && !fetch) && resetn;
 	assign dout_data = ibuffer;
 	assign dout_tag = xfer_tag_q;
 
 	always @* begin
 		flash_io0_oe_i = 0;
 		flash_io1_oe_i = 0;
 		//flash_io2_oe = 0;
 		//flash_io3_oe = 0;
 
 		flash_io0_do_i = 0;
 		flash_io1_do_i = 0;
 		//flash_io2_do = 0;
 		//flash_io3_do = 0;
 
 		next_obuffer = obuffer;
 		next_ibuffer = ibuffer;
 		next_count = count;
 		next_fetch = 0;
 
 		if (dummy_count == 0) begin
 			casez ({xfer_ddr, xfer_qspi, xfer_dspi})
 				3'b 000: begin
 					flash_io0_oe_i = 1;
 					flash_io0_do_i = obuffer[7];
 
 					if (flash_clk_i) begin
 						next_obuffer = {obuffer[6:0], 1'b 0};
 						next_count = count - |count;
 					end else begin
 						next_ibuffer = {ibuffer[6:0], flash_io1_di};
 					end
 
 					next_fetch = (next_count == 0);
 				end
 				3'b 01?: begin
 					flash_io0_oe_i = !xfer_rd;
 					flash_io1_oe_i = !xfer_rd;
 					//flash_io2_oe = !xfer_rd;
 					//flash_io3_oe = !xfer_rd;
 
 					flash_io0_do_i = obuffer[4];
 					flash_io1_do_i = obuffer[5];
 					//flash_io2_do = obuffer[6];
 					//flash_io3_do = obuffer[7];
 
 					if (flash_clk_i) begin
 						next_obuffer = {obuffer[3:0], 4'b 0000};
 						next_count = count - {|count, 2'b00};
 					end else begin
 						next_ibuffer = {ibuffer[3:0], 1'b0, 1'b0, flash_io1_di, flash_io0_di};
 					end
 
 					next_fetch = (next_count == 0);
 				end
 				3'b 11?: begin
 					flash_io0_oe_i = !xfer_rd;
 					flash_io1_oe_i = !xfer_rd;
 					//flash_io2_oe = !xfer_rd;
 					//flash_io3_oe = !xfer_rd;
 
 					flash_io0_do_i = obuffer[4];
 					flash_io1_do_i = obuffer[5];
 					//flash_io2_do = obuffer[6];
 					//flash_io3_do = obuffer[7];
 
 					next_obuffer = {obuffer[3:0], 4'b 0000};
 					next_ibuffer = {ibuffer[3:0], 1'b0, 1'b0, flash_io1_di, flash_io0_di};
 					next_count = count - {|count, 2'b00};
 
 					next_fetch = (next_count == 0);
 				end
 				3'b ??1: begin
 					flash_io0_oe_i = !xfer_rd;
 					flash_io1_oe_i = !xfer_rd;
 
 					flash_io0_do_i = obuffer[6];
 					flash_io1_do_i = obuffer[7];
 
 					if (flash_clk_i) begin
 						next_obuffer = {obuffer[5:0], 2'b 00};
 						next_count = count - {|count, 1'b0};
 					end else begin
 						next_ibuffer = {ibuffer[5:0], flash_io1_di, flash_io0_di};
 					end
 
 					next_fetch = (next_count == 0);
 				end
 			endcase
 		end
 	end
 
 	always @(posedge clk) begin
 		if (!resetn) begin
 			fetch <= 1;
 			last_fetch <= 1;
 			flash_csb_i <= 1;
 			flash_clk_i <= 0;
 			count <= 0;
 			dummy_count <= 0;
 			xfer_tag <= 0;
 			xfer_cont <= 0;
 			xfer_dspi <= 0;
 			xfer_qspi <= 0;
 			xfer_ddr <= 0;
 			xfer_rd <= 0;
 		end else begin
 			fetch <= next_fetch;
 			last_fetch <= xfer_ddr ? fetch : 1;
 			if (dummy_count) begin
 				flash_clk_i <= !flash_clk_i && !flash_csb_i;
 				dummy_count <= dummy_count - flash_clk_i;
 			end else
 			if (count) begin
 				flash_clk_i <= !flash_clk_i && !flash_csb_i;
 				obuffer <= next_obuffer;
 				ibuffer <= next_ibuffer;
 				count <= next_count;
 			end
 			if (din_valid && din_ready) begin
 				flash_csb_i <= 0;
 				flash_clk_i <= 0;
 
 				count <= 8;
 				dummy_count <= din_rd ? din_data : 0;
 				obuffer <= din_data;
 
 				xfer_tag <= din_tag;
 				xfer_cont <= din_cont;
 				xfer_dspi <= din_dspi;
 				xfer_qspi <= din_qspi;
 				xfer_ddr <= din_ddr;
 				xfer_rd <= din_rd;
 			end
 		end
 	end
endmodule
//---- Top entity
module vbb787c (
 input v6b2a2c,
 input v248807,
 input vba979e,
 output v790e82
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v6b2a2c;
 assign w1 = v248807;
 assign w2 = vba979e;
 assign v790e82 = w3;
 vbb787c_v43ad2d v43ad2d (
  .pin(w0),
  .oe(w1),
  .dout(w2),
  .din(w3)
 );
endmodule

//---------------------------------------------------
//-- InOut
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bloque para entrada-salida (PIO)
//---------------------------------------------------

module vbb787c_v43ad2d (
 input pin,
 input oe,
 input dout,
 output din
);
   SB_IO #(
       .PIN_TYPE(6'b1010_01),
       .PULLUP(1'b0)
   ) triState (
       .PACKAGE_PIN(pin),
       .OUTPUT_ENABLE(oe),
       .D_OUT_0(dout),
       .D_IN_0(din)
   );
endmodule
//---- Top entity
module vd7e6ff (
 input v248807,
 input vba979e,
 output v341fc3,
 output v790e82
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v248807;
 assign w1 = vba979e;
 assign v790e82 = w2;
 assign v341fc3 = w3;
 vd7e6ff_v43ad2d v43ad2d (
  .oe(w0),
  .dout(w1),
  .din(w2),
  .pin(w3)
 );
endmodule

//---------------------------------------------------
//-- In-out-right
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bloque inout, con conexión de pin por la derecha
//---------------------------------------------------

module vd7e6ff_v43ad2d (
 input oe,
 input dout,
 output pin,
 output din
);
   SB_IO #(
       .PIN_TYPE(6'b1010_01),
       .PULLUP(1'b0)
   ) triState (
       .PACKAGE_PIN(pin),
       .OUTPUT_ENABLE(oe),
       .D_OUT_0(dout),
       .D_IN_0(din)
   );
endmodule
//---- Top entity
module va1329e (
 input v91de83,
 input vf72f35,
 input v6f1466,
 input v8cc0d0,
 input [7:0] v0d6dda,
 output [7:0] v0acf62
);
 wire w0;
 wire w1;
 wire [0:7] w2;
 wire w3;
 wire w4;
 wire [0:7] w5;
 wire w6;
 wire w7;
 wire w8;
 assign w0 = v6f1466;
 assign w1 = v8cc0d0;
 assign v0acf62 = w2;
 assign w3 = vf72f35;
 assign w5 = v0d6dda;
 assign w7 = v91de83;
 assign w8 = v91de83;
 assign w8 = w7;
 v10d933 v3bb133 (
  .v6a82dd(w0),
  .vd4e5d7(w4),
  .v444878(w7)
 );
 v10d933 v66881e (
  .v6a82dd(w1),
  .vd4e5d7(w6),
  .v444878(w8)
 );
 va1329e_v97efd3 v97efd3 (
  .Data_Out(w2),
  .rstn(w3),
  .Trigger(w4),
  .Data_In(w5),
  .Starter(w6)
 );
endmodule


module va1329e_v97efd3 (
 input rstn,
 input Trigger,
 input Starter,
 input [7:0] Data_In,
 output [7:0] Data_Out
);
 reg [7:0] opA;
 reg [7:0] opB;
 reg [7:0] op;
 reg [7:0] result;
 reg [1:0] counter;
 reg [7:0] lastValue;
 reg [7:0] showReg;
 reg flag;
 
 reg res_valid; 
 
 always @(posedge Starter or negedge rstn) begin
     if(!rstn) begin
         opA <= 0; 
         opB <= 0; 
         op <= 0; 
         counter <= 0; 
         lastValue <= 8'h00;
         showReg <= 0;
     end else begin
         if(counter == 2'd0) begin
             opA = Data_In;
             showReg = opA;
             counter = 2'd1;
         end else if (counter == 2'd1) begin
             opB = Data_In;
             showReg = opB;
             counter = 2'd2;
         end else if (counter == 2'd2) begin
             op = Data_In;
             showReg = op;
             counter = 2'd3;
         end
     end
 end
 
 always @(posedge Trigger or negedge rstn) begin
     if(!rstn) begin
         res_valid = 0;
         result = 0; 
     end else begin
         if (op == 8'd1) begin
             result <= opA + opB;
         end else if (op == 8'd2) begin
             result <= opA - opB;
         end else if (op == 8'd3) begin
             result <= opA * opB;
         end else if (op == 8'd4) begin
             result <= (opB != 0) ? (opA / opB) : 8'd0;
         end else begin
             result <= 8'd15;
         end
         res_valid = 1'b1; 
     end
 end
 
 //assign Data_Out = result;
 
 assign Data_Out = res_valid ? result : showReg;
endmodule
//---- Top entity
module v10d933 (
 input v444878,
 input v6a82dd,
 output vd4e5d7
);
 wire w0;
 wire w1;
 wire w2;
 assign vd4e5d7 = w0;
 assign w1 = v444878;
 assign w2 = v6a82dd;
 v10d933_va7041c va7041c (
  .out(w0),
  .clk(w1),
  .in(w2)
 );
endmodule

//---------------------------------------------------
//-- Debouncer
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Remove the rebound on a mechanical switch
//---------------------------------------------------

module v10d933_va7041c (
 input clk,
 input in,
 output out
);
 //-- Debouncer Circuit
 //-- It produces a stable output when the
 //-- input signal is bouncing
 
 reg btn_prev = 0;
 reg btn_out_r = 0;
 
 reg [16:0] counter = 0;
 
 
 always @(posedge clk) begin
 
   //-- If btn_prev and btn_in are differents
   if (btn_prev ^ in == 1'b1) begin
     
       //-- Reset the counter
       counter <= 0;
       
       //-- Capture the button status
       btn_prev <= in;
   end
     
   //-- If no timeout, increase the counter
   else if (counter[16] == 1'b0)
       counter <= counter + 1;
       
   else
     //-- Set the output to the stable value
     btn_out_r <= btn_prev;
 
 end
 
 assign out = btn_out_r;
 
endmodule
